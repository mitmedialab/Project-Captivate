
stm32_mainMCU_Code_v3.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   0000013c  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00002678  08000140  08000140  00010140  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       000000d0  080027b8  080027b8  000127b8  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .init_array   00000004  08002888  08002888  00012888  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  4 .fini_array   00000004  0800288c  0800288c  0001288c  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .data         00000010  20000004  08002890  00020004  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .bss          0000068c  20000014  080028a0  00020014  2**2
                  ALLOC
  7 ._user_heap_stack 00000600  200006a0  080028a0  000206a0  2**0
                  ALLOC
  8 .ARM.attributes 00000030  00000000  00000000  00020014  2**0
                  CONTENTS, READONLY
  9 MAPPING_TABLE 00000024  20030000  20030000  00030000  2**2
                  ALLOC
 10 MB_MEM1       00000094  20030024  20030024  00030000  2**2
                  ALLOC
 11 MB_MEM2       00000020  200300b8  200300b8  00030000  2**2
                  ALLOC
 12 .debug_info   0002be60  00000000  00000000  00020044  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_abbrev 000048c9  00000000  00000000  0004bea4  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_loc    000123b8  00000000  00000000  0005076d  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_aranges 00001978  00000000  00000000  00062b28  2**3
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_ranges 00001c00  00000000  00000000  000644a0  2**3
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_line   00010682  00000000  00000000  000660a0  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_str    0000c708  00000000  00000000  00076722  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .comment      0000007b  00000000  00000000  00082e2a  2**0
                  CONTENTS, READONLY
 20 .debug_frame  00004274  00000000  00000000  00082ea8  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

08000140 <__do_global_dtors_aux>:
 8000140:	b510      	push	{r4, lr}
 8000142:	4c05      	ldr	r4, [pc, #20]	; (8000158 <__do_global_dtors_aux+0x18>)
 8000144:	7823      	ldrb	r3, [r4, #0]
 8000146:	b933      	cbnz	r3, 8000156 <__do_global_dtors_aux+0x16>
 8000148:	4b04      	ldr	r3, [pc, #16]	; (800015c <__do_global_dtors_aux+0x1c>)
 800014a:	b113      	cbz	r3, 8000152 <__do_global_dtors_aux+0x12>
 800014c:	4804      	ldr	r0, [pc, #16]	; (8000160 <__do_global_dtors_aux+0x20>)
 800014e:	f3af 8000 	nop.w
 8000152:	2301      	movs	r3, #1
 8000154:	7023      	strb	r3, [r4, #0]
 8000156:	bd10      	pop	{r4, pc}
 8000158:	20000014 	.word	0x20000014
 800015c:	00000000 	.word	0x00000000
 8000160:	080027a0 	.word	0x080027a0

08000164 <frame_dummy>:
 8000164:	b508      	push	{r3, lr}
 8000166:	4b03      	ldr	r3, [pc, #12]	; (8000174 <frame_dummy+0x10>)
 8000168:	b11b      	cbz	r3, 8000172 <frame_dummy+0xe>
 800016a:	4903      	ldr	r1, [pc, #12]	; (8000178 <frame_dummy+0x14>)
 800016c:	4803      	ldr	r0, [pc, #12]	; (800017c <frame_dummy+0x18>)
 800016e:	f3af 8000 	nop.w
 8000172:	bd08      	pop	{r3, pc}
 8000174:	00000000 	.word	0x00000000
 8000178:	20000018 	.word	0x20000018
 800017c:	080027a0 	.word	0x080027a0

08000180 <strcmp>:
 8000180:	f810 2b01 	ldrb.w	r2, [r0], #1
 8000184:	f811 3b01 	ldrb.w	r3, [r1], #1
 8000188:	2a01      	cmp	r2, #1
 800018a:	bf28      	it	cs
 800018c:	429a      	cmpcs	r2, r3
 800018e:	d0f7      	beq.n	8000180 <strcmp>
 8000190:	1ad0      	subs	r0, r2, r3
 8000192:	4770      	bx	lr

08000194 <TL_TRACES_EvtReceived>:
  return;
}

/* Received trace buffer from M0 */
void TL_TRACES_EvtReceived( TL_EvtPacket_t * hcievt )
{
 8000194:	b508      	push	{r3, lr}
  /* - Cast to TL_AsynchEvt_t* to get "real" payload (without Sub Evt code 2bytes),
     - (-2) to size to remove Sub Evt Code */
  DbgTraceWrite(1U, (const unsigned char *) ((TL_AsynchEvt_t *)(hcievt->evtserial.evt.payload))->payload, hcievt->evtserial.evt.plen - 2U);
#endif /* CFG_DEBUG_TRACE */
  /* Release buffer */
  TL_MM_EvtDone( hcievt );
 8000196:	f002 f959 	bl	800244c <TL_MM_EvtDone>
}
 800019a:	bd08      	pop	{r3, pc}

0800019c <HW_UART_Transmit_IT>:
    return;
}

void HW_UART_Transmit_IT(hw_uart_id_t hw_uart_id, uint8_t *p_data, uint16_t size,  void (*cb)(void))
{
    switch (hw_uart_id)
 800019c:	b100      	cbz	r0, 80001a0 <HW_UART_Transmit_IT+0x4>
 800019e:	4770      	bx	lr
{
 80001a0:	b508      	push	{r3, lr}
    {
#if (CFG_HW_USART1_ENABLED == 1)
        case hw_uart1:
            HW_UART_TX_IT(huart1, USART1);
 80001a2:	4804      	ldr	r0, [pc, #16]	; (80001b4 <HW_UART_Transmit_IT+0x18>)
 80001a4:	6003      	str	r3, [r0, #0]
 80001a6:	4804      	ldr	r0, [pc, #16]	; (80001b8 <HW_UART_Transmit_IT+0x1c>)
 80001a8:	4b04      	ldr	r3, [pc, #16]	; (80001bc <HW_UART_Transmit_IT+0x20>)
 80001aa:	6003      	str	r3, [r0, #0]
 80001ac:	f001 fd16 	bl	8001bdc <HAL_UART_Transmit_IT>
        default:
            break;
    }

    return;
}
 80001b0:	bd08      	pop	{r3, pc}
 80001b2:	bf00      	nop
 80001b4:	200005cc 	.word	0x200005cc
 80001b8:	20000610 	.word	0x20000610
 80001bc:	40013800 	.word	0x40013800

080001c0 <SystemClock_Config>:
/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
 80001c0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80001c2:	b0af      	sub	sp, #188	; 0xbc
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 80001c4:	2248      	movs	r2, #72	; 0x48
 80001c6:	2100      	movs	r1, #0
 80001c8:	a81c      	add	r0, sp, #112	; 0x70
 80001ca:	f002 fae1 	bl	8002790 <memset>
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 80001ce:	2400      	movs	r4, #0
 80001d0:	9415      	str	r4, [sp, #84]	; 0x54
 80001d2:	9416      	str	r4, [sp, #88]	; 0x58
 80001d4:	9417      	str	r4, [sp, #92]	; 0x5c
 80001d6:	9418      	str	r4, [sp, #96]	; 0x60
 80001d8:	9419      	str	r4, [sp, #100]	; 0x64
 80001da:	941a      	str	r4, [sp, #104]	; 0x68
 80001dc:	941b      	str	r4, [sp, #108]	; 0x6c
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
 80001de:	2250      	movs	r2, #80	; 0x50
 80001e0:	4621      	mov	r1, r4
 80001e2:	a801      	add	r0, sp, #4
 80001e4:	f002 fad4 	bl	8002790 <memset>

  /** Macro to configure the PLL multiplication factor 
  */
  __HAL_RCC_PLL_PLLM_CONFIG(RCC_PLLM_DIV2);
 80001e8:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80001ec:	68da      	ldr	r2, [r3, #12]
 80001ee:	f022 0270 	bic.w	r2, r2, #112	; 0x70
 80001f2:	f042 0210 	orr.w	r2, r2, #16
 80001f6:	60da      	str	r2, [r3, #12]
  /** Macro to configure the PLL clock source 
  */
  __HAL_RCC_PLL_PLLSOURCE_CONFIG(RCC_PLLSOURCE_HSE);
 80001f8:	68da      	ldr	r2, [r3, #12]
 80001fa:	f042 0203 	orr.w	r2, r2, #3
 80001fe:	60da      	str	r2, [r3, #12]
  *         @arg @ref LL_RCC_LSEDRIVE_HIGH
  * @retval None
  */
__STATIC_INLINE void LL_RCC_LSE_SetDriveCapability(uint32_t LSEDrive)
{
  MODIFY_REG(RCC->BDCR, RCC_BDCR_LSEDRV, LSEDrive);
 8000200:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 8000204:	f022 0218 	bic.w	r2, r2, #24
 8000208:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
  /** Configure LSE Drive Capability 
  */
  __HAL_RCC_LSEDRIVE_CONFIG(RCC_LSEDRIVE_LOW);
  /** Configure the main internal regulator output voltage 
  */
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 800020c:	4a25      	ldr	r2, [pc, #148]	; (80002a4 <SystemClock_Config+0xe4>)
 800020e:	6813      	ldr	r3, [r2, #0]
 8000210:	f423 63c0 	bic.w	r3, r3, #1536	; 0x600
 8000214:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8000218:	6013      	str	r3, [r2, #0]
 800021a:	6813      	ldr	r3, [r2, #0]
 800021c:	f403 63c0 	and.w	r3, r3, #1536	; 0x600
 8000220:	9300      	str	r3, [sp, #0]
 8000222:	9b00      	ldr	r3, [sp, #0]
  /** Initializes the CPU, AHB and APB busses clocks 
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI|RCC_OSCILLATORTYPE_LSI1
 8000224:	230f      	movs	r3, #15
 8000226:	931c      	str	r3, [sp, #112]	; 0x70
                              |RCC_OSCILLATORTYPE_HSE|RCC_OSCILLATORTYPE_LSE;
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
 8000228:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 800022c:	931d      	str	r3, [sp, #116]	; 0x74
  RCC_OscInitStruct.LSEState = RCC_LSE_ON;
 800022e:	2701      	movs	r7, #1
 8000230:	971e      	str	r7, [sp, #120]	; 0x78
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
 8000232:	f44f 7680 	mov.w	r6, #256	; 0x100
 8000236:	961f      	str	r6, [sp, #124]	; 0x7c
  RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
 8000238:	2340      	movs	r3, #64	; 0x40
 800023a:	9320      	str	r3, [sp, #128]	; 0x80
  RCC_OscInitStruct.LSIState = RCC_LSI_ON;
 800023c:	2305      	movs	r3, #5
 800023e:	9321      	str	r3, [sp, #132]	; 0x84
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
 8000240:	9427      	str	r4, [sp, #156]	; 0x9c
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 8000242:	a81c      	add	r0, sp, #112	; 0x70
 8000244:	f000 fb2c 	bl	80008a0 <HAL_RCC_OscConfig>
  {
    Error_Handler();
  }
  /** Configure the SYSCLKSource, HCLK, PCLK1 and PCLK2 clocks dividers 
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK4|RCC_CLOCKTYPE_HCLK2
 8000248:	236f      	movs	r3, #111	; 0x6f
 800024a:	9315      	str	r3, [sp, #84]	; 0x54
                              |RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_HSE;
 800024c:	2502      	movs	r5, #2
 800024e:	9516      	str	r5, [sp, #88]	; 0x58
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 8000250:	9417      	str	r4, [sp, #92]	; 0x5c
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
 8000252:	9418      	str	r4, [sp, #96]	; 0x60
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
 8000254:	9419      	str	r4, [sp, #100]	; 0x64
  RCC_ClkInitStruct.AHBCLK2Divider = RCC_SYSCLK_DIV1;
 8000256:	941a      	str	r4, [sp, #104]	; 0x68
  RCC_ClkInitStruct.AHBCLK4Divider = RCC_SYSCLK_DIV1;
 8000258:	941b      	str	r4, [sp, #108]	; 0x6c

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_1) != HAL_OK)
 800025a:	4639      	mov	r1, r7
 800025c:	a815      	add	r0, sp, #84	; 0x54
 800025e:	f000 fea9 	bl	8000fb4 <HAL_RCC_ClockConfig>
  {
    Error_Handler();
  }
  /** Initializes the peripherals clocks 
  */
  PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_SMPS|RCC_PERIPHCLK_RFWAKEUP
 8000262:	f643 4305 	movw	r3, #15365	; 0x3c05
 8000266:	9301      	str	r3, [sp, #4]
                              |RCC_PERIPHCLK_RTC|RCC_PERIPHCLK_USART1
                              |RCC_PERIPHCLK_I2C1|RCC_PERIPHCLK_ADC;
  PeriphClkInitStruct.PLLSAI1.PLLN = 6;
 8000268:	2306      	movs	r3, #6
 800026a:	9302      	str	r3, [sp, #8]
  PeriphClkInitStruct.PLLSAI1.PLLP = RCC_PLLP_DIV2;
 800026c:	f44f 3300 	mov.w	r3, #131072	; 0x20000
 8000270:	9303      	str	r3, [sp, #12]
  PeriphClkInitStruct.PLLSAI1.PLLQ = RCC_PLLQ_DIV2;
 8000272:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 8000276:	9304      	str	r3, [sp, #16]
  PeriphClkInitStruct.PLLSAI1.PLLR = RCC_PLLR_DIV2;
 8000278:	f04f 5300 	mov.w	r3, #536870912	; 0x20000000
 800027c:	9305      	str	r3, [sp, #20]
  PeriphClkInitStruct.PLLSAI1.PLLSAI1ClockOut = RCC_PLLSAI1_ADCCLK;
 800027e:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
 8000282:	9306      	str	r3, [sp, #24]
  PeriphClkInitStruct.Usart1ClockSelection = RCC_USART1CLKSOURCE_PCLK2;
 8000284:	9407      	str	r4, [sp, #28]
  PeriphClkInitStruct.I2c1ClockSelection = RCC_I2C1CLKSOURCE_PCLK1;
 8000286:	f44f 3240 	mov.w	r2, #196608	; 0x30000
 800028a:	9209      	str	r2, [sp, #36]	; 0x24
  PeriphClkInitStruct.AdcClockSelection = RCC_ADCCLKSOURCE_PLLSAI1;
 800028c:	9310      	str	r3, [sp, #64]	; 0x40
  PeriphClkInitStruct.RTCClockSelection = RCC_RTCCLKSOURCE_LSE;
 800028e:	9611      	str	r6, [sp, #68]	; 0x44
  PeriphClkInitStruct.RFWakeUpClockSelection = RCC_RFWKPCLKSOURCE_LSI;
 8000290:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 8000294:	9312      	str	r3, [sp, #72]	; 0x48
  PeriphClkInitStruct.SmpsClockSelection = RCC_SMPSCLKSOURCE_HSE;
 8000296:	9513      	str	r5, [sp, #76]	; 0x4c
  PeriphClkInitStruct.SmpsDivSelection = RCC_SMPSCLKDIV_RANGE0;
 8000298:	9414      	str	r4, [sp, #80]	; 0x50

  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 800029a:	a801      	add	r0, sp, #4
 800029c:	f001 f933 	bl	8001506 <HAL_RCCEx_PeriphCLKConfig>
    Error_Handler();
  }
  /* USER CODE BEGIN Smps */

  /* USER CODE END Smps */
}
 80002a0:	b02f      	add	sp, #188	; 0xbc
 80002a2:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80002a4:	58000400 	.word	0x58000400

080002a8 <main>:
{
 80002a8:	b508      	push	{r3, lr}
  HAL_Init();
 80002aa:	f000 f96d 	bl	8000588 <HAL_Init>
  SystemClock_Config();
 80002ae:	f7ff ff87 	bl	80001c0 <SystemClock_Config>
	  HAL_Delay(1000);
 80002b2:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 80002b6:	f000 f995 	bl	80005e4 <HAL_Delay>
 80002ba:	e7fa      	b.n	80002b2 <main+0xa>

080002bc <HAL_TIM_PeriodElapsedCallback>:
  * a global variable "uwTick" used as application time base.
  * @param  htim : TIM handle
  * @retval None
  */
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
 80002bc:	b508      	push	{r3, lr}
  /* USER CODE BEGIN Callback 0 */

  /* USER CODE END Callback 0 */
  if (htim->Instance == TIM1) {
 80002be:	6802      	ldr	r2, [r0, #0]
 80002c0:	4b03      	ldr	r3, [pc, #12]	; (80002d0 <HAL_TIM_PeriodElapsedCallback+0x14>)
 80002c2:	429a      	cmp	r2, r3
 80002c4:	d000      	beq.n	80002c8 <HAL_TIM_PeriodElapsedCallback+0xc>
    HAL_IncTick();
  }
  /* USER CODE BEGIN Callback 1 */

  /* USER CODE END Callback 1 */
}
 80002c6:	bd08      	pop	{r3, pc}
    HAL_IncTick();
 80002c8:	f000 f974 	bl	80005b4 <HAL_IncTick>
}
 80002cc:	e7fb      	b.n	80002c6 <HAL_TIM_PeriodElapsedCallback+0xa>
 80002ce:	bf00      	nop
 80002d0:	40012c00 	.word	0x40012c00

080002d4 <HAL_MspInit>:
/* USER CODE END 0 */
/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
 80002d4:	b500      	push	{lr}
 80002d6:	b083      	sub	sp, #12
  * @retval None
*/
__STATIC_INLINE void LL_AHB3_GRP1_EnableClock(uint32_t Periphs)
{
  __IO uint32_t tmpreg;
  SET_BIT(RCC->AHB3ENR, Periphs);
 80002d8:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80002dc:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 80002de:	f442 2200 	orr.w	r2, r2, #524288	; 0x80000
 80002e2:	651a      	str	r2, [r3, #80]	; 0x50
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_BIT(RCC->AHB3ENR, Periphs);
 80002e4:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 80002e6:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
 80002ea:	9301      	str	r3, [sp, #4]
  (void)tmpreg;
 80002ec:	9b01      	ldr	r3, [sp, #4]

  __HAL_RCC_HSEM_CLK_ENABLE();

  /* System interrupt init*/
  /* PendSV_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(PendSV_IRQn, 15, 0);
 80002ee:	2200      	movs	r2, #0
 80002f0:	210f      	movs	r1, #15
 80002f2:	f06f 0001 	mvn.w	r0, #1
 80002f6:	f000 f99b 	bl	8000630 <HAL_NVIC_SetPriority>

  /* USER CODE BEGIN MspInit 1 */
  HAL_NVIC_SetPriority(IPCC_C1_RX_IRQn , 15, 0);
 80002fa:	2200      	movs	r2, #0
 80002fc:	210f      	movs	r1, #15
 80002fe:	202c      	movs	r0, #44	; 0x2c
 8000300:	f000 f996 	bl	8000630 <HAL_NVIC_SetPriority>
  HAL_NVIC_SetPriority(IPCC_C1_TX_IRQn , 15, 0);
 8000304:	2200      	movs	r2, #0
 8000306:	210f      	movs	r1, #15
 8000308:	202d      	movs	r0, #45	; 0x2d
 800030a:	f000 f991 	bl	8000630 <HAL_NVIC_SetPriority>
  /* USER CODE END MspInit 1 */
}
 800030e:	b003      	add	sp, #12
 8000310:	f85d fb04 	ldr.w	pc, [sp], #4

08000314 <HAL_InitTick>:
  *         reset by HAL_Init() or at any time when clock is configured, by HAL_RCC_ClockConfig(). 
  * @param  TickPriority: Tick interrupt priority.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 8000314:	b500      	push	{lr}
 8000316:	b08b      	sub	sp, #44	; 0x2c
  uint32_t              uwTimclock = 0;
  uint32_t              uwPrescalerValue = 0;
  uint32_t              pFLatency;
  
  /*Configure the TIM1 IRQ priority */
  HAL_NVIC_SetPriority(TIM1_UP_TIM16_IRQn, TickPriority ,0); 
 8000318:	2200      	movs	r2, #0
 800031a:	4601      	mov	r1, r0
 800031c:	2019      	movs	r0, #25
 800031e:	f000 f987 	bl	8000630 <HAL_NVIC_SetPriority>
  
  /* Enable the TIM1 global Interrupt */
  HAL_NVIC_EnableIRQ(TIM1_UP_TIM16_IRQn); 
 8000322:	2019      	movs	r0, #25
 8000324:	f000 f9b8 	bl	8000698 <HAL_NVIC_EnableIRQ>
  * @retval None
*/
__STATIC_INLINE void LL_APB2_GRP1_EnableClock(uint32_t Periphs)
{
  __IO uint32_t tmpreg;
  SET_BIT(RCC->APB2ENR, Periphs);
 8000328:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800032c:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 800032e:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 8000332:	661a      	str	r2, [r3, #96]	; 0x60
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_BIT(RCC->APB2ENR, Periphs);
 8000334:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8000336:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 800033a:	9301      	str	r3, [sp, #4]
  (void)tmpreg;
 800033c:	9b01      	ldr	r3, [sp, #4]
  
  /* Enable TIM1 clock */
  __HAL_RCC_TIM1_CLK_ENABLE();
  
  /* Get clock configuration */
  HAL_RCC_GetClockConfig(&clkconfig, &pFLatency);
 800033e:	a902      	add	r1, sp, #8
 8000340:	a803      	add	r0, sp, #12
 8000342:	f000 ffe5 	bl	8001310 <HAL_RCC_GetClockConfig>
  
  /* Compute TIM1 clock */
  uwTimclock = HAL_RCC_GetPCLK2Freq();
 8000346:	f000 ffd1 	bl	80012ec <HAL_RCC_GetPCLK2Freq>
   
  /* Compute the prescaler value to have TIM1 counter clock equal to 1MHz */
  uwPrescalerValue = (uint32_t) ((uwTimclock / 1000000) - 1);
 800034a:	4b0d      	ldr	r3, [pc, #52]	; (8000380 <HAL_InitTick+0x6c>)
 800034c:	fba3 2300 	umull	r2, r3, r3, r0
 8000350:	0c9b      	lsrs	r3, r3, #18
 8000352:	3b01      	subs	r3, #1
  
  /* Initialize TIM1 */
  htim1.Instance = TIM1;
 8000354:	480b      	ldr	r0, [pc, #44]	; (8000384 <HAL_InitTick+0x70>)
 8000356:	4a0c      	ldr	r2, [pc, #48]	; (8000388 <HAL_InitTick+0x74>)
 8000358:	6002      	str	r2, [r0, #0]
  + Period = [(TIM1CLK/1000) - 1]. to have a (1/1000) s time base.
  + Prescaler = (uwTimclock/1000000 - 1) to have a 1MHz counter clock.
  + ClockDivision = 0
  + Counter direction = Up
  */
  htim1.Init.Period = (1000000 / 1000) - 1;
 800035a:	f240 32e7 	movw	r2, #999	; 0x3e7
 800035e:	60c2      	str	r2, [r0, #12]
  htim1.Init.Prescaler = uwPrescalerValue;
 8000360:	6043      	str	r3, [r0, #4]
  htim1.Init.ClockDivision = 0;
 8000362:	2300      	movs	r3, #0
 8000364:	6103      	str	r3, [r0, #16]
  htim1.Init.CounterMode = TIM_COUNTERMODE_UP;
 8000366:	6083      	str	r3, [r0, #8]
  if(HAL_TIM_Base_Init(&htim1) == HAL_OK)
 8000368:	f001 fb78 	bl	8001a5c <HAL_TIM_Base_Init>
 800036c:	b118      	cbz	r0, 8000376 <HAL_InitTick+0x62>
    /* Start the TIM time Base generation in interrupt mode */
    return HAL_TIM_Base_Start_IT(&htim1);
  }
  
  /* Return function status */
  return HAL_ERROR;
 800036e:	2001      	movs	r0, #1
}
 8000370:	b00b      	add	sp, #44	; 0x2c
 8000372:	f85d fb04 	ldr.w	pc, [sp], #4
    return HAL_TIM_Base_Start_IT(&htim1);
 8000376:	4803      	ldr	r0, [pc, #12]	; (8000384 <HAL_InitTick+0x70>)
 8000378:	f001 fa50 	bl	800181c <HAL_TIM_Base_Start_IT>
 800037c:	e7f8      	b.n	8000370 <HAL_InitTick+0x5c>
 800037e:	bf00      	nop
 8000380:	431bde83 	.word	0x431bde83
 8000384:	200005d0 	.word	0x200005d0
 8000388:	40012c00 	.word	0x40012c00

0800038c <NMI_Handler>:

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */

  /* USER CODE END NonMaskableInt_IRQn 1 */
}
 800038c:	4770      	bx	lr

0800038e <HardFault_Handler>:

/**
  * @brief This function handles Hard fault interrupt.
  */
void HardFault_Handler(void)
{
 800038e:	e7fe      	b.n	800038e <HardFault_Handler>

08000390 <MemManage_Handler>:

/**
  * @brief This function handles Memory management fault.
  */
void MemManage_Handler(void)
{
 8000390:	e7fe      	b.n	8000390 <MemManage_Handler>

08000392 <BusFault_Handler>:

/**
  * @brief This function handles Prefetch fault, memory access fault.
  */
void BusFault_Handler(void)
{
 8000392:	e7fe      	b.n	8000392 <BusFault_Handler>

08000394 <UsageFault_Handler>:

/**
  * @brief This function handles Undefined instruction or illegal state.
  */
void UsageFault_Handler(void)
{
 8000394:	e7fe      	b.n	8000394 <UsageFault_Handler>

08000396 <DebugMon_Handler>:

  /* USER CODE END DebugMonitor_IRQn 0 */
  /* USER CODE BEGIN DebugMonitor_IRQn 1 */

  /* USER CODE END DebugMonitor_IRQn 1 */
}
 8000396:	4770      	bx	lr

08000398 <DMA1_Channel1_IRQHandler>:

/**
  * @brief This function handles DMA1 channel1 global interrupt.
  */
void DMA1_Channel1_IRQHandler(void)
{
 8000398:	b508      	push	{r3, lr}
  /* USER CODE BEGIN DMA1_Channel1_IRQn 0 */

  /* USER CODE END DMA1_Channel1_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_adc1);
 800039a:	4802      	ldr	r0, [pc, #8]	; (80003a4 <DMA1_Channel1_IRQHandler+0xc>)
 800039c:	f000 f98a 	bl	80006b4 <HAL_DMA_IRQHandler>
  /* USER CODE BEGIN DMA1_Channel1_IRQn 1 */

  /* USER CODE END DMA1_Channel1_IRQn 1 */
}
 80003a0:	bd08      	pop	{r3, pc}
 80003a2:	bf00      	nop
 80003a4:	20000568 	.word	0x20000568

080003a8 <TIM1_UP_TIM16_IRQHandler>:

/**
  * @brief This function handles TIM1 update interrupt and TIM16 global interrupt.
  */
void TIM1_UP_TIM16_IRQHandler(void)
{
 80003a8:	b508      	push	{r3, lr}
  /* USER CODE BEGIN TIM1_UP_TIM16_IRQn 0 */

  /* USER CODE END TIM1_UP_TIM16_IRQn 0 */
  HAL_TIM_IRQHandler(&htim1);
 80003aa:	4802      	ldr	r0, [pc, #8]	; (80003b4 <TIM1_UP_TIM16_IRQHandler+0xc>)
 80003ac:	f001 fa50 	bl	8001850 <HAL_TIM_IRQHandler>
  /* USER CODE BEGIN TIM1_UP_TIM16_IRQn 1 */

  /* USER CODE END TIM1_UP_TIM16_IRQn 1 */
}
 80003b0:	bd08      	pop	{r3, pc}
 80003b2:	bf00      	nop
 80003b4:	200005d0 	.word	0x200005d0

080003b8 <IPCC_C1_TX_IRQHandler>:

/* USER CODE BEGIN 1 */
void IPCC_C1_TX_IRQHandler(void)
{
 80003b8:	b508      	push	{r3, lr}
  HW_IPCC_Tx_Handler();
 80003ba:	f002 f90b 	bl	80025d4 <HW_IPCC_Tx_Handler>

  return;
}
 80003be:	bd08      	pop	{r3, pc}

080003c0 <IPCC_C1_RX_IRQHandler>:
void IPCC_C1_RX_IRQHandler(void)
{
 80003c0:	b508      	push	{r3, lr}
  HW_IPCC_Rx_Handler();
 80003c2:	f002 f97b 	bl	80026bc <HW_IPCC_Rx_Handler>
  return;
}
 80003c6:	bd08      	pop	{r3, pc}

080003c8 <SystemInit>:
  /* Configure the Vector Table location add offset address ------------------*/
#if defined(VECT_TAB_SRAM) && defined(VECT_TAB_BASE_ADDRESS)  
  /* program in SRAMx */
  SCB->VTOR = VECT_TAB_BASE_ADDRESS | VECT_TAB_OFFSET;  /* Vector Table Relocation in Internal SRAMx for CPU1 */
#else    /* program in FLASH */
  SCB->VTOR = VECT_TAB_OFFSET;              /* Vector Table Relocation in Internal FLASH */
 80003c8:	4b16      	ldr	r3, [pc, #88]	; (8000424 <SystemInit+0x5c>)
 80003ca:	2100      	movs	r1, #0
 80003cc:	6099      	str	r1, [r3, #8]
#endif

  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << (10UL*2UL))|(3UL << (11UL*2UL)));  /* set CP10 and CP11 Full Access */
 80003ce:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 80003d2:	f442 0270 	orr.w	r2, r2, #15728640	; 0xf00000
 80003d6:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
  #endif
  
  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set MSION bit */
  RCC->CR |= RCC_CR_MSION;
 80003da:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80003de:	681a      	ldr	r2, [r3, #0]
 80003e0:	f042 0201 	orr.w	r2, r2, #1
 80003e4:	601a      	str	r2, [r3, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00070000U;
 80003e6:	f44f 22e0 	mov.w	r2, #458752	; 0x70000
 80003ea:	609a      	str	r2, [r3, #8]

  /* Reset PLLSAI1ON, PLLON, HSECSSON, HSEON, HSION, and MSIPLLON bits */
  RCC->CR &= (uint32_t)0xFAF6FEFBU;
 80003ec:	6818      	ldr	r0, [r3, #0]
 80003ee:	f1a2 62a2 	sub.w	r2, r2, #84934656	; 0x5100000
 80003f2:	f2a2 1205 	subw	r2, r2, #261	; 0x105
 80003f6:	4002      	ands	r2, r0
 80003f8:	601a      	str	r2, [r3, #0]

  /*!< Reset LSI1 and LSI2 bits */
  RCC->CSR &= (uint32_t)0xFFFFFFFAU;
 80003fa:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
 80003fe:	f022 0205 	bic.w	r2, r2, #5
 8000402:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
  
  /*!< Reset HSI48ON  bit */
  RCC->CRRCR &= (uint32_t)0xFFFFFFFEU;
 8000406:	f8d3 2098 	ldr.w	r2, [r3, #152]	; 0x98
 800040a:	f022 0201 	bic.w	r2, r2, #1
 800040e:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
    
  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x22041000U;
 8000412:	4a05      	ldr	r2, [pc, #20]	; (8000428 <SystemInit+0x60>)
 8000414:	60da      	str	r2, [r3, #12]

#if defined(STM32WB55xx)
  /* Reset PLLSAI1CFGR register */
  RCC->PLLSAI1CFGR = 0x22041000U;
 8000416:	611a      	str	r2, [r3, #16]
#endif
  
  /* Reset HSEBYP bit */
  RCC->CR &= 0xFFFBFFFFU;
 8000418:	681a      	ldr	r2, [r3, #0]
 800041a:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 800041e:	601a      	str	r2, [r3, #0]

  /* Disable all interrupts */
  RCC->CIER = 0x00000000;
 8000420:	6199      	str	r1, [r3, #24]
}
 8000422:	4770      	bx	lr
 8000424:	e000ed00 	.word	0xe000ed00
 8000428:	22041000 	.word	0x22041000

0800042c <SystemCoreClockUpdate>:
  uint32_t tmp, msirange, pllvco, pllr, pllsource , pllm;

  /* Get MSI Range frequency--------------------------------------------------*/

  /*MSI frequency range in Hz*/
  msirange = MSIRangeTable[(RCC->CR & RCC_CR_MSIRANGE) >> RCC_CR_MSIRANGE_Pos];
 800042c:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 8000430:	6813      	ldr	r3, [r2, #0]
 8000432:	f3c3 1303 	ubfx	r3, r3, #4, #4
 8000436:	4929      	ldr	r1, [pc, #164]	; (80004dc <SystemCoreClockUpdate+0xb0>)
 8000438:	f851 1023 	ldr.w	r1, [r1, r3, lsl #2]

  /* Get SYSCLK source -------------------------------------------------------*/
  switch (RCC->CFGR & RCC_CFGR_SWS)
 800043c:	6893      	ldr	r3, [r2, #8]
 800043e:	f003 030c 	and.w	r3, r3, #12
 8000442:	2b0c      	cmp	r3, #12
 8000444:	d846      	bhi.n	80004d4 <SystemCoreClockUpdate+0xa8>
 8000446:	e8df f003 	tbb	[pc, r3]
 800044a:	4507      	.short	0x4507
 800044c:	45174545 	.word	0x45174545
 8000450:	451b4545 	.word	0x451b4545
 8000454:	4545      	.short	0x4545
 8000456:	1f          	.byte	0x1f
 8000457:	00          	.byte	0x00
  {
    case 0x00:   /* MSI used as system clock source */
      SystemCoreClock = msirange;
 8000458:	4b21      	ldr	r3, [pc, #132]	; (80004e0 <SystemCoreClockUpdate+0xb4>)
 800045a:	6019      	str	r1, [r3, #0]
      break;
  }
  
  /* Compute HCLK clock frequency --------------------------------------------*/
  /* Get HCLK1 prescaler */
  tmp = AHBPrescTable[((RCC->CFGR & RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos)];
 800045c:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8000460:	689b      	ldr	r3, [r3, #8]
 8000462:	f3c3 1303 	ubfx	r3, r3, #4, #4
 8000466:	4a1f      	ldr	r2, [pc, #124]	; (80004e4 <SystemCoreClockUpdate+0xb8>)
 8000468:	f852 1023 	ldr.w	r1, [r2, r3, lsl #2]
  /* HCLK clock frequency */
  SystemCoreClock = SystemCoreClock / tmp;
 800046c:	4a1c      	ldr	r2, [pc, #112]	; (80004e0 <SystemCoreClockUpdate+0xb4>)
 800046e:	6813      	ldr	r3, [r2, #0]
 8000470:	fbb3 f3f1 	udiv	r3, r3, r1
 8000474:	6013      	str	r3, [r2, #0]

}
 8000476:	4770      	bx	lr
        SystemCoreClock = HSI_VALUE;
 8000478:	4b19      	ldr	r3, [pc, #100]	; (80004e0 <SystemCoreClockUpdate+0xb4>)
 800047a:	4a1b      	ldr	r2, [pc, #108]	; (80004e8 <SystemCoreClockUpdate+0xbc>)
 800047c:	601a      	str	r2, [r3, #0]
      break;
 800047e:	e7ed      	b.n	800045c <SystemCoreClockUpdate+0x30>
      SystemCoreClock = HSE_VALUE;
 8000480:	4b17      	ldr	r3, [pc, #92]	; (80004e0 <SystemCoreClockUpdate+0xb4>)
 8000482:	4a1a      	ldr	r2, [pc, #104]	; (80004ec <SystemCoreClockUpdate+0xc0>)
 8000484:	601a      	str	r2, [r3, #0]
      break;
 8000486:	e7e9      	b.n	800045c <SystemCoreClockUpdate+0x30>
      pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC);
 8000488:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800048c:	68da      	ldr	r2, [r3, #12]
 800048e:	f002 0203 	and.w	r2, r2, #3
      pllm = ((RCC->PLLCFGR & RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1UL ;
 8000492:	68db      	ldr	r3, [r3, #12]
 8000494:	f3c3 1302 	ubfx	r3, r3, #4, #3
 8000498:	3301      	adds	r3, #1
      if(pllsource == 0x02UL) /* HSI used as PLL clock source */
 800049a:	2a02      	cmp	r2, #2
 800049c:	d012      	beq.n	80004c4 <SystemCoreClockUpdate+0x98>
      else if(pllsource == 0x03UL) /* HSE used as PLL clock source */
 800049e:	2a03      	cmp	r2, #3
 80004a0:	d014      	beq.n	80004cc <SystemCoreClockUpdate+0xa0>
        pllvco = (msirange / pllm);
 80004a2:	fbb1 f3f3 	udiv	r3, r1, r3
      pllvco = pllvco * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
 80004a6:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 80004aa:	68ca      	ldr	r2, [r1, #12]
 80004ac:	f3c2 2206 	ubfx	r2, r2, #8, #7
 80004b0:	fb03 f302 	mul.w	r3, r3, r2
      pllr = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLR) >> RCC_PLLCFGR_PLLR_Pos) + 1UL);
 80004b4:	68ca      	ldr	r2, [r1, #12]
 80004b6:	0f52      	lsrs	r2, r2, #29
 80004b8:	3201      	adds	r2, #1
      SystemCoreClock = pllvco/pllr;
 80004ba:	fbb3 f3f2 	udiv	r3, r3, r2
 80004be:	4a08      	ldr	r2, [pc, #32]	; (80004e0 <SystemCoreClockUpdate+0xb4>)
 80004c0:	6013      	str	r3, [r2, #0]
      break;
 80004c2:	e7cb      	b.n	800045c <SystemCoreClockUpdate+0x30>
        pllvco = (HSI_VALUE / pllm);
 80004c4:	4a08      	ldr	r2, [pc, #32]	; (80004e8 <SystemCoreClockUpdate+0xbc>)
 80004c6:	fbb2 f3f3 	udiv	r3, r2, r3
 80004ca:	e7ec      	b.n	80004a6 <SystemCoreClockUpdate+0x7a>
        pllvco = (HSE_VALUE / pllm);
 80004cc:	4a07      	ldr	r2, [pc, #28]	; (80004ec <SystemCoreClockUpdate+0xc0>)
 80004ce:	fbb2 f3f3 	udiv	r3, r2, r3
 80004d2:	e7e8      	b.n	80004a6 <SystemCoreClockUpdate+0x7a>
      SystemCoreClock = msirange;
 80004d4:	4b02      	ldr	r3, [pc, #8]	; (80004e0 <SystemCoreClockUpdate+0xb4>)
 80004d6:	6019      	str	r1, [r3, #0]
      break;
 80004d8:	e7c0      	b.n	800045c <SystemCoreClockUpdate+0x30>
 80004da:	bf00      	nop
 80004dc:	08002844 	.word	0x08002844
 80004e0:	20000004 	.word	0x20000004
 80004e4:	080027e4 	.word	0x080027e4
 80004e8:	00f42400 	.word	0x00f42400
 80004ec:	01e84800 	.word	0x01e84800

080004f0 <HAL_TIM_Base_MspInit>:
}

void HAL_TIM_Base_MspInit(TIM_HandleTypeDef* tim_baseHandle)
{

  if(tim_baseHandle->Instance==TIM2)
 80004f0:	6803      	ldr	r3, [r0, #0]
 80004f2:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 80004f6:	d000      	beq.n	80004fa <HAL_TIM_Base_MspInit+0xa>
 80004f8:	4770      	bx	lr
{
 80004fa:	b082      	sub	sp, #8
  SET_BIT(RCC->APB1ENR1, Periphs);
 80004fc:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8000500:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 8000502:	f042 0201 	orr.w	r2, r2, #1
 8000506:	659a      	str	r2, [r3, #88]	; 0x58
  tmpreg = READ_BIT(RCC->APB1ENR1, Periphs);
 8000508:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 800050a:	f003 0301 	and.w	r3, r3, #1
 800050e:	9301      	str	r3, [sp, #4]
  (void)tmpreg;
 8000510:	9b01      	ldr	r3, [sp, #4]
    __HAL_RCC_TIM2_CLK_ENABLE();
  /* USER CODE BEGIN TIM2_MspInit 1 */

  /* USER CODE END TIM2_MspInit 1 */
  }
}
 8000512:	b002      	add	sp, #8
 8000514:	4770      	bx	lr

08000516 <CopyDataInit>:
  bl LoopCopyDataInit
.endm

.section  .text.data_initializers
CopyDataInit:
  ldr r4, [r2, r3]
 8000516:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
 8000518:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
 800051a:	3304      	adds	r3, #4

0800051c <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
 800051c:	18c4      	adds	r4, r0, r3
  cmp r4, r1
 800051e:	428c      	cmp	r4, r1
  bcc  CopyDataInit
 8000520:	d3f9      	bcc.n	8000516 <CopyDataInit>
  bx lr
 8000522:	4770      	bx	lr

08000524 <FillZerobss>:

FillZerobss:
  str  r3, [r0]
 8000524:	6003      	str	r3, [r0, #0]
  adds r0, r0, #4
 8000526:	3004      	adds	r0, #4

08000528 <LoopFillZerobss>:

LoopFillZerobss:
  cmp r0, r1
 8000528:	4288      	cmp	r0, r1
  bcc FillZerobss
 800052a:	d3fb      	bcc.n	8000524 <FillZerobss>
  bx lr
 800052c:	4770      	bx	lr
	...

08000530 <Reset_Handler>:

  .section .text.Reset_Handler
  .weak Reset_Handler
  .type Reset_Handler, %function
Reset_Handler:
  ldr   r0, =_estack
 8000530:	480c      	ldr	r0, [pc, #48]	; (8000564 <LoopForever+0x4>)
  mov   sp, r0          /* set stack pointer */
 8000532:	4685      	mov	sp, r0

/* Copy the data segment initializers from flash to SRAM */
  INIT_DATA _sdata, _edata, _sidata
 8000534:	480c      	ldr	r0, [pc, #48]	; (8000568 <LoopForever+0x8>)
 8000536:	490d      	ldr	r1, [pc, #52]	; (800056c <LoopForever+0xc>)
 8000538:	4a0d      	ldr	r2, [pc, #52]	; (8000570 <LoopForever+0x10>)
 800053a:	2300      	movs	r3, #0
 800053c:	f7ff ffee 	bl	800051c <LoopCopyDataInit>

/* Zero fill the bss segments. */
  INIT_BSS _sbss, _ebss
 8000540:	480c      	ldr	r0, [pc, #48]	; (8000574 <LoopForever+0x14>)
 8000542:	490d      	ldr	r1, [pc, #52]	; (8000578 <LoopForever+0x18>)
 8000544:	2300      	movs	r3, #0
 8000546:	f7ff ffef 	bl	8000528 <LoopFillZerobss>
  INIT_BSS _sMB_MEM2, _eMB_MEM2
 800054a:	480c      	ldr	r0, [pc, #48]	; (800057c <LoopForever+0x1c>)
 800054c:	490c      	ldr	r1, [pc, #48]	; (8000580 <LoopForever+0x20>)
 800054e:	2300      	movs	r3, #0
 8000550:	f7ff ffea 	bl	8000528 <LoopFillZerobss>

/* Call the clock system intitialization function.*/
  bl  SystemInit
 8000554:	f7ff ff38 	bl	80003c8 <SystemInit>
/* Call static constructors */
  bl __libc_init_array
 8000558:	f002 f8f6 	bl	8002748 <__libc_init_array>
/* Call the application s entry point.*/
	bl	main
 800055c:	f7ff fea4 	bl	80002a8 <main>

08000560 <LoopForever>:

LoopForever:
  b LoopForever
 8000560:	e7fe      	b.n	8000560 <LoopForever>
 8000562:	0000      	.short	0x0000
  ldr   r0, =_estack
 8000564:	20030000 	.word	0x20030000
  INIT_DATA _sdata, _edata, _sidata
 8000568:	20000004 	.word	0x20000004
 800056c:	20000014 	.word	0x20000014
 8000570:	08002890 	.word	0x08002890
  INIT_BSS _sbss, _ebss
 8000574:	20000014 	.word	0x20000014
 8000578:	200006a0 	.word	0x200006a0
  INIT_BSS _sMB_MEM2, _eMB_MEM2
 800057c:	200300b8 	.word	0x200300b8
 8000580:	200300d8 	.word	0x200300d8

08000584 <ADC1_IRQHandler>:
 * @retval None
*/
  .section .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
	b	Infinite_Loop
 8000584:	e7fe      	b.n	8000584 <ADC1_IRQHandler>
	...

08000588 <HAL_Init>:
  *         need to ensure that the SysTick time base is always set to 1 millisecond
  *         to have correct HAL operation.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
 8000588:	b510      	push	{r4, lr}
#if (DATA_CACHE_ENABLE == 0U)
   __HAL_FLASH_DATA_CACHE_DISABLE();
#endif /* DATA_CACHE_ENABLE */

#if (PREFETCH_ENABLE != 0U)
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 800058a:	4a09      	ldr	r2, [pc, #36]	; (80005b0 <HAL_Init+0x28>)
 800058c:	6813      	ldr	r3, [r2, #0]
 800058e:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8000592:	6013      	str	r3, [r2, #0]
#endif /* PREFETCH_ENABLE */

  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 8000594:	2003      	movs	r0, #3
 8000596:	f000 f839 	bl	800060c <HAL_NVIC_SetPriorityGrouping>
  
  /* Use SysTick as time base source and configure 1ms tick (default clock after Reset is MSI) */
  if (HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
 800059a:	2000      	movs	r0, #0
 800059c:	f7ff feba 	bl	8000314 <HAL_InitTick>
 80005a0:	b110      	cbz	r0, 80005a8 <HAL_Init+0x20>
  {
    status = HAL_ERROR;
 80005a2:	2401      	movs	r4, #1
    HAL_MspInit();
  }

  /* Return function status */
  return status;
}
 80005a4:	4620      	mov	r0, r4
 80005a6:	bd10      	pop	{r4, pc}
 80005a8:	4604      	mov	r4, r0
    HAL_MspInit();
 80005aa:	f7ff fe93 	bl	80002d4 <HAL_MspInit>
 80005ae:	e7f9      	b.n	80005a4 <HAL_Init+0x1c>
 80005b0:	58004000 	.word	0x58004000

080005b4 <HAL_IncTick>:
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
  uwTick += (uint32_t)uwTickFreq;
 80005b4:	4a03      	ldr	r2, [pc, #12]	; (80005c4 <HAL_IncTick+0x10>)
 80005b6:	6813      	ldr	r3, [r2, #0]
 80005b8:	4903      	ldr	r1, [pc, #12]	; (80005c8 <HAL_IncTick+0x14>)
 80005ba:	6809      	ldr	r1, [r1, #0]
 80005bc:	440b      	add	r3, r1
 80005be:	6013      	str	r3, [r2, #0]
}
 80005c0:	4770      	bx	lr
 80005c2:	bf00      	nop
 80005c4:	2000069c 	.word	0x2000069c
 80005c8:	20000008 	.word	0x20000008

080005cc <HAL_GetTick>:
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
  return uwTick;
 80005cc:	4b01      	ldr	r3, [pc, #4]	; (80005d4 <HAL_GetTick+0x8>)
 80005ce:	6818      	ldr	r0, [r3, #0]
}
 80005d0:	4770      	bx	lr
 80005d2:	bf00      	nop
 80005d4:	2000069c 	.word	0x2000069c

080005d8 <HAL_GetTickPrio>:
  * @retval tick priority
  */
uint32_t HAL_GetTickPrio(void)
{
  return uwTickPrio;
}
 80005d8:	4b01      	ldr	r3, [pc, #4]	; (80005e0 <HAL_GetTickPrio+0x8>)
 80005da:	6818      	ldr	r0, [r3, #0]
 80005dc:	4770      	bx	lr
 80005de:	bf00      	nop
 80005e0:	2000000c 	.word	0x2000000c

080005e4 <HAL_Delay>:
  *       implementations in user file.
  * @param Delay  specifies the delay time length, in milliseconds.
  * @retval None
  */
  __weak void HAL_Delay(uint32_t Delay)
  {
 80005e4:	b538      	push	{r3, r4, r5, lr}
 80005e6:	4604      	mov	r4, r0
    uint32_t tickstart = HAL_GetTick();
 80005e8:	f7ff fff0 	bl	80005cc <HAL_GetTick>
 80005ec:	4605      	mov	r5, r0
    uint32_t wait = Delay;
  
    /* Add a freq to guarantee minimum wait */
    if (wait < HAL_MAX_DELAY)
 80005ee:	f1b4 3fff 	cmp.w	r4, #4294967295
 80005f2:	d002      	beq.n	80005fa <HAL_Delay+0x16>
    {
      wait += (uint32_t)(uwTickFreq);
 80005f4:	4b04      	ldr	r3, [pc, #16]	; (8000608 <HAL_Delay+0x24>)
 80005f6:	681b      	ldr	r3, [r3, #0]
 80005f8:	441c      	add	r4, r3
    }
  
    while ((HAL_GetTick() - tickstart) < wait)
 80005fa:	f7ff ffe7 	bl	80005cc <HAL_GetTick>
 80005fe:	1b40      	subs	r0, r0, r5
 8000600:	42a0      	cmp	r0, r4
 8000602:	d3fa      	bcc.n	80005fa <HAL_Delay+0x16>
    {
    }
  }
 8000604:	bd38      	pop	{r3, r4, r5, pc}
 8000606:	bf00      	nop
 8000608:	20000008 	.word	0x20000008

0800060c <HAL_NVIC_SetPriorityGrouping>:
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 800060c:	4a07      	ldr	r2, [pc, #28]	; (800062c <HAL_NVIC_SetPriorityGrouping+0x20>)
 800060e:	68d3      	ldr	r3, [r2, #12]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 8000610:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 8000614:	041b      	lsls	r3, r3, #16
 8000616:	0c1b      	lsrs	r3, r3, #16
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 8000618:	0200      	lsls	r0, r0, #8
 800061a:	f400 60e0 	and.w	r0, r0, #1792	; 0x700
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 800061e:	4318      	orrs	r0, r3
  reg_value  =  (reg_value                                   |
 8000620:	f040 60bf 	orr.w	r0, r0, #100139008	; 0x5f80000
 8000624:	f440 3000 	orr.w	r0, r0, #131072	; 0x20000
  SCB->AIRCR =  reg_value;
 8000628:	60d0      	str	r0, [r2, #12]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));

  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
}
 800062a:	4770      	bx	lr
 800062c:	e000ed00 	.word	0xe000ed00

08000630 <HAL_NVIC_SetPriority>:
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
 8000630:	b430      	push	{r4, r5}
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 8000632:	4b17      	ldr	r3, [pc, #92]	; (8000690 <HAL_NVIC_SetPriority+0x60>)
 8000634:	68db      	ldr	r3, [r3, #12]
 8000636:	f3c3 2302 	ubfx	r3, r3, #8, #3
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 800063a:	f1c3 0407 	rsb	r4, r3, #7
 800063e:	2c04      	cmp	r4, #4
 8000640:	bf28      	it	cs
 8000642:	2404      	movcs	r4, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8000644:	1d1d      	adds	r5, r3, #4
 8000646:	2d06      	cmp	r5, #6
 8000648:	d918      	bls.n	800067c <HAL_NVIC_SetPriority+0x4c>
 800064a:	3b03      	subs	r3, #3

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 800064c:	f04f 35ff 	mov.w	r5, #4294967295
 8000650:	fa05 f404 	lsl.w	r4, r5, r4
 8000654:	ea21 0104 	bic.w	r1, r1, r4
 8000658:	4099      	lsls	r1, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 800065a:	fa05 f303 	lsl.w	r3, r5, r3
 800065e:	ea22 0303 	bic.w	r3, r2, r3
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8000662:	4319      	orrs	r1, r3
  if ((int32_t)(IRQn) >= 0)
 8000664:	2800      	cmp	r0, #0
 8000666:	db0b      	blt.n	8000680 <HAL_NVIC_SetPriority+0x50>
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000668:	0109      	lsls	r1, r1, #4
 800066a:	b2c9      	uxtb	r1, r1
 800066c:	f100 4060 	add.w	r0, r0, #3758096384	; 0xe0000000
 8000670:	f500 4061 	add.w	r0, r0, #57600	; 0xe100
 8000674:	f880 1300 	strb.w	r1, [r0, #768]	; 0x300
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));

  prioritygroup = NVIC_GetPriorityGrouping();

  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
}
 8000678:	bc30      	pop	{r4, r5}
 800067a:	4770      	bx	lr
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 800067c:	2300      	movs	r3, #0
 800067e:	e7e5      	b.n	800064c <HAL_NVIC_SetPriority+0x1c>
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000680:	f000 000f 	and.w	r0, r0, #15
 8000684:	0109      	lsls	r1, r1, #4
 8000686:	b2c9      	uxtb	r1, r1
 8000688:	4b02      	ldr	r3, [pc, #8]	; (8000694 <HAL_NVIC_SetPriority+0x64>)
 800068a:	5419      	strb	r1, [r3, r0]
 800068c:	e7f4      	b.n	8000678 <HAL_NVIC_SetPriority+0x48>
 800068e:	bf00      	nop
 8000690:	e000ed00 	.word	0xe000ed00
 8000694:	e000ed14 	.word	0xe000ed14

08000698 <HAL_NVIC_EnableIRQ>:
  if ((int32_t)(IRQn) >= 0)
 8000698:	2800      	cmp	r0, #0
 800069a:	db07      	blt.n	80006ac <HAL_NVIC_EnableIRQ+0x14>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 800069c:	f000 021f 	and.w	r2, r0, #31
 80006a0:	0940      	lsrs	r0, r0, #5
 80006a2:	2301      	movs	r3, #1
 80006a4:	4093      	lsls	r3, r2
 80006a6:	4a02      	ldr	r2, [pc, #8]	; (80006b0 <HAL_NVIC_EnableIRQ+0x18>)
 80006a8:	f842 3020 	str.w	r3, [r2, r0, lsl #2]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  
  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
}
 80006ac:	4770      	bx	lr
 80006ae:	bf00      	nop
 80006b0:	e000e100 	.word	0xe000e100

080006b4 <HAL_DMA_IRQHandler>:
  * @param hdma Pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Channel.
  * @retval None
  */
void HAL_DMA_IRQHandler(DMA_HandleTypeDef *hdma)
{
 80006b4:	b538      	push	{r3, r4, r5, lr}
  uint32_t flag_it = hdma->DmaBaseAddress->ISR;
 80006b6:	6c03      	ldr	r3, [r0, #64]	; 0x40
 80006b8:	6819      	ldr	r1, [r3, #0]
  uint32_t source_it = hdma->Instance->CCR;
 80006ba:	6804      	ldr	r4, [r0, #0]
 80006bc:	6825      	ldr	r5, [r4, #0]

  /* Half Transfer Complete Interrupt management ******************************/
  if (((flag_it & (DMA_FLAG_HT1 << (hdma->ChannelIndex & 0x1cU))) != 0U) && ((source_it & DMA_IT_HT) != 0U))
 80006be:	6c43      	ldr	r3, [r0, #68]	; 0x44
 80006c0:	f003 031c 	and.w	r3, r3, #28
 80006c4:	2204      	movs	r2, #4
 80006c6:	409a      	lsls	r2, r3
 80006c8:	420a      	tst	r2, r1
 80006ca:	d015      	beq.n	80006f8 <HAL_DMA_IRQHandler+0x44>
 80006cc:	f015 0f04 	tst.w	r5, #4
 80006d0:	d012      	beq.n	80006f8 <HAL_DMA_IRQHandler+0x44>
  {
    /* Disable the half transfer interrupt if the DMA mode is not CIRCULAR */
    if ((hdma->Instance->CCR & DMA_CCR_CIRC) == 0U)
 80006d2:	6823      	ldr	r3, [r4, #0]
 80006d4:	f013 0f20 	tst.w	r3, #32
 80006d8:	d103      	bne.n	80006e2 <HAL_DMA_IRQHandler+0x2e>
    {
      /* Disable the half transfer interrupt */
      __HAL_DMA_DISABLE_IT(hdma, DMA_IT_HT);
 80006da:	6823      	ldr	r3, [r4, #0]
 80006dc:	f023 0304 	bic.w	r3, r3, #4
 80006e0:	6023      	str	r3, [r4, #0]
    }
    /* Clear the half transfer complete flag */
    hdma->DmaBaseAddress->IFCR = (DMA_ISR_HTIF1 << (hdma->ChannelIndex & 0x1CU));
 80006e2:	6c43      	ldr	r3, [r0, #68]	; 0x44
 80006e4:	f003 021c 	and.w	r2, r3, #28
 80006e8:	6c01      	ldr	r1, [r0, #64]	; 0x40
 80006ea:	2304      	movs	r3, #4
 80006ec:	4093      	lsls	r3, r2
 80006ee:	604b      	str	r3, [r1, #4]

    /* DMA peripheral state is not updated in Half Transfer */
    /* but in Transfer Complete case */

    if (hdma->XferHalfCpltCallback != NULL)
 80006f0:	6b03      	ldr	r3, [r0, #48]	; 0x30
 80006f2:	b103      	cbz	r3, 80006f6 <HAL_DMA_IRQHandler+0x42>
    {
      /* Half transfer callback */
      hdma->XferHalfCpltCallback(hdma);
 80006f4:	4798      	blx	r3
  else
  {
    /* Nothing To Do */
  }
  return;
}
 80006f6:	bd38      	pop	{r3, r4, r5, pc}
  else if (((flag_it & (DMA_FLAG_TC1 << (hdma->ChannelIndex & 0x1cU))) != 0U) && ((source_it & DMA_IT_TC) != 0U))
 80006f8:	2202      	movs	r2, #2
 80006fa:	409a      	lsls	r2, r3
 80006fc:	420a      	tst	r2, r1
 80006fe:	d01c      	beq.n	800073a <HAL_DMA_IRQHandler+0x86>
 8000700:	f015 0f02 	tst.w	r5, #2
 8000704:	d019      	beq.n	800073a <HAL_DMA_IRQHandler+0x86>
    if ((hdma->Instance->CCR & DMA_CCR_CIRC) == 0U)
 8000706:	6823      	ldr	r3, [r4, #0]
 8000708:	f013 0f20 	tst.w	r3, #32
 800070c:	d106      	bne.n	800071c <HAL_DMA_IRQHandler+0x68>
      __HAL_DMA_DISABLE_IT(hdma, DMA_IT_TE | DMA_IT_TC);
 800070e:	6823      	ldr	r3, [r4, #0]
 8000710:	f023 030a 	bic.w	r3, r3, #10
 8000714:	6023      	str	r3, [r4, #0]
      hdma->State = HAL_DMA_STATE_READY;
 8000716:	2301      	movs	r3, #1
 8000718:	f880 3025 	strb.w	r3, [r0, #37]	; 0x25
    hdma->DmaBaseAddress->IFCR = (DMA_ISR_TCIF1 << (hdma->ChannelIndex & 0x1cU));
 800071c:	6c43      	ldr	r3, [r0, #68]	; 0x44
 800071e:	f003 021c 	and.w	r2, r3, #28
 8000722:	6c01      	ldr	r1, [r0, #64]	; 0x40
 8000724:	2302      	movs	r3, #2
 8000726:	4093      	lsls	r3, r2
 8000728:	604b      	str	r3, [r1, #4]
    __HAL_UNLOCK(hdma);
 800072a:	2300      	movs	r3, #0
 800072c:	f880 3024 	strb.w	r3, [r0, #36]	; 0x24
    if (hdma->XferCpltCallback != NULL)
 8000730:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 8000732:	2b00      	cmp	r3, #0
 8000734:	d0df      	beq.n	80006f6 <HAL_DMA_IRQHandler+0x42>
      hdma->XferCpltCallback(hdma);
 8000736:	4798      	blx	r3
 8000738:	e7dd      	b.n	80006f6 <HAL_DMA_IRQHandler+0x42>
  else if (((flag_it & (DMA_FLAG_TE1 << (hdma->ChannelIndex & 0x1cU)))!= 0U) && ((source_it & DMA_IT_TE) != 0U))
 800073a:	2208      	movs	r2, #8
 800073c:	fa02 f303 	lsl.w	r3, r2, r3
 8000740:	420b      	tst	r3, r1
 8000742:	d0d8      	beq.n	80006f6 <HAL_DMA_IRQHandler+0x42>
 8000744:	f015 0f08 	tst.w	r5, #8
 8000748:	d0d5      	beq.n	80006f6 <HAL_DMA_IRQHandler+0x42>
    __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
 800074a:	6823      	ldr	r3, [r4, #0]
 800074c:	f023 030e 	bic.w	r3, r3, #14
 8000750:	6023      	str	r3, [r4, #0]
    hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex & 0x1cU));
 8000752:	6c43      	ldr	r3, [r0, #68]	; 0x44
 8000754:	f003 031c 	and.w	r3, r3, #28
 8000758:	6c01      	ldr	r1, [r0, #64]	; 0x40
 800075a:	2201      	movs	r2, #1
 800075c:	fa02 f303 	lsl.w	r3, r2, r3
 8000760:	604b      	str	r3, [r1, #4]
    hdma->ErrorCode = HAL_DMA_ERROR_TE;
 8000762:	63c2      	str	r2, [r0, #60]	; 0x3c
    hdma->State = HAL_DMA_STATE_READY;
 8000764:	f880 2025 	strb.w	r2, [r0, #37]	; 0x25
    __HAL_UNLOCK(hdma);
 8000768:	2300      	movs	r3, #0
 800076a:	f880 3024 	strb.w	r3, [r0, #36]	; 0x24
    if (hdma->XferErrorCallback != NULL)
 800076e:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8000770:	2b00      	cmp	r3, #0
 8000772:	d0c0      	beq.n	80006f6 <HAL_DMA_IRQHandler+0x42>
      hdma->XferErrorCallback(hdma);
 8000774:	4798      	blx	r3
  return;
 8000776:	e7be      	b.n	80006f6 <HAL_DMA_IRQHandler+0x42>

08000778 <HAL_PWR_EnableBkUpAccess>:
  *         back-up domain.
  * @retval None
  */
void HAL_PWR_EnableBkUpAccess(void)
{
  SET_BIT(PWR->CR1, PWR_CR1_DBP);
 8000778:	4a02      	ldr	r2, [pc, #8]	; (8000784 <HAL_PWR_EnableBkUpAccess+0xc>)
 800077a:	6813      	ldr	r3, [r2, #0]
 800077c:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8000780:	6013      	str	r3, [r2, #0]
}
 8000782:	4770      	bx	lr
 8000784:	58000400 	.word	0x58000400

08000788 <HAL_PWREx_GetVoltageRange>:
  * @brief Return Voltage Scaling Range.
  * @retval VOS bit field (PWR_REGULATOR_VOLTAGE_RANGE1 or PWR_REGULATOR_VOLTAGE_RANGE2)
  */  
uint32_t HAL_PWREx_GetVoltageRange(void)
{
  return  (PWR->CR1 & PWR_CR1_VOS);
 8000788:	4b02      	ldr	r3, [pc, #8]	; (8000794 <HAL_PWREx_GetVoltageRange+0xc>)
 800078a:	6818      	ldr	r0, [r3, #0]
}
 800078c:	f400 60c0 	and.w	r0, r0, #1536	; 0x600
 8000790:	4770      	bx	lr
 8000792:	bf00      	nop
 8000794:	58000400 	.word	0x58000400

08000798 <RCC_SetFlashLatency>:
  * @param  Flash_ClkSrcFreq  Flash Clock Source (in MHz)
  * @param  VCORE_Voltage     Current Vcore voltage (PWR_REGULATOR_VOLTAGE_SCALE1 or PWR_REGULATOR_VOLTAGE_SCALE2)
  * @retval HAL status
  */
static HAL_StatusTypeDef RCC_SetFlashLatency(uint32_t Flash_ClkSrcFreq, uint32_t VCORE_Voltage)
{
 8000798:	b5f0      	push	{r4, r5, r6, r7, lr}
 800079a:	b08d      	sub	sp, #52	; 0x34
 800079c:	4606      	mov	r6, r0
 800079e:	460f      	mov	r7, r1
  /* Flash Clock source (HCLK4) range in MHz with a VCORE is range1 */
  const uint32_t FLASH_CLK_SRC_RANGE_VOS1[] = {18UL, 36UL, 54UL, 64UL};
 80007a0:	4c2a      	ldr	r4, [pc, #168]	; (800084c <RCC_SetFlashLatency+0xb4>)
 80007a2:	e894 000f 	ldmia.w	r4, {r0, r1, r2, r3}
 80007a6:	ad0c      	add	r5, sp, #48	; 0x30
 80007a8:	e905 000f 	stmdb	r5, {r0, r1, r2, r3}
#if defined(PWR_CR1_VOS)
  /* Flash Clock source (HCLK4) range in MHz with a VCORE is range2 */
  const uint32_t FLASH_CLK_SRC_RANGE_VOS2[] = {6UL, 12UL, 16UL};
 80007ac:	ab05      	add	r3, sp, #20
 80007ae:	f104 0210 	add.w	r2, r4, #16
 80007b2:	ca07      	ldmia	r2, {r0, r1, r2}
 80007b4:	e883 0007 	stmia.w	r3, {r0, r1, r2}
#endif
  /* Flash Latency range */
  const uint32_t FLASH_LATENCY_RANGE[] = {FLASH_LATENCY_0, FLASH_LATENCY_1, FLASH_LATENCY_2, FLASH_LATENCY_3};
 80007b8:	ad01      	add	r5, sp, #4
 80007ba:	341c      	adds	r4, #28
 80007bc:	e894 000f 	ldmia.w	r4, {r0, r1, r2, r3}
 80007c0:	e885 000f 	stmia.w	r5, {r0, r1, r2, r3}
  uint32_t latency   = FLASH_LATENCY_0;  /* default value 0WS */
  uint32_t tickstart;

#if defined(PWR_CR1_VOS)
  if (VCORE_Voltage == PWR_REGULATOR_VOLTAGE_SCALE1)
 80007c4:	f5b7 7f00 	cmp.w	r7, #512	; 0x200
 80007c8:	d011      	beq.n	80007ee <RCC_SetFlashLatency+0x56>
      }
    }
  }
  else  /* PWR_REGULATOR_VOLTAGE_SCALE2 */
  {
    for (uint32_t index = 0; index < __COUNTOF(FLASH_CLK_SRC_RANGE_VOS2); index++)
 80007ca:	2300      	movs	r3, #0
 80007cc:	2b02      	cmp	r3, #2
 80007ce:	d822      	bhi.n	8000816 <RCC_SetFlashLatency+0x7e>
    {
      if (Flash_ClkSrcFreq <= FLASH_CLK_SRC_RANGE_VOS2[index])
 80007d0:	aa0c      	add	r2, sp, #48	; 0x30
 80007d2:	eb02 0283 	add.w	r2, r2, r3, lsl #2
 80007d6:	f852 2c1c 	ldr.w	r2, [r2, #-28]
 80007da:	42b2      	cmp	r2, r6
 80007dc:	d215      	bcs.n	800080a <RCC_SetFlashLatency+0x72>
    for (uint32_t index = 0; index < __COUNTOF(FLASH_CLK_SRC_RANGE_VOS2); index++)
 80007de:	3301      	adds	r3, #1
 80007e0:	e7f4      	b.n	80007cc <RCC_SetFlashLatency+0x34>
        latency = FLASH_LATENCY_RANGE[index];
 80007e2:	aa0c      	add	r2, sp, #48	; 0x30
 80007e4:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 80007e8:	f853 4c2c 	ldr.w	r4, [r3, #-44]
        break;
 80007ec:	e014      	b.n	8000818 <RCC_SetFlashLatency+0x80>
    for (uint32_t index = 0; index < __COUNTOF(FLASH_CLK_SRC_RANGE_VOS1); index++)
 80007ee:	2300      	movs	r3, #0
 80007f0:	2b03      	cmp	r3, #3
 80007f2:	d808      	bhi.n	8000806 <RCC_SetFlashLatency+0x6e>
      if (Flash_ClkSrcFreq <= FLASH_CLK_SRC_RANGE_VOS1[index])
 80007f4:	aa0c      	add	r2, sp, #48	; 0x30
 80007f6:	eb02 0283 	add.w	r2, r2, r3, lsl #2
 80007fa:	f852 2c10 	ldr.w	r2, [r2, #-16]
 80007fe:	42b2      	cmp	r2, r6
 8000800:	d2ef      	bcs.n	80007e2 <RCC_SetFlashLatency+0x4a>
    for (uint32_t index = 0; index < __COUNTOF(FLASH_CLK_SRC_RANGE_VOS1); index++)
 8000802:	3301      	adds	r3, #1
 8000804:	e7f4      	b.n	80007f0 <RCC_SetFlashLatency+0x58>
  uint32_t latency   = FLASH_LATENCY_0;  /* default value 0WS */
 8000806:	2400      	movs	r4, #0
 8000808:	e006      	b.n	8000818 <RCC_SetFlashLatency+0x80>
      {
        latency = FLASH_LATENCY_RANGE[index];
 800080a:	aa0c      	add	r2, sp, #48	; 0x30
 800080c:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 8000810:	f853 4c2c 	ldr.w	r4, [r3, #-44]
        break;
 8000814:	e000      	b.n	8000818 <RCC_SetFlashLatency+0x80>
  uint32_t latency   = FLASH_LATENCY_0;  /* default value 0WS */
 8000816:	2400      	movs	r4, #0
      break;
    }
  }
#endif

  __HAL_FLASH_SET_LATENCY(latency);
 8000818:	4a0d      	ldr	r2, [pc, #52]	; (8000850 <RCC_SetFlashLatency+0xb8>)
 800081a:	6813      	ldr	r3, [r2, #0]
 800081c:	f023 0307 	bic.w	r3, r3, #7
 8000820:	4323      	orrs	r3, r4
 8000822:	6013      	str	r3, [r2, #0]

  /* Get Start Tick*/
  tickstart = HAL_GetTick();
 8000824:	f7ff fed2 	bl	80005cc <HAL_GetTick>
 8000828:	4605      	mov	r5, r0

  /* Check that the new number of wait states is taken into account to access the Flash
     memory by reading the FLASH_ACR register */
  while (__HAL_FLASH_GET_LATENCY() != latency)
 800082a:	4b09      	ldr	r3, [pc, #36]	; (8000850 <RCC_SetFlashLatency+0xb8>)
 800082c:	681b      	ldr	r3, [r3, #0]
 800082e:	f003 0307 	and.w	r3, r3, #7
 8000832:	42a3      	cmp	r3, r4
 8000834:	d006      	beq.n	8000844 <RCC_SetFlashLatency+0xac>
  {
    if ((HAL_GetTick() - tickstart) > LATENCY_TIMEOUT_VALUE)
 8000836:	f7ff fec9 	bl	80005cc <HAL_GetTick>
 800083a:	1b40      	subs	r0, r0, r5
 800083c:	2802      	cmp	r0, #2
 800083e:	d9f4      	bls.n	800082a <RCC_SetFlashLatency+0x92>
    {
      return HAL_TIMEOUT;
 8000840:	2003      	movs	r0, #3
 8000842:	e000      	b.n	8000846 <RCC_SetFlashLatency+0xae>
    }
  }
  return HAL_OK;
 8000844:	2000      	movs	r0, #0
}
 8000846:	b00d      	add	sp, #52	; 0x34
 8000848:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800084a:	bf00      	nop
 800084c:	080027b8 	.word	0x080027b8
 8000850:	58004000 	.word	0x58004000

08000854 <RCC_SetFlashLatencyFromMSIRange>:
{
 8000854:	b510      	push	{r4, lr}
  if (MSI_Range > RCC_MSIRANGE_11)
 8000856:	28b0      	cmp	r0, #176	; 0xb0
 8000858:	d819      	bhi.n	800088e <RCC_SetFlashLatencyFromMSIRange+0x3a>
    msifreq = __LL_RCC_CALC_MSI_FREQ(MSI_Range);
 800085a:	f3c0 1003 	ubfx	r0, r0, #4, #4
 800085e:	4b0d      	ldr	r3, [pc, #52]	; (8000894 <RCC_SetFlashLatencyFromMSIRange+0x40>)
 8000860:	f853 4020 	ldr.w	r4, [r3, r0, lsl #2]
  *         @arg @ref LL_RCC_SYSCLK_DIV_256
  *         @arg @ref LL_RCC_SYSCLK_DIV_512
  */
__STATIC_INLINE uint32_t LL_RCC_GetAHB4Prescaler(void)
{
  return (uint32_t)(READ_BIT(RCC->EXTCFGR, RCC_EXTCFGR_SHDHPRE) << 4);
 8000864:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8000868:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
  flash_clksrcfreq = __LL_RCC_CALC_HCLK4_FREQ(msifreq, LL_RCC_GetAHB4Prescaler());
 800086c:	f003 030f 	and.w	r3, r3, #15
 8000870:	4a09      	ldr	r2, [pc, #36]	; (8000898 <RCC_SetFlashLatencyFromMSIRange+0x44>)
 8000872:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8000876:	fbb4 f4f3 	udiv	r4, r4, r3
  return RCC_SetFlashLatency((flash_clksrcfreq / MEGA_HZ), HAL_PWREx_GetVoltageRange());
 800087a:	f7ff ff85 	bl	8000788 <HAL_PWREx_GetVoltageRange>
 800087e:	4b07      	ldr	r3, [pc, #28]	; (800089c <RCC_SetFlashLatencyFromMSIRange+0x48>)
 8000880:	fba3 3404 	umull	r3, r4, r3, r4
 8000884:	4601      	mov	r1, r0
 8000886:	0ca0      	lsrs	r0, r4, #18
 8000888:	f7ff ff86 	bl	8000798 <RCC_SetFlashLatency>
}
 800088c:	bd10      	pop	{r4, pc}
    msifreq = __LL_RCC_CALC_MSI_FREQ(RCC_MSIRANGE_11);
 800088e:	4b01      	ldr	r3, [pc, #4]	; (8000894 <RCC_SetFlashLatencyFromMSIRange+0x40>)
 8000890:	6adc      	ldr	r4, [r3, #44]	; 0x2c
 8000892:	e7e7      	b.n	8000864 <RCC_SetFlashLatencyFromMSIRange+0x10>
 8000894:	08002844 	.word	0x08002844
 8000898:	080027e4 	.word	0x080027e4
 800089c:	431bde83 	.word	0x431bde83

080008a0 <HAL_RCC_OscConfig>:
  if (RCC_OscInitStruct == NULL)
 80008a0:	2800      	cmp	r0, #0
 80008a2:	f000 836c 	beq.w	8000f7e <HAL_RCC_OscConfig+0x6de>
{
 80008a6:	b538      	push	{r3, r4, r5, lr}
 80008a8:	4604      	mov	r4, r0
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_MSI) == RCC_OSCILLATORTYPE_MSI)
 80008aa:	6803      	ldr	r3, [r0, #0]
 80008ac:	f013 0f20 	tst.w	r3, #32
 80008b0:	d059      	beq.n	8000966 <HAL_RCC_OscConfig+0xc6>
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SWS));
 80008b2:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 80008b6:	6893      	ldr	r3, [r2, #8]
  *         @arg @ref LL_RCC_PLLSOURCE_HSI
  *         @arg @ref LL_RCC_PLLSOURCE_HSE
  */
__STATIC_INLINE uint32_t LL_RCC_PLL_GetMainSource(void)
{
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC));
 80008b8:	68d2      	ldr	r2, [r2, #12]
 80008ba:	f002 0203 	and.w	r2, r2, #3
    if ((temp_sysclksrc == RCC_SYSCLKSOURCE_STATUS_MSI) ||
 80008be:	f013 030c 	ands.w	r3, r3, #12
 80008c2:	d01e      	beq.n	8000902 <HAL_RCC_OscConfig+0x62>
 80008c4:	2b0c      	cmp	r3, #12
 80008c6:	d01a      	beq.n	80008fe <HAL_RCC_OscConfig+0x5e>
      if (RCC_OscInitStruct->MSIState != RCC_MSI_OFF)
 80008c8:	69e3      	ldr	r3, [r4, #28]
 80008ca:	2b00      	cmp	r3, #0
 80008cc:	f000 80a7 	beq.w	8000a1e <HAL_RCC_OscConfig+0x17e>
  SET_BIT(RCC->CR, RCC_CR_MSION);
 80008d0:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 80008d4:	6813      	ldr	r3, [r2, #0]
 80008d6:	f043 0301 	orr.w	r3, r3, #1
 80008da:	6013      	str	r3, [r2, #0]
        tickstart = HAL_GetTick();
 80008dc:	f7ff fe76 	bl	80005cc <HAL_GetTick>
 80008e0:	4605      	mov	r5, r0
  return ((READ_BIT(RCC->CR, RCC_CR_MSIRDY) == (RCC_CR_MSIRDY)) ? 1UL : 0UL);
 80008e2:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80008e6:	681b      	ldr	r3, [r3, #0]
 80008e8:	f013 0f02 	tst.w	r3, #2
 80008ec:	f040 8087 	bne.w	80009fe <HAL_RCC_OscConfig+0x15e>
          if ((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
 80008f0:	f7ff fe6c 	bl	80005cc <HAL_GetTick>
 80008f4:	1b40      	subs	r0, r0, r5
 80008f6:	2802      	cmp	r0, #2
 80008f8:	d9f3      	bls.n	80008e2 <HAL_RCC_OscConfig+0x42>
            return HAL_TIMEOUT;
 80008fa:	2003      	movs	r0, #3
 80008fc:	e34c      	b.n	8000f98 <HAL_RCC_OscConfig+0x6f8>
        ((temp_sysclksrc == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (temp_plloscsrc == RCC_PLLSOURCE_MSI)))
 80008fe:	2a01      	cmp	r2, #1
 8000900:	d1e2      	bne.n	80008c8 <HAL_RCC_OscConfig+0x28>
 8000902:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8000906:	681b      	ldr	r3, [r3, #0]
 8000908:	f013 0f02 	tst.w	r3, #2
 800090c:	d003      	beq.n	8000916 <HAL_RCC_OscConfig+0x76>
      if ((LL_RCC_MSI_IsReady() != 0U) && (RCC_OscInitStruct->MSIState == RCC_MSI_OFF))
 800090e:	69e3      	ldr	r3, [r4, #28]
 8000910:	2b00      	cmp	r3, #0
 8000912:	f000 8336 	beq.w	8000f82 <HAL_RCC_OscConfig+0x6e2>
        if (RCC_OscInitStruct->MSIClockRange > __HAL_RCC_GET_MSI_RANGE())
 8000916:	6a60      	ldr	r0, [r4, #36]	; 0x24
  uint32_t msiRange = READ_BIT(RCC->CR, RCC_CR_MSIRANGE);
 8000918:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800091c:	681b      	ldr	r3, [r3, #0]
 800091e:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
  if (msiRange > LL_RCC_MSIRANGE_11)
 8000922:	2bb0      	cmp	r3, #176	; 0xb0
 8000924:	d900      	bls.n	8000928 <HAL_RCC_OscConfig+0x88>
    msiRange = LL_RCC_MSIRANGE_11;
 8000926:	23b0      	movs	r3, #176	; 0xb0
 8000928:	4298      	cmp	r0, r3
 800092a:	d953      	bls.n	80009d4 <HAL_RCC_OscConfig+0x134>
          if (RCC_SetFlashLatencyFromMSIRange(RCC_OscInitStruct->MSIClockRange) != HAL_OK)
 800092c:	f7ff ff92 	bl	8000854 <RCC_SetFlashLatencyFromMSIRange>
 8000930:	2800      	cmp	r0, #0
 8000932:	f040 8328 	bne.w	8000f86 <HAL_RCC_OscConfig+0x6e6>
          __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 8000936:	6a63      	ldr	r3, [r4, #36]	; 0x24
  MODIFY_REG(RCC->CR, RCC_CR_MSIRANGE, Range);
 8000938:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 800093c:	6811      	ldr	r1, [r2, #0]
 800093e:	f021 01f0 	bic.w	r1, r1, #240	; 0xf0
 8000942:	430b      	orrs	r3, r1
 8000944:	6013      	str	r3, [r2, #0]
          __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 8000946:	6a21      	ldr	r1, [r4, #32]
  MODIFY_REG(RCC->ICSCR, RCC_ICSCR_MSITRIM, Value << RCC_ICSCR_MSITRIM_Pos);
 8000948:	6853      	ldr	r3, [r2, #4]
 800094a:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
 800094e:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 8000952:	6053      	str	r3, [r2, #4]
        SystemCoreClockUpdate();
 8000954:	f7ff fd6a 	bl	800042c <SystemCoreClockUpdate>
        if (HAL_InitTick(uwTickPrio) != HAL_OK)
 8000958:	4bc2      	ldr	r3, [pc, #776]	; (8000c64 <HAL_RCC_OscConfig+0x3c4>)
 800095a:	6818      	ldr	r0, [r3, #0]
 800095c:	f7ff fcda 	bl	8000314 <HAL_InitTick>
 8000960:	2800      	cmp	r0, #0
 8000962:	f040 8312 	bne.w	8000f8a <HAL_RCC_OscConfig+0x6ea>
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 8000966:	6823      	ldr	r3, [r4, #0]
 8000968:	f013 0f01 	tst.w	r3, #1
 800096c:	d079      	beq.n	8000a62 <HAL_RCC_OscConfig+0x1c2>
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SWS));
 800096e:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 8000972:	6893      	ldr	r3, [r2, #8]
 8000974:	f003 030c 	and.w	r3, r3, #12
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC));
 8000978:	68d2      	ldr	r2, [r2, #12]
 800097a:	f002 0203 	and.w	r2, r2, #3
    if ((temp_sysclksrc == RCC_SYSCLKSOURCE_STATUS_HSE) ||
 800097e:	2b08      	cmp	r3, #8
 8000980:	d065      	beq.n	8000a4e <HAL_RCC_OscConfig+0x1ae>
 8000982:	2b0c      	cmp	r3, #12
 8000984:	d061      	beq.n	8000a4a <HAL_RCC_OscConfig+0x1aa>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8000986:	6863      	ldr	r3, [r4, #4]
 8000988:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 800098c:	f000 8093 	beq.w	8000ab6 <HAL_RCC_OscConfig+0x216>
 8000990:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
 8000994:	f000 8096 	beq.w	8000ac4 <HAL_RCC_OscConfig+0x224>
  CLEAR_BIT(RCC->CR, RCC_CR_HSEON);
 8000998:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800099c:	681a      	ldr	r2, [r3, #0]
 800099e:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 80009a2:	601a      	str	r2, [r3, #0]
  CLEAR_BIT(RCC->CR, RCC_CR_HSEBYP);
 80009a4:	681a      	ldr	r2, [r3, #0]
 80009a6:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 80009aa:	601a      	str	r2, [r3, #0]
      if (RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
 80009ac:	6863      	ldr	r3, [r4, #4]
 80009ae:	2b00      	cmp	r3, #0
 80009b0:	f000 8093 	beq.w	8000ada <HAL_RCC_OscConfig+0x23a>
        tickstart = HAL_GetTick();
 80009b4:	f7ff fe0a 	bl	80005cc <HAL_GetTick>
 80009b8:	4605      	mov	r5, r0
  return ((READ_BIT(RCC->CR, RCC_CR_HSERDY) == (RCC_CR_HSERDY)) ? 1UL : 0UL);
 80009ba:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80009be:	681b      	ldr	r3, [r3, #0]
 80009c0:	f413 3f00 	tst.w	r3, #131072	; 0x20000
 80009c4:	d14d      	bne.n	8000a62 <HAL_RCC_OscConfig+0x1c2>
          if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 80009c6:	f7ff fe01 	bl	80005cc <HAL_GetTick>
 80009ca:	1b40      	subs	r0, r0, r5
 80009cc:	2864      	cmp	r0, #100	; 0x64
 80009ce:	d9f4      	bls.n	80009ba <HAL_RCC_OscConfig+0x11a>
            return HAL_TIMEOUT;
 80009d0:	2003      	movs	r0, #3
 80009d2:	e2e1      	b.n	8000f98 <HAL_RCC_OscConfig+0x6f8>
  MODIFY_REG(RCC->CR, RCC_CR_MSIRANGE, Range);
 80009d4:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 80009d8:	6813      	ldr	r3, [r2, #0]
 80009da:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 80009de:	4318      	orrs	r0, r3
 80009e0:	6010      	str	r0, [r2, #0]
          __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 80009e2:	6a21      	ldr	r1, [r4, #32]
  MODIFY_REG(RCC->ICSCR, RCC_ICSCR_MSITRIM, Value << RCC_ICSCR_MSITRIM_Pos);
 80009e4:	6853      	ldr	r3, [r2, #4]
 80009e6:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
 80009ea:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 80009ee:	6053      	str	r3, [r2, #4]
          if (RCC_SetFlashLatencyFromMSIRange(RCC_OscInitStruct->MSIClockRange) != HAL_OK)
 80009f0:	6a60      	ldr	r0, [r4, #36]	; 0x24
 80009f2:	f7ff ff2f 	bl	8000854 <RCC_SetFlashLatencyFromMSIRange>
 80009f6:	2800      	cmp	r0, #0
 80009f8:	d0ac      	beq.n	8000954 <HAL_RCC_OscConfig+0xb4>
            return HAL_ERROR;
 80009fa:	2001      	movs	r0, #1
 80009fc:	e2cc      	b.n	8000f98 <HAL_RCC_OscConfig+0x6f8>
        __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 80009fe:	6a63      	ldr	r3, [r4, #36]	; 0x24
  MODIFY_REG(RCC->CR, RCC_CR_MSIRANGE, Range);
 8000a00:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 8000a04:	6811      	ldr	r1, [r2, #0]
 8000a06:	f021 01f0 	bic.w	r1, r1, #240	; 0xf0
 8000a0a:	430b      	orrs	r3, r1
 8000a0c:	6013      	str	r3, [r2, #0]
        __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 8000a0e:	6a21      	ldr	r1, [r4, #32]
  MODIFY_REG(RCC->ICSCR, RCC_ICSCR_MSITRIM, Value << RCC_ICSCR_MSITRIM_Pos);
 8000a10:	6853      	ldr	r3, [r2, #4]
 8000a12:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
 8000a16:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 8000a1a:	6053      	str	r3, [r2, #4]
 8000a1c:	e7a3      	b.n	8000966 <HAL_RCC_OscConfig+0xc6>
  CLEAR_BIT(RCC->CR, RCC_CR_MSION);
 8000a1e:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 8000a22:	6813      	ldr	r3, [r2, #0]
 8000a24:	f023 0301 	bic.w	r3, r3, #1
 8000a28:	6013      	str	r3, [r2, #0]
        tickstart = HAL_GetTick();
 8000a2a:	f7ff fdcf 	bl	80005cc <HAL_GetTick>
 8000a2e:	4605      	mov	r5, r0
  return ((READ_BIT(RCC->CR, RCC_CR_MSIRDY) == (RCC_CR_MSIRDY)) ? 1UL : 0UL);
 8000a30:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8000a34:	681b      	ldr	r3, [r3, #0]
 8000a36:	f013 0f02 	tst.w	r3, #2
 8000a3a:	d094      	beq.n	8000966 <HAL_RCC_OscConfig+0xc6>
          if ((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
 8000a3c:	f7ff fdc6 	bl	80005cc <HAL_GetTick>
 8000a40:	1b40      	subs	r0, r0, r5
 8000a42:	2802      	cmp	r0, #2
 8000a44:	d9f4      	bls.n	8000a30 <HAL_RCC_OscConfig+0x190>
            return HAL_TIMEOUT;
 8000a46:	2003      	movs	r0, #3
 8000a48:	e2a6      	b.n	8000f98 <HAL_RCC_OscConfig+0x6f8>
        ((temp_sysclksrc == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (temp_plloscsrc == RCC_PLLSOURCE_HSE)))
 8000a4a:	2a03      	cmp	r2, #3
 8000a4c:	d19b      	bne.n	8000986 <HAL_RCC_OscConfig+0xe6>
  return ((READ_BIT(RCC->CR, RCC_CR_HSERDY) == (RCC_CR_HSERDY)) ? 1UL : 0UL);
 8000a4e:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8000a52:	681b      	ldr	r3, [r3, #0]
 8000a54:	f413 3f00 	tst.w	r3, #131072	; 0x20000
 8000a58:	d003      	beq.n	8000a62 <HAL_RCC_OscConfig+0x1c2>
      if ((LL_RCC_HSE_IsReady() != 0U) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 8000a5a:	6863      	ldr	r3, [r4, #4]
 8000a5c:	2b00      	cmp	r3, #0
 8000a5e:	f000 8296 	beq.w	8000f8e <HAL_RCC_OscConfig+0x6ee>
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 8000a62:	6823      	ldr	r3, [r4, #0]
 8000a64:	f013 0f02 	tst.w	r3, #2
 8000a68:	d05c      	beq.n	8000b24 <HAL_RCC_OscConfig+0x284>
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SWS));
 8000a6a:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 8000a6e:	6893      	ldr	r3, [r2, #8]
 8000a70:	f003 030c 	and.w	r3, r3, #12
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC));
 8000a74:	68d2      	ldr	r2, [r2, #12]
 8000a76:	f002 0203 	and.w	r2, r2, #3
    if ((temp_sysclksrc == RCC_SYSCLKSOURCE_STATUS_HSI) ||
 8000a7a:	2b04      	cmp	r3, #4
 8000a7c:	d03f      	beq.n	8000afe <HAL_RCC_OscConfig+0x25e>
 8000a7e:	2b0c      	cmp	r3, #12
 8000a80:	d03b      	beq.n	8000afa <HAL_RCC_OscConfig+0x25a>
      if (RCC_OscInitStruct->HSIState != RCC_HSI_OFF)
 8000a82:	68e3      	ldr	r3, [r4, #12]
 8000a84:	2b00      	cmp	r3, #0
 8000a86:	f000 8083 	beq.w	8000b90 <HAL_RCC_OscConfig+0x2f0>
  SET_BIT(RCC->CR, RCC_CR_HSION);
 8000a8a:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 8000a8e:	6813      	ldr	r3, [r2, #0]
 8000a90:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8000a94:	6013      	str	r3, [r2, #0]
        tickstart = HAL_GetTick();
 8000a96:	f7ff fd99 	bl	80005cc <HAL_GetTick>
 8000a9a:	4605      	mov	r5, r0
  return ((READ_BIT(RCC->CR, RCC_CR_HSIRDY) == (RCC_CR_HSIRDY)) ? 1UL : 0UL);
 8000a9c:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8000aa0:	681b      	ldr	r3, [r3, #0]
 8000aa2:	f413 6f80 	tst.w	r3, #1024	; 0x400
 8000aa6:	d169      	bne.n	8000b7c <HAL_RCC_OscConfig+0x2dc>
          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 8000aa8:	f7ff fd90 	bl	80005cc <HAL_GetTick>
 8000aac:	1b40      	subs	r0, r0, r5
 8000aae:	2802      	cmp	r0, #2
 8000ab0:	d9f4      	bls.n	8000a9c <HAL_RCC_OscConfig+0x1fc>
            return HAL_TIMEOUT;
 8000ab2:	2003      	movs	r0, #3
 8000ab4:	e270      	b.n	8000f98 <HAL_RCC_OscConfig+0x6f8>
  SET_BIT(RCC->CR, RCC_CR_HSEON);
 8000ab6:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 8000aba:	6813      	ldr	r3, [r2, #0]
 8000abc:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8000ac0:	6013      	str	r3, [r2, #0]
 8000ac2:	e773      	b.n	80009ac <HAL_RCC_OscConfig+0x10c>
  SET_BIT(RCC->CR, RCC_CR_HSEBYP);
 8000ac4:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8000ac8:	681a      	ldr	r2, [r3, #0]
 8000aca:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
 8000ace:	601a      	str	r2, [r3, #0]
  SET_BIT(RCC->CR, RCC_CR_HSEON);
 8000ad0:	681a      	ldr	r2, [r3, #0]
 8000ad2:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 8000ad6:	601a      	str	r2, [r3, #0]
 8000ad8:	e768      	b.n	80009ac <HAL_RCC_OscConfig+0x10c>
        tickstart = HAL_GetTick();
 8000ada:	f7ff fd77 	bl	80005cc <HAL_GetTick>
 8000ade:	4605      	mov	r5, r0
  return ((READ_BIT(RCC->CR, RCC_CR_HSERDY) == (RCC_CR_HSERDY)) ? 1UL : 0UL);
 8000ae0:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8000ae4:	681b      	ldr	r3, [r3, #0]
 8000ae6:	f413 3f00 	tst.w	r3, #131072	; 0x20000
 8000aea:	d0ba      	beq.n	8000a62 <HAL_RCC_OscConfig+0x1c2>
          if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 8000aec:	f7ff fd6e 	bl	80005cc <HAL_GetTick>
 8000af0:	1b40      	subs	r0, r0, r5
 8000af2:	2864      	cmp	r0, #100	; 0x64
 8000af4:	d9f4      	bls.n	8000ae0 <HAL_RCC_OscConfig+0x240>
            return HAL_TIMEOUT;
 8000af6:	2003      	movs	r0, #3
 8000af8:	e24e      	b.n	8000f98 <HAL_RCC_OscConfig+0x6f8>
        ((temp_sysclksrc == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (temp_plloscsrc == RCC_PLLSOURCE_HSI)))
 8000afa:	2a02      	cmp	r2, #2
 8000afc:	d1c1      	bne.n	8000a82 <HAL_RCC_OscConfig+0x1e2>
  return ((READ_BIT(RCC->CR, RCC_CR_HSIRDY) == (RCC_CR_HSIRDY)) ? 1UL : 0UL);
 8000afe:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8000b02:	681b      	ldr	r3, [r3, #0]
 8000b04:	f413 6f80 	tst.w	r3, #1024	; 0x400
 8000b08:	d003      	beq.n	8000b12 <HAL_RCC_OscConfig+0x272>
      if ((LL_RCC_HSI_IsReady() != 0U) && (RCC_OscInitStruct->HSIState == RCC_HSI_OFF))
 8000b0a:	68e3      	ldr	r3, [r4, #12]
 8000b0c:	2b00      	cmp	r3, #0
 8000b0e:	f000 8240 	beq.w	8000f92 <HAL_RCC_OscConfig+0x6f2>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8000b12:	6921      	ldr	r1, [r4, #16]
  MODIFY_REG(RCC->ICSCR, RCC_ICSCR_HSITRIM, Value << RCC_ICSCR_HSITRIM_Pos);
 8000b14:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 8000b18:	6853      	ldr	r3, [r2, #4]
 8000b1a:	f023 43fe 	bic.w	r3, r3, #2130706432	; 0x7f000000
 8000b1e:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
 8000b22:	6053      	str	r3, [r2, #4]
  if ((((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI1) == RCC_OSCILLATORTYPE_LSI1) || \
 8000b24:	6823      	ldr	r3, [r4, #0]
 8000b26:	f013 0f18 	tst.w	r3, #24
 8000b2a:	f000 80e5 	beq.w	8000cf8 <HAL_RCC_OscConfig+0x458>
    if (RCC_OscInitStruct->LSIState != RCC_LSI_OFF)
 8000b2e:	6962      	ldr	r2, [r4, #20]
 8000b30:	2a00      	cmp	r2, #0
 8000b32:	f000 80af 	beq.w	8000c94 <HAL_RCC_OscConfig+0x3f4>
      if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI2) == RCC_OSCILLATORTYPE_LSI2)
 8000b36:	f013 0f10 	tst.w	r3, #16
 8000b3a:	d07a      	beq.n	8000c32 <HAL_RCC_OscConfig+0x392>
  return ((READ_BIT(RCC->CSR, RCC_CSR_LSI1RDY) == (RCC_CSR_LSI1RDY)) ? 1UL : 0UL);
 8000b3c:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8000b40:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 8000b44:	f013 0f02 	tst.w	r3, #2
 8000b48:	d138      	bne.n	8000bbc <HAL_RCC_OscConfig+0x31c>
  SET_BIT(RCC->CSR, RCC_CSR_LSI1ON);
 8000b4a:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 8000b4e:	f8d2 3094 	ldr.w	r3, [r2, #148]	; 0x94
 8000b52:	f043 0301 	orr.w	r3, r3, #1
 8000b56:	f8c2 3094 	str.w	r3, [r2, #148]	; 0x94
          tickstart = HAL_GetTick();
 8000b5a:	f7ff fd37 	bl	80005cc <HAL_GetTick>
 8000b5e:	4605      	mov	r5, r0
  return ((READ_BIT(RCC->CSR, RCC_CSR_LSI1RDY) == (RCC_CSR_LSI1RDY)) ? 1UL : 0UL);
 8000b60:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8000b64:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 8000b68:	f013 0f02 	tst.w	r3, #2
 8000b6c:	d126      	bne.n	8000bbc <HAL_RCC_OscConfig+0x31c>
            if ((HAL_GetTick() - tickstart) > LSI1_TIMEOUT_VALUE)
 8000b6e:	f7ff fd2d 	bl	80005cc <HAL_GetTick>
 8000b72:	1b40      	subs	r0, r0, r5
 8000b74:	2802      	cmp	r0, #2
 8000b76:	d9f3      	bls.n	8000b60 <HAL_RCC_OscConfig+0x2c0>
              return HAL_TIMEOUT;
 8000b78:	2003      	movs	r0, #3
 8000b7a:	e20d      	b.n	8000f98 <HAL_RCC_OscConfig+0x6f8>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8000b7c:	6921      	ldr	r1, [r4, #16]
  MODIFY_REG(RCC->ICSCR, RCC_ICSCR_HSITRIM, Value << RCC_ICSCR_HSITRIM_Pos);
 8000b7e:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 8000b82:	6853      	ldr	r3, [r2, #4]
 8000b84:	f023 43fe 	bic.w	r3, r3, #2130706432	; 0x7f000000
 8000b88:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
 8000b8c:	6053      	str	r3, [r2, #4]
 8000b8e:	e7c9      	b.n	8000b24 <HAL_RCC_OscConfig+0x284>
  CLEAR_BIT(RCC->CR, RCC_CR_HSION);
 8000b90:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 8000b94:	6813      	ldr	r3, [r2, #0]
 8000b96:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8000b9a:	6013      	str	r3, [r2, #0]
        tickstart = HAL_GetTick();
 8000b9c:	f7ff fd16 	bl	80005cc <HAL_GetTick>
 8000ba0:	4605      	mov	r5, r0
  return ((READ_BIT(RCC->CR, RCC_CR_HSIRDY) == (RCC_CR_HSIRDY)) ? 1UL : 0UL);
 8000ba2:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8000ba6:	681b      	ldr	r3, [r3, #0]
 8000ba8:	f413 6f80 	tst.w	r3, #1024	; 0x400
 8000bac:	d0ba      	beq.n	8000b24 <HAL_RCC_OscConfig+0x284>
          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 8000bae:	f7ff fd0d 	bl	80005cc <HAL_GetTick>
 8000bb2:	1b40      	subs	r0, r0, r5
 8000bb4:	2802      	cmp	r0, #2
 8000bb6:	d9f4      	bls.n	8000ba2 <HAL_RCC_OscConfig+0x302>
            return HAL_TIMEOUT;
 8000bb8:	2003      	movs	r0, #3
 8000bba:	e1ed      	b.n	8000f98 <HAL_RCC_OscConfig+0x6f8>
  SET_BIT(RCC->CSR, RCC_CSR_LSI2ON);
 8000bbc:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 8000bc0:	f8d2 3094 	ldr.w	r3, [r2, #148]	; 0x94
 8000bc4:	f043 0304 	orr.w	r3, r3, #4
 8000bc8:	f8c2 3094 	str.w	r3, [r2, #148]	; 0x94
        tickstart = HAL_GetTick();
 8000bcc:	f7ff fcfe 	bl	80005cc <HAL_GetTick>
 8000bd0:	4605      	mov	r5, r0
  return ((READ_BIT(RCC->CSR, RCC_CSR_LSI2RDY) == (RCC_CSR_LSI2RDY)) ? 1UL : 0UL);
 8000bd2:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8000bd6:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 8000bda:	f013 0f08 	tst.w	r3, #8
 8000bde:	d106      	bne.n	8000bee <HAL_RCC_OscConfig+0x34e>
          if ((HAL_GetTick() - tickstart) > LSI2_TIMEOUT_VALUE)
 8000be0:	f7ff fcf4 	bl	80005cc <HAL_GetTick>
 8000be4:	1b40      	subs	r0, r0, r5
 8000be6:	2803      	cmp	r0, #3
 8000be8:	d9f3      	bls.n	8000bd2 <HAL_RCC_OscConfig+0x332>
            return HAL_TIMEOUT;
 8000bea:	2003      	movs	r0, #3
 8000bec:	e1d4      	b.n	8000f98 <HAL_RCC_OscConfig+0x6f8>
        __HAL_RCC_LSI2_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->LSI2CalibrationValue);
 8000bee:	69a1      	ldr	r1, [r4, #24]
  MODIFY_REG(RCC->CSR, RCC_CSR_LSI2TRIM, Value << RCC_CSR_LSI2TRIM_Pos);
 8000bf0:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 8000bf4:	f8d2 3094 	ldr.w	r3, [r2, #148]	; 0x94
 8000bf8:	f423 6370 	bic.w	r3, r3, #3840	; 0xf00
 8000bfc:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 8000c00:	f8c2 3094 	str.w	r3, [r2, #148]	; 0x94
  CLEAR_BIT(RCC->CSR, RCC_CSR_LSI1ON);
 8000c04:	f8d2 3094 	ldr.w	r3, [r2, #148]	; 0x94
 8000c08:	f023 0301 	bic.w	r3, r3, #1
 8000c0c:	f8c2 3094 	str.w	r3, [r2, #148]	; 0x94
        tickstart = HAL_GetTick();
 8000c10:	f7ff fcdc 	bl	80005cc <HAL_GetTick>
 8000c14:	4605      	mov	r5, r0
  return ((READ_BIT(RCC->CSR, RCC_CSR_LSI1RDY) == (RCC_CSR_LSI1RDY)) ? 1UL : 0UL);
 8000c16:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8000c1a:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 8000c1e:	f013 0f02 	tst.w	r3, #2
 8000c22:	d069      	beq.n	8000cf8 <HAL_RCC_OscConfig+0x458>
          if ((HAL_GetTick() - tickstart) > LSI1_TIMEOUT_VALUE)
 8000c24:	f7ff fcd2 	bl	80005cc <HAL_GetTick>
 8000c28:	1b40      	subs	r0, r0, r5
 8000c2a:	2802      	cmp	r0, #2
 8000c2c:	d9f3      	bls.n	8000c16 <HAL_RCC_OscConfig+0x376>
            return HAL_TIMEOUT;
 8000c2e:	2003      	movs	r0, #3
 8000c30:	e1b2      	b.n	8000f98 <HAL_RCC_OscConfig+0x6f8>
  SET_BIT(RCC->CSR, RCC_CSR_LSI1ON);
 8000c32:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 8000c36:	f8d2 3094 	ldr.w	r3, [r2, #148]	; 0x94
 8000c3a:	f043 0301 	orr.w	r3, r3, #1
 8000c3e:	f8c2 3094 	str.w	r3, [r2, #148]	; 0x94
        tickstart = HAL_GetTick();
 8000c42:	f7ff fcc3 	bl	80005cc <HAL_GetTick>
 8000c46:	4605      	mov	r5, r0
  return ((READ_BIT(RCC->CSR, RCC_CSR_LSI1RDY) == (RCC_CSR_LSI1RDY)) ? 1UL : 0UL);
 8000c48:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8000c4c:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 8000c50:	f013 0f02 	tst.w	r3, #2
 8000c54:	d108      	bne.n	8000c68 <HAL_RCC_OscConfig+0x3c8>
          if ((HAL_GetTick() - tickstart) > LSI1_TIMEOUT_VALUE)
 8000c56:	f7ff fcb9 	bl	80005cc <HAL_GetTick>
 8000c5a:	1b40      	subs	r0, r0, r5
 8000c5c:	2802      	cmp	r0, #2
 8000c5e:	d9f3      	bls.n	8000c48 <HAL_RCC_OscConfig+0x3a8>
            return HAL_TIMEOUT;
 8000c60:	2003      	movs	r0, #3
 8000c62:	e199      	b.n	8000f98 <HAL_RCC_OscConfig+0x6f8>
 8000c64:	2000000c 	.word	0x2000000c
  CLEAR_BIT(RCC->CSR, RCC_CSR_LSI2ON);
 8000c68:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 8000c6c:	f8d2 3094 	ldr.w	r3, [r2, #148]	; 0x94
 8000c70:	f023 0304 	bic.w	r3, r3, #4
 8000c74:	f8c2 3094 	str.w	r3, [r2, #148]	; 0x94
  return ((READ_BIT(RCC->CSR, RCC_CSR_LSI2RDY) == (RCC_CSR_LSI2RDY)) ? 1UL : 0UL);
 8000c78:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8000c7c:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 8000c80:	f013 0f08 	tst.w	r3, #8
 8000c84:	d038      	beq.n	8000cf8 <HAL_RCC_OscConfig+0x458>
          if ((HAL_GetTick() - tickstart) > LSI2_TIMEOUT_VALUE)
 8000c86:	f7ff fca1 	bl	80005cc <HAL_GetTick>
 8000c8a:	1b40      	subs	r0, r0, r5
 8000c8c:	2803      	cmp	r0, #3
 8000c8e:	d9f3      	bls.n	8000c78 <HAL_RCC_OscConfig+0x3d8>
            return HAL_TIMEOUT;
 8000c90:	2003      	movs	r0, #3
 8000c92:	e181      	b.n	8000f98 <HAL_RCC_OscConfig+0x6f8>
  CLEAR_BIT(RCC->CSR, RCC_CSR_LSI2ON);
 8000c94:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 8000c98:	f8d2 3094 	ldr.w	r3, [r2, #148]	; 0x94
 8000c9c:	f023 0304 	bic.w	r3, r3, #4
 8000ca0:	f8c2 3094 	str.w	r3, [r2, #148]	; 0x94
      tickstart = HAL_GetTick();
 8000ca4:	f7ff fc92 	bl	80005cc <HAL_GetTick>
 8000ca8:	4605      	mov	r5, r0
  return ((READ_BIT(RCC->CSR, RCC_CSR_LSI2RDY) == (RCC_CSR_LSI2RDY)) ? 1UL : 0UL);
 8000caa:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8000cae:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 8000cb2:	f013 0f08 	tst.w	r3, #8
 8000cb6:	d006      	beq.n	8000cc6 <HAL_RCC_OscConfig+0x426>
        if ((HAL_GetTick() - tickstart) > LSI2_TIMEOUT_VALUE)
 8000cb8:	f7ff fc88 	bl	80005cc <HAL_GetTick>
 8000cbc:	1b40      	subs	r0, r0, r5
 8000cbe:	2803      	cmp	r0, #3
 8000cc0:	d9f3      	bls.n	8000caa <HAL_RCC_OscConfig+0x40a>
          return HAL_TIMEOUT;
 8000cc2:	2003      	movs	r0, #3
 8000cc4:	e168      	b.n	8000f98 <HAL_RCC_OscConfig+0x6f8>
  CLEAR_BIT(RCC->CSR, RCC_CSR_LSI1ON);
 8000cc6:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 8000cca:	f8d2 3094 	ldr.w	r3, [r2, #148]	; 0x94
 8000cce:	f023 0301 	bic.w	r3, r3, #1
 8000cd2:	f8c2 3094 	str.w	r3, [r2, #148]	; 0x94
      tickstart = HAL_GetTick();
 8000cd6:	f7ff fc79 	bl	80005cc <HAL_GetTick>
 8000cda:	4605      	mov	r5, r0
  return ((READ_BIT(RCC->CSR, RCC_CSR_LSI1RDY) == (RCC_CSR_LSI1RDY)) ? 1UL : 0UL);
 8000cdc:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8000ce0:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 8000ce4:	f013 0f02 	tst.w	r3, #2
 8000ce8:	d006      	beq.n	8000cf8 <HAL_RCC_OscConfig+0x458>
        if ((HAL_GetTick() - tickstart) > LSI1_TIMEOUT_VALUE)
 8000cea:	f7ff fc6f 	bl	80005cc <HAL_GetTick>
 8000cee:	1b40      	subs	r0, r0, r5
 8000cf0:	2802      	cmp	r0, #2
 8000cf2:	d9f3      	bls.n	8000cdc <HAL_RCC_OscConfig+0x43c>
          return HAL_TIMEOUT;
 8000cf4:	2003      	movs	r0, #3
 8000cf6:	e14f      	b.n	8000f98 <HAL_RCC_OscConfig+0x6f8>
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 8000cf8:	6823      	ldr	r3, [r4, #0]
 8000cfa:	f013 0f04 	tst.w	r3, #4
 8000cfe:	d068      	beq.n	8000dd2 <HAL_RCC_OscConfig+0x532>
    if (HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 8000d00:	4baa      	ldr	r3, [pc, #680]	; (8000fac <HAL_RCC_OscConfig+0x70c>)
 8000d02:	681b      	ldr	r3, [r3, #0]
 8000d04:	f413 7f80 	tst.w	r3, #256	; 0x100
 8000d08:	d027      	beq.n	8000d5a <HAL_RCC_OscConfig+0x4ba>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8000d0a:	68a3      	ldr	r3, [r4, #8]
 8000d0c:	2b01      	cmp	r3, #1
 8000d0e:	d035      	beq.n	8000d7c <HAL_RCC_OscConfig+0x4dc>
 8000d10:	2b05      	cmp	r3, #5
 8000d12:	d03c      	beq.n	8000d8e <HAL_RCC_OscConfig+0x4ee>
  CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSEON);
 8000d14:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8000d18:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 8000d1c:	f022 0201 	bic.w	r2, r2, #1
 8000d20:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
  CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSEBYP);
 8000d24:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 8000d28:	f022 0204 	bic.w	r2, r2, #4
 8000d2c:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
    if (RCC_OscInitStruct->LSEState != RCC_LSE_OFF)
 8000d30:	68a3      	ldr	r3, [r4, #8]
 8000d32:	b3db      	cbz	r3, 8000dac <HAL_RCC_OscConfig+0x50c>
      tickstart = HAL_GetTick();
 8000d34:	f7ff fc4a 	bl	80005cc <HAL_GetTick>
 8000d38:	4605      	mov	r5, r0
  return ((READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == (RCC_BDCR_LSERDY)) ? 1UL : 0UL);
 8000d3a:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8000d3e:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8000d42:	f013 0f02 	tst.w	r3, #2
 8000d46:	d144      	bne.n	8000dd2 <HAL_RCC_OscConfig+0x532>
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8000d48:	f7ff fc40 	bl	80005cc <HAL_GetTick>
 8000d4c:	1b40      	subs	r0, r0, r5
 8000d4e:	f241 3388 	movw	r3, #5000	; 0x1388
 8000d52:	4298      	cmp	r0, r3
 8000d54:	d9f1      	bls.n	8000d3a <HAL_RCC_OscConfig+0x49a>
          return HAL_TIMEOUT;
 8000d56:	2003      	movs	r0, #3
 8000d58:	e11e      	b.n	8000f98 <HAL_RCC_OscConfig+0x6f8>
      HAL_PWR_EnableBkUpAccess();
 8000d5a:	f7ff fd0d 	bl	8000778 <HAL_PWR_EnableBkUpAccess>
      tickstart = HAL_GetTick();
 8000d5e:	f7ff fc35 	bl	80005cc <HAL_GetTick>
 8000d62:	4605      	mov	r5, r0
      while (HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 8000d64:	4b91      	ldr	r3, [pc, #580]	; (8000fac <HAL_RCC_OscConfig+0x70c>)
 8000d66:	681b      	ldr	r3, [r3, #0]
 8000d68:	f413 7f80 	tst.w	r3, #256	; 0x100
 8000d6c:	d1cd      	bne.n	8000d0a <HAL_RCC_OscConfig+0x46a>
        if ((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 8000d6e:	f7ff fc2d 	bl	80005cc <HAL_GetTick>
 8000d72:	1b40      	subs	r0, r0, r5
 8000d74:	2802      	cmp	r0, #2
 8000d76:	d9f5      	bls.n	8000d64 <HAL_RCC_OscConfig+0x4c4>
          return HAL_TIMEOUT;
 8000d78:	2003      	movs	r0, #3
 8000d7a:	e10d      	b.n	8000f98 <HAL_RCC_OscConfig+0x6f8>
  SET_BIT(RCC->BDCR, RCC_BDCR_LSEON);
 8000d7c:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 8000d80:	f8d2 3090 	ldr.w	r3, [r2, #144]	; 0x90
 8000d84:	f043 0301 	orr.w	r3, r3, #1
 8000d88:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
 8000d8c:	e7d0      	b.n	8000d30 <HAL_RCC_OscConfig+0x490>
  SET_BIT(RCC->BDCR, RCC_BDCR_LSEBYP);
 8000d8e:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8000d92:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 8000d96:	f042 0204 	orr.w	r2, r2, #4
 8000d9a:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
  SET_BIT(RCC->BDCR, RCC_BDCR_LSEON);
 8000d9e:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 8000da2:	f042 0201 	orr.w	r2, r2, #1
 8000da6:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
 8000daa:	e7c1      	b.n	8000d30 <HAL_RCC_OscConfig+0x490>
      tickstart = HAL_GetTick();
 8000dac:	f7ff fc0e 	bl	80005cc <HAL_GetTick>
 8000db0:	4605      	mov	r5, r0
  return ((READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == (RCC_BDCR_LSERDY)) ? 1UL : 0UL);
 8000db2:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8000db6:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8000dba:	f013 0f02 	tst.w	r3, #2
 8000dbe:	d008      	beq.n	8000dd2 <HAL_RCC_OscConfig+0x532>
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8000dc0:	f7ff fc04 	bl	80005cc <HAL_GetTick>
 8000dc4:	1b40      	subs	r0, r0, r5
 8000dc6:	f241 3388 	movw	r3, #5000	; 0x1388
 8000dca:	4298      	cmp	r0, r3
 8000dcc:	d9f1      	bls.n	8000db2 <HAL_RCC_OscConfig+0x512>
          return HAL_TIMEOUT;
 8000dce:	2003      	movs	r0, #3
 8000dd0:	e0e2      	b.n	8000f98 <HAL_RCC_OscConfig+0x6f8>
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI48) == RCC_OSCILLATORTYPE_HSI48)
 8000dd2:	6823      	ldr	r3, [r4, #0]
 8000dd4:	f013 0f40 	tst.w	r3, #64	; 0x40
 8000dd8:	d033      	beq.n	8000e42 <HAL_RCC_OscConfig+0x5a2>
    if (RCC_OscInitStruct->HSI48State != RCC_HSI48_OFF)
 8000dda:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8000ddc:	b1c3      	cbz	r3, 8000e10 <HAL_RCC_OscConfig+0x570>
  SET_BIT(RCC->CRRCR, RCC_CRRCR_HSI48ON);
 8000dde:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 8000de2:	f8d2 3098 	ldr.w	r3, [r2, #152]	; 0x98
 8000de6:	f043 0301 	orr.w	r3, r3, #1
 8000dea:	f8c2 3098 	str.w	r3, [r2, #152]	; 0x98
      tickstart = HAL_GetTick();
 8000dee:	f7ff fbed 	bl	80005cc <HAL_GetTick>
 8000df2:	4605      	mov	r5, r0
  return ((READ_BIT(RCC->CRRCR, RCC_CRRCR_HSI48RDY) == (RCC_CRRCR_HSI48RDY)) ? 1UL : 0UL);
 8000df4:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8000df8:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
 8000dfc:	f013 0f02 	tst.w	r3, #2
 8000e00:	d11f      	bne.n	8000e42 <HAL_RCC_OscConfig+0x5a2>
        if ((HAL_GetTick() - tickstart) > HSI48_TIMEOUT_VALUE)
 8000e02:	f7ff fbe3 	bl	80005cc <HAL_GetTick>
 8000e06:	1b40      	subs	r0, r0, r5
 8000e08:	2802      	cmp	r0, #2
 8000e0a:	d9f3      	bls.n	8000df4 <HAL_RCC_OscConfig+0x554>
          return HAL_TIMEOUT;
 8000e0c:	2003      	movs	r0, #3
 8000e0e:	e0c3      	b.n	8000f98 <HAL_RCC_OscConfig+0x6f8>
  CLEAR_BIT(RCC->CRRCR, RCC_CRRCR_HSI48ON);
 8000e10:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 8000e14:	f8d2 3098 	ldr.w	r3, [r2, #152]	; 0x98
 8000e18:	f023 0301 	bic.w	r3, r3, #1
 8000e1c:	f8c2 3098 	str.w	r3, [r2, #152]	; 0x98
      tickstart = HAL_GetTick();
 8000e20:	f7ff fbd4 	bl	80005cc <HAL_GetTick>
 8000e24:	4605      	mov	r5, r0
  return ((READ_BIT(RCC->CRRCR, RCC_CRRCR_HSI48RDY) == (RCC_CRRCR_HSI48RDY)) ? 1UL : 0UL);
 8000e26:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8000e2a:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
 8000e2e:	f013 0f02 	tst.w	r3, #2
 8000e32:	d006      	beq.n	8000e42 <HAL_RCC_OscConfig+0x5a2>
        if ((HAL_GetTick() - tickstart) > HSI48_TIMEOUT_VALUE)
 8000e34:	f7ff fbca 	bl	80005cc <HAL_GetTick>
 8000e38:	1b40      	subs	r0, r0, r5
 8000e3a:	2802      	cmp	r0, #2
 8000e3c:	d9f3      	bls.n	8000e26 <HAL_RCC_OscConfig+0x586>
          return HAL_TIMEOUT;
 8000e3e:	2003      	movs	r0, #3
 8000e40:	e0aa      	b.n	8000f98 <HAL_RCC_OscConfig+0x6f8>
  if (RCC_OscInitStruct->PLL.PLLState != RCC_PLL_NONE)
 8000e42:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8000e44:	2b00      	cmp	r3, #0
 8000e46:	f000 80a6 	beq.w	8000f96 <HAL_RCC_OscConfig+0x6f6>
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SWS));
 8000e4a:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 8000e4e:	6892      	ldr	r2, [r2, #8]
 8000e50:	f002 020c 	and.w	r2, r2, #12
    if (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 8000e54:	2a0c      	cmp	r2, #12
 8000e56:	d063      	beq.n	8000f20 <HAL_RCC_OscConfig+0x680>
      if (RCC_OscInitStruct->PLL.PLLState == RCC_PLL_ON)
 8000e58:	2b02      	cmp	r3, #2
 8000e5a:	d020      	beq.n	8000e9e <HAL_RCC_OscConfig+0x5fe>
  CLEAR_BIT(RCC->CR, RCC_CR_PLLON);
 8000e5c:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8000e60:	681a      	ldr	r2, [r3, #0]
 8000e62:	f022 7280 	bic.w	r2, r2, #16777216	; 0x1000000
 8000e66:	601a      	str	r2, [r3, #0]
        MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC, PLLSOURCE_NONE);
 8000e68:	68da      	ldr	r2, [r3, #12]
 8000e6a:	f022 0203 	bic.w	r2, r2, #3
 8000e6e:	60da      	str	r2, [r3, #12]
        __HAL_RCC_PLLCLKOUT_DISABLE(RCC_PLL_SYSCLK | RCC_PLL_USBCLK | RCC_PLL_SAI1CLK);
 8000e70:	68da      	ldr	r2, [r3, #12]
 8000e72:	f022 5288 	bic.w	r2, r2, #285212672	; 0x11000000
 8000e76:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8000e7a:	60da      	str	r2, [r3, #12]
        tickstart = HAL_GetTick();
 8000e7c:	f7ff fba6 	bl	80005cc <HAL_GetTick>
 8000e80:	4604      	mov	r4, r0
  return ((READ_BIT(RCC->CR, RCC_CR_PLLRDY) == (RCC_CR_PLLRDY)) ? 1UL : 0UL);
 8000e82:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8000e86:	681b      	ldr	r3, [r3, #0]
 8000e88:	f013 7f00 	tst.w	r3, #33554432	; 0x2000000
 8000e8c:	f000 8087 	beq.w	8000f9e <HAL_RCC_OscConfig+0x6fe>
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8000e90:	f7ff fb9c 	bl	80005cc <HAL_GetTick>
 8000e94:	1b00      	subs	r0, r0, r4
 8000e96:	2802      	cmp	r0, #2
 8000e98:	d9f3      	bls.n	8000e82 <HAL_RCC_OscConfig+0x5e2>
            return HAL_TIMEOUT;
 8000e9a:	2003      	movs	r0, #3
 8000e9c:	e07c      	b.n	8000f98 <HAL_RCC_OscConfig+0x6f8>
  CLEAR_BIT(RCC->CR, RCC_CR_PLLON);
 8000e9e:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 8000ea2:	6813      	ldr	r3, [r2, #0]
 8000ea4:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 8000ea8:	6013      	str	r3, [r2, #0]
        tickstart = HAL_GetTick();
 8000eaa:	f7ff fb8f 	bl	80005cc <HAL_GetTick>
 8000eae:	4605      	mov	r5, r0
  return ((READ_BIT(RCC->CR, RCC_CR_PLLRDY) == (RCC_CR_PLLRDY)) ? 1UL : 0UL);
 8000eb0:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8000eb4:	681b      	ldr	r3, [r3, #0]
 8000eb6:	f013 7f00 	tst.w	r3, #33554432	; 0x2000000
 8000eba:	d006      	beq.n	8000eca <HAL_RCC_OscConfig+0x62a>
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8000ebc:	f7ff fb86 	bl	80005cc <HAL_GetTick>
 8000ec0:	1b40      	subs	r0, r0, r5
 8000ec2:	2802      	cmp	r0, #2
 8000ec4:	d9f4      	bls.n	8000eb0 <HAL_RCC_OscConfig+0x610>
            return HAL_TIMEOUT;
 8000ec6:	2003      	movs	r0, #3
 8000ec8:	e066      	b.n	8000f98 <HAL_RCC_OscConfig+0x6f8>
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 8000eca:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 8000ece:	68d3      	ldr	r3, [r2, #12]
 8000ed0:	4937      	ldr	r1, [pc, #220]	; (8000fb0 <HAL_RCC_OscConfig+0x710>)
 8000ed2:	4019      	ands	r1, r3
 8000ed4:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8000ed6:	6b60      	ldr	r0, [r4, #52]	; 0x34
 8000ed8:	4303      	orrs	r3, r0
 8000eda:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 8000edc:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
 8000ee0:	6be0      	ldr	r0, [r4, #60]	; 0x3c
 8000ee2:	4303      	orrs	r3, r0
 8000ee4:	6c20      	ldr	r0, [r4, #64]	; 0x40
 8000ee6:	4303      	orrs	r3, r0
 8000ee8:	6c60      	ldr	r0, [r4, #68]	; 0x44
 8000eea:	4303      	orrs	r3, r0
 8000eec:	430b      	orrs	r3, r1
 8000eee:	60d3      	str	r3, [r2, #12]
  SET_BIT(RCC->CR, RCC_CR_PLLON);
 8000ef0:	6813      	ldr	r3, [r2, #0]
 8000ef2:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8000ef6:	6013      	str	r3, [r2, #0]
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SYSCLK);
 8000ef8:	68d3      	ldr	r3, [r2, #12]
 8000efa:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8000efe:	60d3      	str	r3, [r2, #12]
        tickstart = HAL_GetTick();
 8000f00:	f7ff fb64 	bl	80005cc <HAL_GetTick>
 8000f04:	4604      	mov	r4, r0
  return ((READ_BIT(RCC->CR, RCC_CR_PLLRDY) == (RCC_CR_PLLRDY)) ? 1UL : 0UL);
 8000f06:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8000f0a:	681b      	ldr	r3, [r3, #0]
 8000f0c:	f013 7f00 	tst.w	r3, #33554432	; 0x2000000
 8000f10:	d143      	bne.n	8000f9a <HAL_RCC_OscConfig+0x6fa>
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8000f12:	f7ff fb5b 	bl	80005cc <HAL_GetTick>
 8000f16:	1b00      	subs	r0, r0, r4
 8000f18:	2802      	cmp	r0, #2
 8000f1a:	d9f4      	bls.n	8000f06 <HAL_RCC_OscConfig+0x666>
            return HAL_TIMEOUT;
 8000f1c:	2003      	movs	r0, #3
 8000f1e:	e03b      	b.n	8000f98 <HAL_RCC_OscConfig+0x6f8>
      if ((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF)
 8000f20:	2b01      	cmp	r3, #1
 8000f22:	d03e      	beq.n	8000fa2 <HAL_RCC_OscConfig+0x702>
        uint32_t pllcfgr = RCC->PLLCFGR;
 8000f24:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8000f28:	68db      	ldr	r3, [r3, #12]
        if ((READ_BIT(pllcfgr, RCC_PLLCFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 8000f2a:	f003 0103 	and.w	r1, r3, #3
 8000f2e:	6b22      	ldr	r2, [r4, #48]	; 0x30
 8000f30:	4291      	cmp	r1, r2
 8000f32:	d001      	beq.n	8000f38 <HAL_RCC_OscConfig+0x698>
          return HAL_ERROR;
 8000f34:	2001      	movs	r0, #1
 8000f36:	e02f      	b.n	8000f98 <HAL_RCC_OscConfig+0x6f8>
            (READ_BIT(pllcfgr, RCC_PLLCFGR_PLLM) != RCC_OscInitStruct->PLL.PLLM) ||
 8000f38:	f003 0270 	and.w	r2, r3, #112	; 0x70
 8000f3c:	6b61      	ldr	r1, [r4, #52]	; 0x34
        if ((READ_BIT(pllcfgr, RCC_PLLCFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 8000f3e:	428a      	cmp	r2, r1
 8000f40:	d001      	beq.n	8000f46 <HAL_RCC_OscConfig+0x6a6>
          return HAL_ERROR;
 8000f42:	2001      	movs	r0, #1
 8000f44:	e028      	b.n	8000f98 <HAL_RCC_OscConfig+0x6f8>
            ((READ_BIT(pllcfgr, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos) != RCC_OscInitStruct->PLL.PLLN) ||
 8000f46:	f3c3 2206 	ubfx	r2, r3, #8, #7
 8000f4a:	6ba1      	ldr	r1, [r4, #56]	; 0x38
            (READ_BIT(pllcfgr, RCC_PLLCFGR_PLLM) != RCC_OscInitStruct->PLL.PLLM) ||
 8000f4c:	428a      	cmp	r2, r1
 8000f4e:	d001      	beq.n	8000f54 <HAL_RCC_OscConfig+0x6b4>
          return HAL_ERROR;
 8000f50:	2001      	movs	r0, #1
 8000f52:	e021      	b.n	8000f98 <HAL_RCC_OscConfig+0x6f8>
            (READ_BIT(pllcfgr, RCC_PLLCFGR_PLLP) != RCC_OscInitStruct->PLL.PLLP) ||
 8000f54:	f403 1278 	and.w	r2, r3, #4063232	; 0x3e0000
 8000f58:	6be1      	ldr	r1, [r4, #60]	; 0x3c
            ((READ_BIT(pllcfgr, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos) != RCC_OscInitStruct->PLL.PLLN) ||
 8000f5a:	428a      	cmp	r2, r1
 8000f5c:	d001      	beq.n	8000f62 <HAL_RCC_OscConfig+0x6c2>
          return HAL_ERROR;
 8000f5e:	2001      	movs	r0, #1
 8000f60:	e01a      	b.n	8000f98 <HAL_RCC_OscConfig+0x6f8>
            (READ_BIT(pllcfgr, RCC_PLLCFGR_PLLQ) != RCC_OscInitStruct->PLL.PLLQ) ||
 8000f62:	f003 6260 	and.w	r2, r3, #234881024	; 0xe000000
 8000f66:	6c21      	ldr	r1, [r4, #64]	; 0x40
            (READ_BIT(pllcfgr, RCC_PLLCFGR_PLLP) != RCC_OscInitStruct->PLL.PLLP) ||
 8000f68:	428a      	cmp	r2, r1
 8000f6a:	d001      	beq.n	8000f70 <HAL_RCC_OscConfig+0x6d0>
          return HAL_ERROR;
 8000f6c:	2001      	movs	r0, #1
 8000f6e:	e013      	b.n	8000f98 <HAL_RCC_OscConfig+0x6f8>
            (READ_BIT(pllcfgr, RCC_PLLCFGR_PLLR) != RCC_OscInitStruct->PLL.PLLR))
 8000f70:	f003 4360 	and.w	r3, r3, #3758096384	; 0xe0000000
 8000f74:	6c62      	ldr	r2, [r4, #68]	; 0x44
            (READ_BIT(pllcfgr, RCC_PLLCFGR_PLLQ) != RCC_OscInitStruct->PLL.PLLQ) ||
 8000f76:	4293      	cmp	r3, r2
 8000f78:	d015      	beq.n	8000fa6 <HAL_RCC_OscConfig+0x706>
          return HAL_ERROR;
 8000f7a:	2001      	movs	r0, #1
 8000f7c:	e00c      	b.n	8000f98 <HAL_RCC_OscConfig+0x6f8>
    return HAL_ERROR;
 8000f7e:	2001      	movs	r0, #1
}
 8000f80:	4770      	bx	lr
        return HAL_ERROR;
 8000f82:	2001      	movs	r0, #1
 8000f84:	e008      	b.n	8000f98 <HAL_RCC_OscConfig+0x6f8>
            return HAL_ERROR;
 8000f86:	2001      	movs	r0, #1
 8000f88:	e006      	b.n	8000f98 <HAL_RCC_OscConfig+0x6f8>
          return HAL_ERROR;
 8000f8a:	2001      	movs	r0, #1
 8000f8c:	e004      	b.n	8000f98 <HAL_RCC_OscConfig+0x6f8>
        return HAL_ERROR;
 8000f8e:	2001      	movs	r0, #1
 8000f90:	e002      	b.n	8000f98 <HAL_RCC_OscConfig+0x6f8>
        return HAL_ERROR;
 8000f92:	2001      	movs	r0, #1
 8000f94:	e000      	b.n	8000f98 <HAL_RCC_OscConfig+0x6f8>
  return HAL_OK;
 8000f96:	2000      	movs	r0, #0
}
 8000f98:	bd38      	pop	{r3, r4, r5, pc}
  return HAL_OK;
 8000f9a:	2000      	movs	r0, #0
 8000f9c:	e7fc      	b.n	8000f98 <HAL_RCC_OscConfig+0x6f8>
 8000f9e:	2000      	movs	r0, #0
 8000fa0:	e7fa      	b.n	8000f98 <HAL_RCC_OscConfig+0x6f8>
        return HAL_ERROR;
 8000fa2:	2001      	movs	r0, #1
 8000fa4:	e7f8      	b.n	8000f98 <HAL_RCC_OscConfig+0x6f8>
  return HAL_OK;
 8000fa6:	2000      	movs	r0, #0
 8000fa8:	e7f6      	b.n	8000f98 <HAL_RCC_OscConfig+0x6f8>
 8000faa:	bf00      	nop
 8000fac:	58000400 	.word	0x58000400
 8000fb0:	11c1808c 	.word	0x11c1808c

08000fb4 <HAL_RCC_ClockConfig>:
  if (RCC_ClkInitStruct == NULL)
 8000fb4:	2800      	cmp	r0, #0
 8000fb6:	f000 8127 	beq.w	8001208 <HAL_RCC_ClockConfig+0x254>
{
 8000fba:	b570      	push	{r4, r5, r6, lr}
 8000fbc:	4604      	mov	r4, r0
 8000fbe:	460d      	mov	r5, r1
  if (FLatency > __HAL_FLASH_GET_LATENCY())
 8000fc0:	4b92      	ldr	r3, [pc, #584]	; (800120c <HAL_RCC_ClockConfig+0x258>)
 8000fc2:	681b      	ldr	r3, [r3, #0]
 8000fc4:	f003 0307 	and.w	r3, r3, #7
 8000fc8:	428b      	cmp	r3, r1
 8000fca:	d32d      	bcc.n	8001028 <HAL_RCC_ClockConfig+0x74>
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 8000fcc:	6823      	ldr	r3, [r4, #0]
 8000fce:	f013 0f02 	tst.w	r3, #2
 8000fd2:	d13f      	bne.n	8001054 <HAL_RCC_ClockConfig+0xa0>
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK2) == RCC_CLOCKTYPE_HCLK2)
 8000fd4:	6823      	ldr	r3, [r4, #0]
 8000fd6:	f013 0f20 	tst.w	r3, #32
 8000fda:	d153      	bne.n	8001084 <HAL_RCC_ClockConfig+0xd0>
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK4) == RCC_CLOCKTYPE_HCLK4)
 8000fdc:	6823      	ldr	r3, [r4, #0]
 8000fde:	f013 0f40 	tst.w	r3, #64	; 0x40
 8000fe2:	d16a      	bne.n	80010ba <HAL_RCC_ClockConfig+0x106>
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 8000fe4:	6823      	ldr	r3, [r4, #0]
 8000fe6:	f013 0f04 	tst.w	r3, #4
 8000fea:	f040 8083 	bne.w	80010f4 <HAL_RCC_ClockConfig+0x140>
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8000fee:	6823      	ldr	r3, [r4, #0]
 8000ff0:	f013 0f08 	tst.w	r3, #8
 8000ff4:	f040 8097 	bne.w	8001126 <HAL_RCC_ClockConfig+0x172>
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 8000ff8:	6823      	ldr	r3, [r4, #0]
 8000ffa:	f013 0f01 	tst.w	r3, #1
 8000ffe:	f000 80e0 	beq.w	80011c2 <HAL_RCC_ClockConfig+0x20e>
    if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8001002:	6863      	ldr	r3, [r4, #4]
 8001004:	2b02      	cmp	r3, #2
 8001006:	f000 80a8 	beq.w	800115a <HAL_RCC_ClockConfig+0x1a6>
    else if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 800100a:	2b03      	cmp	r3, #3
 800100c:	f000 80c9 	beq.w	80011a2 <HAL_RCC_ClockConfig+0x1ee>
    else if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_MSI)
 8001010:	2b00      	cmp	r3, #0
 8001012:	f040 80ce 	bne.w	80011b2 <HAL_RCC_ClockConfig+0x1fe>
  return ((READ_BIT(RCC->CR, RCC_CR_MSIRDY) == (RCC_CR_MSIRDY)) ? 1UL : 0UL);
 8001016:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 800101a:	6812      	ldr	r2, [r2, #0]
 800101c:	f012 0f02 	tst.w	r2, #2
 8001020:	f040 80a1 	bne.w	8001166 <HAL_RCC_ClockConfig+0x1b2>
        return HAL_ERROR;
 8001024:	2001      	movs	r0, #1
 8001026:	e0ee      	b.n	8001206 <HAL_RCC_ClockConfig+0x252>
    __HAL_FLASH_SET_LATENCY(FLatency);
 8001028:	4a78      	ldr	r2, [pc, #480]	; (800120c <HAL_RCC_ClockConfig+0x258>)
 800102a:	6813      	ldr	r3, [r2, #0]
 800102c:	f023 0307 	bic.w	r3, r3, #7
 8001030:	430b      	orrs	r3, r1
 8001032:	6013      	str	r3, [r2, #0]
    tickstart = HAL_GetTick();
 8001034:	f7ff faca 	bl	80005cc <HAL_GetTick>
 8001038:	4606      	mov	r6, r0
    while (__HAL_FLASH_GET_LATENCY() != FLatency)
 800103a:	4b74      	ldr	r3, [pc, #464]	; (800120c <HAL_RCC_ClockConfig+0x258>)
 800103c:	681b      	ldr	r3, [r3, #0]
 800103e:	f003 0307 	and.w	r3, r3, #7
 8001042:	42ab      	cmp	r3, r5
 8001044:	d0c2      	beq.n	8000fcc <HAL_RCC_ClockConfig+0x18>
      if ((HAL_GetTick() - tickstart) > LATENCY_TIMEOUT_VALUE)
 8001046:	f7ff fac1 	bl	80005cc <HAL_GetTick>
 800104a:	1b80      	subs	r0, r0, r6
 800104c:	2802      	cmp	r0, #2
 800104e:	d9f4      	bls.n	800103a <HAL_RCC_ClockConfig+0x86>
        return HAL_TIMEOUT;
 8001050:	2003      	movs	r0, #3
 8001052:	e0d8      	b.n	8001206 <HAL_RCC_ClockConfig+0x252>
    LL_RCC_SetAHBPrescaler(RCC_ClkInitStruct->AHBCLKDivider);
 8001054:	68a3      	ldr	r3, [r4, #8]
  MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, Prescaler);
 8001056:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 800105a:	688a      	ldr	r2, [r1, #8]
 800105c:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0
 8001060:	4313      	orrs	r3, r2
 8001062:	608b      	str	r3, [r1, #8]
    tickstart = HAL_GetTick();
 8001064:	f7ff fab2 	bl	80005cc <HAL_GetTick>
 8001068:	4606      	mov	r6, r0
  * @rmtoll CFGR         HPREF       LL_RCC_IsActiveFlag_HPRE
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IsActiveFlag_HPRE(void)
{
  return ((READ_BIT(RCC->CFGR, RCC_CFGR_HPREF) == (RCC_CFGR_HPREF)) ? 1UL : 0UL);
 800106a:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800106e:	689b      	ldr	r3, [r3, #8]
 8001070:	f413 3f80 	tst.w	r3, #65536	; 0x10000
 8001074:	d1ae      	bne.n	8000fd4 <HAL_RCC_ClockConfig+0x20>
      if ((HAL_GetTick() - tickstart) > PRESCALER_TIMEOUT_VALUE)
 8001076:	f7ff faa9 	bl	80005cc <HAL_GetTick>
 800107a:	1b80      	subs	r0, r0, r6
 800107c:	2802      	cmp	r0, #2
 800107e:	d9f4      	bls.n	800106a <HAL_RCC_ClockConfig+0xb6>
        return HAL_TIMEOUT;
 8001080:	2003      	movs	r0, #3
 8001082:	e0c0      	b.n	8001206 <HAL_RCC_ClockConfig+0x252>
    LL_C2_RCC_SetAHBPrescaler(RCC_ClkInitStruct->AHBCLK2Divider);
 8001084:	6963      	ldr	r3, [r4, #20]
  MODIFY_REG(RCC->EXTCFGR, RCC_EXTCFGR_C2HPRE, Prescaler);
 8001086:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 800108a:	f8d1 2108 	ldr.w	r2, [r1, #264]	; 0x108
 800108e:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0
 8001092:	4313      	orrs	r3, r2
 8001094:	f8c1 3108 	str.w	r3, [r1, #264]	; 0x108
    tickstart = HAL_GetTick();
 8001098:	f7ff fa98 	bl	80005cc <HAL_GetTick>
 800109c:	4606      	mov	r6, r0
  * @rmtoll EXTCFGR         C2HPREF       LL_RCC_IsActiveFlag_C2HPRE
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IsActiveFlag_C2HPRE(void)
{
  return ((READ_BIT(RCC->EXTCFGR, RCC_EXTCFGR_C2HPREF) == (RCC_EXTCFGR_C2HPREF)) ? 1UL : 0UL);
 800109e:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80010a2:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
 80010a6:	f413 3f00 	tst.w	r3, #131072	; 0x20000
 80010aa:	d197      	bne.n	8000fdc <HAL_RCC_ClockConfig+0x28>
      if ((HAL_GetTick() - tickstart) > PRESCALER_TIMEOUT_VALUE)
 80010ac:	f7ff fa8e 	bl	80005cc <HAL_GetTick>
 80010b0:	1b80      	subs	r0, r0, r6
 80010b2:	2802      	cmp	r0, #2
 80010b4:	d9f3      	bls.n	800109e <HAL_RCC_ClockConfig+0xea>
        return HAL_TIMEOUT;
 80010b6:	2003      	movs	r0, #3
 80010b8:	e0a5      	b.n	8001206 <HAL_RCC_ClockConfig+0x252>
    LL_RCC_SetAHB4Prescaler(RCC_ClkInitStruct->AHBCLK4Divider);
 80010ba:	69a1      	ldr	r1, [r4, #24]
  MODIFY_REG(RCC->EXTCFGR, RCC_EXTCFGR_SHDHPRE, Prescaler >> 4);
 80010bc:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 80010c0:	f8d2 3108 	ldr.w	r3, [r2, #264]	; 0x108
 80010c4:	f023 030f 	bic.w	r3, r3, #15
 80010c8:	ea43 1311 	orr.w	r3, r3, r1, lsr #4
 80010cc:	f8c2 3108 	str.w	r3, [r2, #264]	; 0x108
    tickstart = HAL_GetTick();
 80010d0:	f7ff fa7c 	bl	80005cc <HAL_GetTick>
 80010d4:	4606      	mov	r6, r0
  * @rmtoll EXTCFGR         SHDHPREF       LL_RCC_IsActiveFlag_SHDHPRE
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IsActiveFlag_SHDHPRE(void)
{
  return ((READ_BIT(RCC->EXTCFGR, RCC_EXTCFGR_SHDHPREF) == (RCC_EXTCFGR_SHDHPREF)) ? 1UL : 0UL);
 80010d6:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80010da:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
 80010de:	f413 3f80 	tst.w	r3, #65536	; 0x10000
 80010e2:	f47f af7f 	bne.w	8000fe4 <HAL_RCC_ClockConfig+0x30>
      if ((HAL_GetTick() - tickstart) > PRESCALER_TIMEOUT_VALUE)
 80010e6:	f7ff fa71 	bl	80005cc <HAL_GetTick>
 80010ea:	1b80      	subs	r0, r0, r6
 80010ec:	2802      	cmp	r0, #2
 80010ee:	d9f2      	bls.n	80010d6 <HAL_RCC_ClockConfig+0x122>
        return HAL_TIMEOUT;
 80010f0:	2003      	movs	r0, #3
 80010f2:	e088      	b.n	8001206 <HAL_RCC_ClockConfig+0x252>
    LL_RCC_SetAPB1Prescaler(RCC_ClkInitStruct->APB1CLKDivider);
 80010f4:	68e3      	ldr	r3, [r4, #12]
  MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, Prescaler);
 80010f6:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 80010fa:	688a      	ldr	r2, [r1, #8]
 80010fc:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
 8001100:	4313      	orrs	r3, r2
 8001102:	608b      	str	r3, [r1, #8]
    tickstart = HAL_GetTick();
 8001104:	f7ff fa62 	bl	80005cc <HAL_GetTick>
 8001108:	4606      	mov	r6, r0
  * @rmtoll CFGR         PPRE1F       LL_RCC_IsActiveFlag_PPRE1
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IsActiveFlag_PPRE1(void)
{
  return ((READ_BIT(RCC->CFGR, RCC_CFGR_PPRE1F) == (RCC_CFGR_PPRE1F)) ? 1UL : 0UL);
 800110a:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800110e:	689b      	ldr	r3, [r3, #8]
 8001110:	f413 3f00 	tst.w	r3, #131072	; 0x20000
 8001114:	f47f af6b 	bne.w	8000fee <HAL_RCC_ClockConfig+0x3a>
      if ((HAL_GetTick() - tickstart) > PRESCALER_TIMEOUT_VALUE)
 8001118:	f7ff fa58 	bl	80005cc <HAL_GetTick>
 800111c:	1b80      	subs	r0, r0, r6
 800111e:	2802      	cmp	r0, #2
 8001120:	d9f3      	bls.n	800110a <HAL_RCC_ClockConfig+0x156>
        return HAL_TIMEOUT;
 8001122:	2003      	movs	r0, #3
 8001124:	e06f      	b.n	8001206 <HAL_RCC_ClockConfig+0x252>
    LL_RCC_SetAPB2Prescaler((RCC_ClkInitStruct->APB2CLKDivider) << 3U);
 8001126:	6921      	ldr	r1, [r4, #16]
  MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, Prescaler);
 8001128:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 800112c:	6893      	ldr	r3, [r2, #8]
 800112e:	f423 5360 	bic.w	r3, r3, #14336	; 0x3800
 8001132:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3
 8001136:	6093      	str	r3, [r2, #8]
    tickstart = HAL_GetTick();
 8001138:	f7ff fa48 	bl	80005cc <HAL_GetTick>
 800113c:	4606      	mov	r6, r0
  * @rmtoll CFGR         PPRE2F       LL_RCC_IsActiveFlag_PPRE2
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IsActiveFlag_PPRE2(void)
{
  return ((READ_BIT(RCC->CFGR, RCC_CFGR_PPRE2F) == (RCC_CFGR_PPRE2F)) ? 1UL : 0UL);
 800113e:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8001142:	689b      	ldr	r3, [r3, #8]
 8001144:	f413 2f80 	tst.w	r3, #262144	; 0x40000
 8001148:	f47f af56 	bne.w	8000ff8 <HAL_RCC_ClockConfig+0x44>
      if ((HAL_GetTick() - tickstart) > PRESCALER_TIMEOUT_VALUE)
 800114c:	f7ff fa3e 	bl	80005cc <HAL_GetTick>
 8001150:	1b80      	subs	r0, r0, r6
 8001152:	2802      	cmp	r0, #2
 8001154:	d9f3      	bls.n	800113e <HAL_RCC_ClockConfig+0x18a>
        return HAL_TIMEOUT;
 8001156:	2003      	movs	r0, #3
 8001158:	e055      	b.n	8001206 <HAL_RCC_ClockConfig+0x252>
  return ((READ_BIT(RCC->CR, RCC_CR_HSERDY) == (RCC_CR_HSERDY)) ? 1UL : 0UL);
 800115a:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 800115e:	6812      	ldr	r2, [r2, #0]
 8001160:	f412 3f00 	tst.w	r2, #131072	; 0x20000
 8001164:	d01b      	beq.n	800119e <HAL_RCC_ClockConfig+0x1ea>
  MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, Source);
 8001166:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 800116a:	688a      	ldr	r2, [r1, #8]
 800116c:	f022 0203 	bic.w	r2, r2, #3
 8001170:	4313      	orrs	r3, r2
 8001172:	608b      	str	r3, [r1, #8]
    tickstart = HAL_GetTick();
 8001174:	f7ff fa2a 	bl	80005cc <HAL_GetTick>
 8001178:	4606      	mov	r6, r0
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SWS));
 800117a:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800117e:	689b      	ldr	r3, [r3, #8]
 8001180:	f003 030c 	and.w	r3, r3, #12
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 8001184:	6862      	ldr	r2, [r4, #4]
 8001186:	ebb3 0f82 	cmp.w	r3, r2, lsl #2
 800118a:	d01a      	beq.n	80011c2 <HAL_RCC_ClockConfig+0x20e>
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 800118c:	f7ff fa1e 	bl	80005cc <HAL_GetTick>
 8001190:	1b80      	subs	r0, r0, r6
 8001192:	f241 3388 	movw	r3, #5000	; 0x1388
 8001196:	4298      	cmp	r0, r3
 8001198:	d9ef      	bls.n	800117a <HAL_RCC_ClockConfig+0x1c6>
        return HAL_TIMEOUT;
 800119a:	2003      	movs	r0, #3
 800119c:	e033      	b.n	8001206 <HAL_RCC_ClockConfig+0x252>
        return HAL_ERROR;
 800119e:	2001      	movs	r0, #1
 80011a0:	e031      	b.n	8001206 <HAL_RCC_ClockConfig+0x252>
  return ((READ_BIT(RCC->CR, RCC_CR_PLLRDY) == (RCC_CR_PLLRDY)) ? 1UL : 0UL);
 80011a2:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 80011a6:	6812      	ldr	r2, [r2, #0]
 80011a8:	f012 7f00 	tst.w	r2, #33554432	; 0x2000000
 80011ac:	d1db      	bne.n	8001166 <HAL_RCC_ClockConfig+0x1b2>
        return HAL_ERROR;
 80011ae:	2001      	movs	r0, #1
 80011b0:	e029      	b.n	8001206 <HAL_RCC_ClockConfig+0x252>
  return ((READ_BIT(RCC->CR, RCC_CR_HSIRDY) == (RCC_CR_HSIRDY)) ? 1UL : 0UL);
 80011b2:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 80011b6:	6812      	ldr	r2, [r2, #0]
 80011b8:	f412 6f80 	tst.w	r2, #1024	; 0x400
 80011bc:	d1d3      	bne.n	8001166 <HAL_RCC_ClockConfig+0x1b2>
        return HAL_ERROR;
 80011be:	2001      	movs	r0, #1
 80011c0:	e021      	b.n	8001206 <HAL_RCC_ClockConfig+0x252>
  if (FLatency < __HAL_FLASH_GET_LATENCY())
 80011c2:	4b12      	ldr	r3, [pc, #72]	; (800120c <HAL_RCC_ClockConfig+0x258>)
 80011c4:	681b      	ldr	r3, [r3, #0]
 80011c6:	f003 0307 	and.w	r3, r3, #7
 80011ca:	42ab      	cmp	r3, r5
 80011cc:	d915      	bls.n	80011fa <HAL_RCC_ClockConfig+0x246>
    __HAL_FLASH_SET_LATENCY(FLatency);
 80011ce:	4a0f      	ldr	r2, [pc, #60]	; (800120c <HAL_RCC_ClockConfig+0x258>)
 80011d0:	6813      	ldr	r3, [r2, #0]
 80011d2:	f023 0307 	bic.w	r3, r3, #7
 80011d6:	432b      	orrs	r3, r5
 80011d8:	6013      	str	r3, [r2, #0]
    tickstart = HAL_GetTick();
 80011da:	f7ff f9f7 	bl	80005cc <HAL_GetTick>
 80011de:	4604      	mov	r4, r0
    while (__HAL_FLASH_GET_LATENCY() != FLatency)
 80011e0:	4b0a      	ldr	r3, [pc, #40]	; (800120c <HAL_RCC_ClockConfig+0x258>)
 80011e2:	681b      	ldr	r3, [r3, #0]
 80011e4:	f003 0307 	and.w	r3, r3, #7
 80011e8:	42ab      	cmp	r3, r5
 80011ea:	d006      	beq.n	80011fa <HAL_RCC_ClockConfig+0x246>
      if ((HAL_GetTick() - tickstart) > LATENCY_TIMEOUT_VALUE)
 80011ec:	f7ff f9ee 	bl	80005cc <HAL_GetTick>
 80011f0:	1b00      	subs	r0, r0, r4
 80011f2:	2802      	cmp	r0, #2
 80011f4:	d9f4      	bls.n	80011e0 <HAL_RCC_ClockConfig+0x22c>
        return HAL_TIMEOUT;
 80011f6:	2003      	movs	r0, #3
 80011f8:	e005      	b.n	8001206 <HAL_RCC_ClockConfig+0x252>
  SystemCoreClockUpdate();
 80011fa:	f7ff f917 	bl	800042c <SystemCoreClockUpdate>
  return HAL_InitTick(HAL_GetTickPrio());
 80011fe:	f7ff f9eb 	bl	80005d8 <HAL_GetTickPrio>
 8001202:	f7ff f887 	bl	8000314 <HAL_InitTick>
}
 8001206:	bd70      	pop	{r4, r5, r6, pc}
    return HAL_ERROR;
 8001208:	2001      	movs	r0, #1
}
 800120a:	4770      	bx	lr
 800120c:	58004000 	.word	0x58004000

08001210 <HAL_RCC_GetSysClockFreq>:
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SWS));
 8001210:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8001214:	689b      	ldr	r3, [r3, #8]
  if (temp_sysclksrc == RCC_SYSCLKSOURCE_STATUS_MSI)
 8001216:	f013 030c 	ands.w	r3, r3, #12
 800121a:	d10c      	bne.n	8001236 <HAL_RCC_GetSysClockFreq+0x26>
  uint32_t msiRange = READ_BIT(RCC->CR, RCC_CR_MSIRANGE);
 800121c:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8001220:	681b      	ldr	r3, [r3, #0]
 8001222:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
  if (msiRange > LL_RCC_MSIRANGE_11)
 8001226:	2bb0      	cmp	r3, #176	; 0xb0
 8001228:	d900      	bls.n	800122c <HAL_RCC_GetSysClockFreq+0x1c>
    msiRange = LL_RCC_MSIRANGE_11;
 800122a:	23b0      	movs	r3, #176	; 0xb0
    sysclockfreq = __LL_RCC_CALC_MSI_FREQ(LL_RCC_MSI_GetRange());
 800122c:	091b      	lsrs	r3, r3, #4
 800122e:	4a24      	ldr	r2, [pc, #144]	; (80012c0 <HAL_RCC_GetSysClockFreq+0xb0>)
 8001230:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
 8001234:	4770      	bx	lr
  else if (temp_sysclksrc == RCC_SYSCLKSOURCE_STATUS_HSI)
 8001236:	2b04      	cmp	r3, #4
 8001238:	d03d      	beq.n	80012b6 <HAL_RCC_GetSysClockFreq+0xa6>
  else if (temp_sysclksrc == RCC_SYSCLKSOURCE_STATUS_HSE)
 800123a:	2b08      	cmp	r3, #8
 800123c:	d010      	beq.n	8001260 <HAL_RCC_GetSysClockFreq+0x50>
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC));
 800123e:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8001242:	68db      	ldr	r3, [r3, #12]
 8001244:	f003 0303 	and.w	r3, r3, #3
    switch (pllsource)
 8001248:	2b02      	cmp	r3, #2
 800124a:	d030      	beq.n	80012ae <HAL_RCC_GetSysClockFreq+0x9e>
 800124c:	2b03      	cmp	r3, #3
 800124e:	d10f      	bne.n	8001270 <HAL_RCC_GetSysClockFreq+0x60>
  return ((READ_BIT(RCC->CR, RCC_CR_HSEPRE) == (RCC_CR_HSEPRE)) ? 1UL : 0UL);
 8001250:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8001254:	681b      	ldr	r3, [r3, #0]
 8001256:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
 800125a:	d12a      	bne.n	80012b2 <HAL_RCC_GetSysClockFreq+0xa2>
          pllinputfreq = HSE_VALUE;
 800125c:	4b19      	ldr	r3, [pc, #100]	; (80012c4 <HAL_RCC_GetSysClockFreq+0xb4>)
 800125e:	e013      	b.n	8001288 <HAL_RCC_GetSysClockFreq+0x78>
 8001260:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8001264:	681b      	ldr	r3, [r3, #0]
 8001266:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
 800126a:	d026      	beq.n	80012ba <HAL_RCC_GetSysClockFreq+0xaa>
      sysclockfreq = HSE_VALUE / 2U;
 800126c:	4816      	ldr	r0, [pc, #88]	; (80012c8 <HAL_RCC_GetSysClockFreq+0xb8>)
 800126e:	4770      	bx	lr
  uint32_t msiRange = READ_BIT(RCC->CR, RCC_CR_MSIRANGE);
 8001270:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8001274:	681b      	ldr	r3, [r3, #0]
 8001276:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
  if (msiRange > LL_RCC_MSIRANGE_11)
 800127a:	2bb0      	cmp	r3, #176	; 0xb0
 800127c:	d900      	bls.n	8001280 <HAL_RCC_GetSysClockFreq+0x70>
    msiRange = LL_RCC_MSIRANGE_11;
 800127e:	23b0      	movs	r3, #176	; 0xb0
        pllinputfreq = __LL_RCC_CALC_MSI_FREQ(LL_RCC_MSI_GetRange());
 8001280:	091b      	lsrs	r3, r3, #4
 8001282:	4a0f      	ldr	r2, [pc, #60]	; (80012c0 <HAL_RCC_GetSysClockFreq+0xb0>)
 8001284:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >>  RCC_PLLCFGR_PLLN_Pos);
 8001288:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 800128c:	68d0      	ldr	r0, [r2, #12]
 800128e:	f3c0 2006 	ubfx	r0, r0, #8, #7
    sysclockfreq = __LL_RCC_CALC_PLLCLK_FREQ(pllinputfreq, LL_RCC_PLL_GetDivider(), LL_RCC_PLL_GetN(), LL_RCC_PLL_GetR());
 8001292:	fb00 f003 	mul.w	r0, r0, r3
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM));
 8001296:	68d3      	ldr	r3, [r2, #12]
 8001298:	f3c3 1302 	ubfx	r3, r3, #4, #3
 800129c:	3301      	adds	r3, #1
 800129e:	fbb0 f0f3 	udiv	r0, r0, r3
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLR));
 80012a2:	68d3      	ldr	r3, [r2, #12]
 80012a4:	0f5b      	lsrs	r3, r3, #29
 80012a6:	3301      	adds	r3, #1
 80012a8:	fbb0 f0f3 	udiv	r0, r0, r3
 80012ac:	4770      	bx	lr
        pllinputfreq = HSI_VALUE;
 80012ae:	4b06      	ldr	r3, [pc, #24]	; (80012c8 <HAL_RCC_GetSysClockFreq+0xb8>)
 80012b0:	e7ea      	b.n	8001288 <HAL_RCC_GetSysClockFreq+0x78>
          pllinputfreq = HSE_VALUE / 2U;
 80012b2:	4b05      	ldr	r3, [pc, #20]	; (80012c8 <HAL_RCC_GetSysClockFreq+0xb8>)
 80012b4:	e7e8      	b.n	8001288 <HAL_RCC_GetSysClockFreq+0x78>
    sysclockfreq = HSI_VALUE;
 80012b6:	4804      	ldr	r0, [pc, #16]	; (80012c8 <HAL_RCC_GetSysClockFreq+0xb8>)
 80012b8:	4770      	bx	lr
      sysclockfreq = HSE_VALUE;
 80012ba:	4802      	ldr	r0, [pc, #8]	; (80012c4 <HAL_RCC_GetSysClockFreq+0xb4>)
}
 80012bc:	4770      	bx	lr
 80012be:	bf00      	nop
 80012c0:	08002844 	.word	0x08002844
 80012c4:	01e84800 	.word	0x01e84800
 80012c8:	00f42400 	.word	0x00f42400

080012cc <HAL_RCC_GetHCLKFreq>:
{
 80012cc:	b508      	push	{r3, lr}
  return ((uint32_t)(__LL_RCC_CALC_HCLK1_FREQ(HAL_RCC_GetSysClockFreq(), LL_RCC_GetAHBPrescaler())));
 80012ce:	f7ff ff9f 	bl	8001210 <HAL_RCC_GetSysClockFreq>
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_HPRE));
 80012d2:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80012d6:	689b      	ldr	r3, [r3, #8]
 80012d8:	f3c3 1303 	ubfx	r3, r3, #4, #4
 80012dc:	4a02      	ldr	r2, [pc, #8]	; (80012e8 <HAL_RCC_GetHCLKFreq+0x1c>)
 80012de:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
}
 80012e2:	fbb0 f0f3 	udiv	r0, r0, r3
 80012e6:	bd08      	pop	{r3, pc}
 80012e8:	080027e4 	.word	0x080027e4

080012ec <HAL_RCC_GetPCLK2Freq>:
{
 80012ec:	b508      	push	{r3, lr}
  return ((uint32_t)(__LL_RCC_CALC_PCLK2_FREQ(HAL_RCC_GetHCLKFreq(), LL_RCC_GetAPB2Prescaler())));
 80012ee:	f7ff ffed 	bl	80012cc <HAL_RCC_GetHCLKFreq>
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_PPRE2));
 80012f2:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80012f6:	689b      	ldr	r3, [r3, #8]
 80012f8:	f3c3 23c2 	ubfx	r3, r3, #11, #3
 80012fc:	4a03      	ldr	r2, [pc, #12]	; (800130c <HAL_RCC_GetPCLK2Freq+0x20>)
 80012fe:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8001302:	f003 031f 	and.w	r3, r3, #31
}
 8001306:	40d8      	lsrs	r0, r3
 8001308:	bd08      	pop	{r3, pc}
 800130a:	bf00      	nop
 800130c:	08002824 	.word	0x08002824

08001310 <HAL_RCC_GetClockConfig>:
  RCC_ClkInitStruct->ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2 |  \
 8001310:	236f      	movs	r3, #111	; 0x6f
 8001312:	6003      	str	r3, [r0, #0]
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SWS));
 8001314:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8001318:	689a      	ldr	r2, [r3, #8]
 800131a:	f002 020c 	and.w	r2, r2, #12
  RCC_ClkInitStruct->SYSCLKSource = LL_RCC_GetSysClkSource();
 800131e:	6042      	str	r2, [r0, #4]
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_HPRE));
 8001320:	689a      	ldr	r2, [r3, #8]
 8001322:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
  RCC_ClkInitStruct->AHBCLKDivider = LL_RCC_GetAHBPrescaler();
 8001326:	6082      	str	r2, [r0, #8]
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_PPRE1));
 8001328:	689a      	ldr	r2, [r3, #8]
 800132a:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
  RCC_ClkInitStruct->APB1CLKDivider = LL_RCC_GetAPB1Prescaler();
 800132e:	60c2      	str	r2, [r0, #12]
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_PPRE2));
 8001330:	689a      	ldr	r2, [r3, #8]
 8001332:	f402 5260 	and.w	r2, r2, #14336	; 0x3800
  RCC_ClkInitStruct->APB2CLKDivider = LL_RCC_GetAPB2Prescaler();
 8001336:	6102      	str	r2, [r0, #16]
  return (uint32_t)(READ_BIT(RCC->EXTCFGR, RCC_EXTCFGR_C2HPRE));
 8001338:	f8d3 2108 	ldr.w	r2, [r3, #264]	; 0x108
 800133c:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
  RCC_ClkInitStruct->AHBCLK2Divider = LL_C2_RCC_GetAHBPrescaler();
 8001340:	6142      	str	r2, [r0, #20]
  return (uint32_t)(READ_BIT(RCC->EXTCFGR, RCC_EXTCFGR_SHDHPRE) << 4);
 8001342:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
 8001346:	011b      	lsls	r3, r3, #4
 8001348:	b2db      	uxtb	r3, r3
  RCC_ClkInitStruct->AHBCLK4Divider = LL_RCC_GetAHB4Prescaler();
 800134a:	6183      	str	r3, [r0, #24]
  *pFLatency = __HAL_FLASH_GET_LATENCY();
 800134c:	4b02      	ldr	r3, [pc, #8]	; (8001358 <HAL_RCC_GetClockConfig+0x48>)
 800134e:	681b      	ldr	r3, [r3, #0]
 8001350:	f003 0307 	and.w	r3, r3, #7
 8001354:	600b      	str	r3, [r1, #0]
}
 8001356:	4770      	bx	lr
 8001358:	58004000 	.word	0x58004000

0800135c <RCCEx_PLLSAI1_ConfigNP>:
  * @note   PLLSAI1 is temporary disable to apply new parameters
  *
  * @retval HAL status
  */
static HAL_StatusTypeDef RCCEx_PLLSAI1_ConfigNP(RCC_PLLSAI1InitTypeDef *PLLSAI1)
{
 800135c:	b570      	push	{r4, r5, r6, lr}
 800135e:	4605      	mov	r5, r0
  CLEAR_BIT(RCC->CR, RCC_CR_PLLSAI1ON);
 8001360:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 8001364:	6813      	ldr	r3, [r2, #0]
 8001366:	f023 6380 	bic.w	r3, r3, #67108864	; 0x4000000
 800136a:	6013      	str	r3, [r2, #0]

  /* Disable the PLLSAI1 */
  __HAL_RCC_PLLSAI1_DISABLE();

  /* Get Start Tick*/
  tickstart = HAL_GetTick();
 800136c:	f7ff f92e 	bl	80005cc <HAL_GetTick>
 8001370:	4604      	mov	r4, r0
  return ((READ_BIT(RCC->CR, RCC_CR_PLLSAI1RDY) == (RCC_CR_PLLSAI1RDY)) ? 1UL : 0UL);
 8001372:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8001376:	681b      	ldr	r3, [r3, #0]
 8001378:	f013 6f00 	tst.w	r3, #134217728	; 0x8000000
 800137c:	d006      	beq.n	800138c <RCCEx_PLLSAI1_ConfigNP+0x30>

  /* Wait till PLLSAI1 is ready to be updated */
  while (LL_RCC_PLLSAI1_IsReady() != 0U)
  {
    if ((HAL_GetTick() - tickstart) > PLLSAI1_TIMEOUT_VALUE)
 800137e:	f7ff f925 	bl	80005cc <HAL_GetTick>
 8001382:	1b00      	subs	r0, r0, r4
 8001384:	2802      	cmp	r0, #2
 8001386:	d9f4      	bls.n	8001372 <RCCEx_PLLSAI1_ConfigNP+0x16>
    {
      status = HAL_TIMEOUT;
 8001388:	2403      	movs	r4, #3
 800138a:	e000      	b.n	800138e <RCCEx_PLLSAI1_ConfigNP+0x32>
  HAL_StatusTypeDef status = HAL_OK;
 800138c:	2400      	movs	r4, #0
      break;
    }
  }

  if (status == HAL_OK)
 800138e:	b10c      	cbz	r4, 8001394 <RCCEx_PLLSAI1_ConfigNP+0x38>
      __HAL_RCC_PLLSAI1CLKOUT_ENABLE(PLLSAI1->PLLSAI1ClockOut);
    }
  }

  return status;
}
 8001390:	4620      	mov	r0, r4
 8001392:	bd70      	pop	{r4, r5, r6, pc}
    __HAL_RCC_PLLSAI1_MULN_CONFIG(PLLSAI1->PLLN);
 8001394:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8001398:	691a      	ldr	r2, [r3, #16]
 800139a:	f422 42fe 	bic.w	r2, r2, #32512	; 0x7f00
 800139e:	6829      	ldr	r1, [r5, #0]
 80013a0:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 80013a4:	611a      	str	r2, [r3, #16]
    __HAL_RCC_PLLSAI1_DIVP_CONFIG(PLLSAI1->PLLP);
 80013a6:	691a      	ldr	r2, [r3, #16]
 80013a8:	f422 1278 	bic.w	r2, r2, #4063232	; 0x3e0000
 80013ac:	6869      	ldr	r1, [r5, #4]
 80013ae:	430a      	orrs	r2, r1
 80013b0:	611a      	str	r2, [r3, #16]
  SET_BIT(RCC->CR, RCC_CR_PLLSAI1ON);
 80013b2:	681a      	ldr	r2, [r3, #0]
 80013b4:	f042 6280 	orr.w	r2, r2, #67108864	; 0x4000000
 80013b8:	601a      	str	r2, [r3, #0]
    tickstart = HAL_GetTick();
 80013ba:	f7ff f907 	bl	80005cc <HAL_GetTick>
 80013be:	4606      	mov	r6, r0
  return ((READ_BIT(RCC->CR, RCC_CR_PLLSAI1RDY) == (RCC_CR_PLLSAI1RDY)) ? 1UL : 0UL);
 80013c0:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80013c4:	681b      	ldr	r3, [r3, #0]
 80013c6:	f013 6f00 	tst.w	r3, #134217728	; 0x8000000
 80013ca:	d105      	bne.n	80013d8 <RCCEx_PLLSAI1_ConfigNP+0x7c>
      if ((HAL_GetTick() - tickstart) > PLLSAI1_TIMEOUT_VALUE)
 80013cc:	f7ff f8fe 	bl	80005cc <HAL_GetTick>
 80013d0:	1b80      	subs	r0, r0, r6
 80013d2:	2802      	cmp	r0, #2
 80013d4:	d9f4      	bls.n	80013c0 <RCCEx_PLLSAI1_ConfigNP+0x64>
        status = HAL_TIMEOUT;
 80013d6:	2403      	movs	r4, #3
    if (status == HAL_OK)
 80013d8:	2c00      	cmp	r4, #0
 80013da:	d1d9      	bne.n	8001390 <RCCEx_PLLSAI1_ConfigNP+0x34>
      __HAL_RCC_PLLSAI1CLKOUT_ENABLE(PLLSAI1->PLLSAI1ClockOut);
 80013dc:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 80013e0:	6913      	ldr	r3, [r2, #16]
 80013e2:	6929      	ldr	r1, [r5, #16]
 80013e4:	430b      	orrs	r3, r1
 80013e6:	6113      	str	r3, [r2, #16]
 80013e8:	e7d2      	b.n	8001390 <RCCEx_PLLSAI1_ConfigNP+0x34>

080013ea <RCCEx_PLLSAI1_ConfigNQ>:
  * @note   PLLSAI1 is temporary disable to apply new parameters
  *
  * @retval HAL status
  */
static HAL_StatusTypeDef RCCEx_PLLSAI1_ConfigNQ(RCC_PLLSAI1InitTypeDef *PLLSAI1)
{
 80013ea:	b570      	push	{r4, r5, r6, lr}
 80013ec:	4605      	mov	r5, r0
  CLEAR_BIT(RCC->CR, RCC_CR_PLLSAI1ON);
 80013ee:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 80013f2:	6813      	ldr	r3, [r2, #0]
 80013f4:	f023 6380 	bic.w	r3, r3, #67108864	; 0x4000000
 80013f8:	6013      	str	r3, [r2, #0]

  /* Disable the PLLSAI1 */
  __HAL_RCC_PLLSAI1_DISABLE();

  /* Get Start Tick*/
  tickstart = HAL_GetTick();
 80013fa:	f7ff f8e7 	bl	80005cc <HAL_GetTick>
 80013fe:	4604      	mov	r4, r0
  return ((READ_BIT(RCC->CR, RCC_CR_PLLSAI1RDY) == (RCC_CR_PLLSAI1RDY)) ? 1UL : 0UL);
 8001400:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8001404:	681b      	ldr	r3, [r3, #0]
 8001406:	f013 6f00 	tst.w	r3, #134217728	; 0x8000000
 800140a:	d006      	beq.n	800141a <RCCEx_PLLSAI1_ConfigNQ+0x30>

  /* Wait till PLLSAI1 is ready to be updated */
  while (LL_RCC_PLLSAI1_IsReady() != 0U)
  {
    if ((HAL_GetTick() - tickstart) > PLLSAI1_TIMEOUT_VALUE)
 800140c:	f7ff f8de 	bl	80005cc <HAL_GetTick>
 8001410:	1b00      	subs	r0, r0, r4
 8001412:	2802      	cmp	r0, #2
 8001414:	d9f4      	bls.n	8001400 <RCCEx_PLLSAI1_ConfigNQ+0x16>
    {
      status = HAL_TIMEOUT;
 8001416:	2403      	movs	r4, #3
 8001418:	e000      	b.n	800141c <RCCEx_PLLSAI1_ConfigNQ+0x32>
  HAL_StatusTypeDef status = HAL_OK;
 800141a:	2400      	movs	r4, #0
      break;
    }
  }

  if (status == HAL_OK)
 800141c:	b10c      	cbz	r4, 8001422 <RCCEx_PLLSAI1_ConfigNQ+0x38>
      __HAL_RCC_PLLSAI1CLKOUT_ENABLE(PLLSAI1->PLLSAI1ClockOut);
    }
  }

  return status;
}
 800141e:	4620      	mov	r0, r4
 8001420:	bd70      	pop	{r4, r5, r6, pc}
    __HAL_RCC_PLLSAI1_MULN_CONFIG(PLLSAI1->PLLN);
 8001422:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8001426:	691a      	ldr	r2, [r3, #16]
 8001428:	f422 42fe 	bic.w	r2, r2, #32512	; 0x7f00
 800142c:	6829      	ldr	r1, [r5, #0]
 800142e:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 8001432:	611a      	str	r2, [r3, #16]
    __HAL_RCC_PLLSAI1_DIVQ_CONFIG(PLLSAI1->PLLQ);
 8001434:	691a      	ldr	r2, [r3, #16]
 8001436:	f022 6260 	bic.w	r2, r2, #234881024	; 0xe000000
 800143a:	68a9      	ldr	r1, [r5, #8]
 800143c:	430a      	orrs	r2, r1
 800143e:	611a      	str	r2, [r3, #16]
  SET_BIT(RCC->CR, RCC_CR_PLLSAI1ON);
 8001440:	681a      	ldr	r2, [r3, #0]
 8001442:	f042 6280 	orr.w	r2, r2, #67108864	; 0x4000000
 8001446:	601a      	str	r2, [r3, #0]
    tickstart = HAL_GetTick();
 8001448:	f7ff f8c0 	bl	80005cc <HAL_GetTick>
 800144c:	4606      	mov	r6, r0
  return ((READ_BIT(RCC->CR, RCC_CR_PLLSAI1RDY) == (RCC_CR_PLLSAI1RDY)) ? 1UL : 0UL);
 800144e:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8001452:	681b      	ldr	r3, [r3, #0]
 8001454:	f013 6f00 	tst.w	r3, #134217728	; 0x8000000
 8001458:	d105      	bne.n	8001466 <RCCEx_PLLSAI1_ConfigNQ+0x7c>
      if ((HAL_GetTick() - tickstart) > PLLSAI1_TIMEOUT_VALUE)
 800145a:	f7ff f8b7 	bl	80005cc <HAL_GetTick>
 800145e:	1b80      	subs	r0, r0, r6
 8001460:	2802      	cmp	r0, #2
 8001462:	d9f4      	bls.n	800144e <RCCEx_PLLSAI1_ConfigNQ+0x64>
        status = HAL_TIMEOUT;
 8001464:	2403      	movs	r4, #3
    if (status == HAL_OK)
 8001466:	2c00      	cmp	r4, #0
 8001468:	d1d9      	bne.n	800141e <RCCEx_PLLSAI1_ConfigNQ+0x34>
      __HAL_RCC_PLLSAI1CLKOUT_ENABLE(PLLSAI1->PLLSAI1ClockOut);
 800146a:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 800146e:	6913      	ldr	r3, [r2, #16]
 8001470:	6929      	ldr	r1, [r5, #16]
 8001472:	430b      	orrs	r3, r1
 8001474:	6113      	str	r3, [r2, #16]
 8001476:	e7d2      	b.n	800141e <RCCEx_PLLSAI1_ConfigNQ+0x34>

08001478 <RCCEx_PLLSAI1_ConfigNR>:
  * @note   PLLSAI1 is temporary disable to apply new parameters
  *
  * @retval HAL status
  */
static HAL_StatusTypeDef RCCEx_PLLSAI1_ConfigNR(RCC_PLLSAI1InitTypeDef *PLLSAI1)
{
 8001478:	b570      	push	{r4, r5, r6, lr}
 800147a:	4605      	mov	r5, r0
  CLEAR_BIT(RCC->CR, RCC_CR_PLLSAI1ON);
 800147c:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 8001480:	6813      	ldr	r3, [r2, #0]
 8001482:	f023 6380 	bic.w	r3, r3, #67108864	; 0x4000000
 8001486:	6013      	str	r3, [r2, #0]

  /* Disable the PLLSAI1 */
  __HAL_RCC_PLLSAI1_DISABLE();

  /* Get Start Tick*/
  tickstart = HAL_GetTick();
 8001488:	f7ff f8a0 	bl	80005cc <HAL_GetTick>
 800148c:	4604      	mov	r4, r0
  return ((READ_BIT(RCC->CR, RCC_CR_PLLSAI1RDY) == (RCC_CR_PLLSAI1RDY)) ? 1UL : 0UL);
 800148e:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8001492:	681b      	ldr	r3, [r3, #0]
 8001494:	f013 6f00 	tst.w	r3, #134217728	; 0x8000000
 8001498:	d006      	beq.n	80014a8 <RCCEx_PLLSAI1_ConfigNR+0x30>

  /* Wait till PLLSAI1 is ready to be updated */
  while (LL_RCC_PLLSAI1_IsReady() != 0U)
  {
    if ((HAL_GetTick() - tickstart) > PLLSAI1_TIMEOUT_VALUE)
 800149a:	f7ff f897 	bl	80005cc <HAL_GetTick>
 800149e:	1b00      	subs	r0, r0, r4
 80014a0:	2802      	cmp	r0, #2
 80014a2:	d9f4      	bls.n	800148e <RCCEx_PLLSAI1_ConfigNR+0x16>
    {
      status = HAL_TIMEOUT;
 80014a4:	2403      	movs	r4, #3
 80014a6:	e000      	b.n	80014aa <RCCEx_PLLSAI1_ConfigNR+0x32>
  HAL_StatusTypeDef status = HAL_OK;
 80014a8:	2400      	movs	r4, #0
      break;
    }
  }

  if (status == HAL_OK)
 80014aa:	b10c      	cbz	r4, 80014b0 <RCCEx_PLLSAI1_ConfigNR+0x38>
      __HAL_RCC_PLLSAI1CLKOUT_ENABLE(PLLSAI1->PLLSAI1ClockOut);
    }
  }

  return status;
}
 80014ac:	4620      	mov	r0, r4
 80014ae:	bd70      	pop	{r4, r5, r6, pc}
    __HAL_RCC_PLLSAI1_MULN_CONFIG(PLLSAI1->PLLN);
 80014b0:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80014b4:	691a      	ldr	r2, [r3, #16]
 80014b6:	f422 42fe 	bic.w	r2, r2, #32512	; 0x7f00
 80014ba:	6829      	ldr	r1, [r5, #0]
 80014bc:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 80014c0:	611a      	str	r2, [r3, #16]
    __HAL_RCC_PLLSAI1_DIVR_CONFIG(PLLSAI1->PLLR);
 80014c2:	691a      	ldr	r2, [r3, #16]
 80014c4:	f022 4260 	bic.w	r2, r2, #3758096384	; 0xe0000000
 80014c8:	68e9      	ldr	r1, [r5, #12]
 80014ca:	430a      	orrs	r2, r1
 80014cc:	611a      	str	r2, [r3, #16]
  SET_BIT(RCC->CR, RCC_CR_PLLSAI1ON);
 80014ce:	681a      	ldr	r2, [r3, #0]
 80014d0:	f042 6280 	orr.w	r2, r2, #67108864	; 0x4000000
 80014d4:	601a      	str	r2, [r3, #0]
    tickstart = HAL_GetTick();
 80014d6:	f7ff f879 	bl	80005cc <HAL_GetTick>
 80014da:	4606      	mov	r6, r0
  return ((READ_BIT(RCC->CR, RCC_CR_PLLSAI1RDY) == (RCC_CR_PLLSAI1RDY)) ? 1UL : 0UL);
 80014dc:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80014e0:	681b      	ldr	r3, [r3, #0]
 80014e2:	f013 6f00 	tst.w	r3, #134217728	; 0x8000000
 80014e6:	d105      	bne.n	80014f4 <RCCEx_PLLSAI1_ConfigNR+0x7c>
      if ((HAL_GetTick() - tickstart) > PLLSAI1_TIMEOUT_VALUE)
 80014e8:	f7ff f870 	bl	80005cc <HAL_GetTick>
 80014ec:	1b80      	subs	r0, r0, r6
 80014ee:	2802      	cmp	r0, #2
 80014f0:	d9f4      	bls.n	80014dc <RCCEx_PLLSAI1_ConfigNR+0x64>
        status = HAL_TIMEOUT;
 80014f2:	2403      	movs	r4, #3
    if (status == HAL_OK)
 80014f4:	2c00      	cmp	r4, #0
 80014f6:	d1d9      	bne.n	80014ac <RCCEx_PLLSAI1_ConfigNR+0x34>
      __HAL_RCC_PLLSAI1CLKOUT_ENABLE(PLLSAI1->PLLSAI1ClockOut);
 80014f8:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 80014fc:	6913      	ldr	r3, [r2, #16]
 80014fe:	6929      	ldr	r1, [r5, #16]
 8001500:	430b      	orrs	r3, r1
 8001502:	6113      	str	r3, [r2, #16]
 8001504:	e7d2      	b.n	80014ac <RCCEx_PLLSAI1_ConfigNR+0x34>

08001506 <HAL_RCCEx_PeriphCLKConfig>:
{
 8001506:	b570      	push	{r4, r5, r6, lr}
 8001508:	4604      	mov	r4, r0
  if ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1))
 800150a:	6803      	ldr	r3, [r0, #0]
 800150c:	f013 0f40 	tst.w	r3, #64	; 0x40
 8001510:	d02a      	beq.n	8001568 <HAL_RCCEx_PeriphCLKConfig+0x62>
    switch (PeriphClkInit->Sai1ClockSelection)
 8001512:	6b03      	ldr	r3, [r0, #48]	; 0x30
 8001514:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
 8001518:	d011      	beq.n	800153e <HAL_RCCEx_PeriphCLKConfig+0x38>
 800151a:	d807      	bhi.n	800152c <HAL_RCCEx_PeriphCLKConfig+0x26>
 800151c:	b963      	cbnz	r3, 8001538 <HAL_RCCEx_PeriphCLKConfig+0x32>
        ret = RCCEx_PLLSAI1_ConfigNP(&(PeriphClkInit->PLLSAI1));
 800151e:	3004      	adds	r0, #4
 8001520:	f7ff ff1c 	bl	800135c <RCCEx_PLLSAI1_ConfigNP>
    if (ret == HAL_OK)
 8001524:	4606      	mov	r6, r0
 8001526:	b188      	cbz	r0, 800154c <HAL_RCCEx_PeriphCLKConfig+0x46>
        ret = RCCEx_PLLSAI1_ConfigNP(&(PeriphClkInit->PLLSAI1));
 8001528:	4605      	mov	r5, r0
 800152a:	e01f      	b.n	800156c <HAL_RCCEx_PeriphCLKConfig+0x66>
    switch (PeriphClkInit->Sai1ClockSelection)
 800152c:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
 8001530:	d018      	beq.n	8001564 <HAL_RCCEx_PeriphCLKConfig+0x5e>
 8001532:	f5b3 0f40 	cmp.w	r3, #12582912	; 0xc00000
 8001536:	d015      	beq.n	8001564 <HAL_RCCEx_PeriphCLKConfig+0x5e>
        ret = HAL_ERROR;
 8001538:	2501      	movs	r5, #1
 800153a:	462e      	mov	r6, r5
 800153c:	e016      	b.n	800156c <HAL_RCCEx_PeriphCLKConfig+0x66>
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SAI1CLK);
 800153e:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 8001542:	68d3      	ldr	r3, [r2, #12]
 8001544:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8001548:	60d3      	str	r3, [r2, #12]
  HAL_StatusTypeDef ret     = HAL_OK;      /* Intermediate status */
 800154a:	2600      	movs	r6, #0
      __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
 800154c:	6b23      	ldr	r3, [r4, #48]	; 0x30
  MODIFY_REG(RCC->CCIPR, RCC_CCIPR_SAI1SEL, SAIxSource);
 800154e:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 8001552:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 8001556:	f422 0240 	bic.w	r2, r2, #12582912	; 0xc00000
 800155a:	4313      	orrs	r3, r2
 800155c:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
  HAL_StatusTypeDef status  = HAL_OK;   /* Final status */
 8001560:	2500      	movs	r5, #0
 8001562:	e003      	b.n	800156c <HAL_RCCEx_PeriphCLKConfig+0x66>
  HAL_StatusTypeDef ret     = HAL_OK;      /* Intermediate status */
 8001564:	2600      	movs	r6, #0
 8001566:	e7f1      	b.n	800154c <HAL_RCCEx_PeriphCLKConfig+0x46>
  HAL_StatusTypeDef status  = HAL_OK;   /* Final status */
 8001568:	2500      	movs	r5, #0
  HAL_StatusTypeDef ret     = HAL_OK;      /* Intermediate status */
 800156a:	462e      	mov	r6, r5
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
 800156c:	6823      	ldr	r3, [r4, #0]
 800156e:	f413 6f00 	tst.w	r3, #2048	; 0x800
 8001572:	d00a      	beq.n	800158a <HAL_RCCEx_PeriphCLKConfig+0x84>
  return (uint32_t)(READ_BIT(RCC->BDCR, RCC_BDCR_RTCSEL));
 8001574:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8001578:	f8d3 5090 	ldr.w	r5, [r3, #144]	; 0x90
 800157c:	f405 7540 	and.w	r5, r5, #768	; 0x300
    if (rtcclocksource != PeriphClkInit->RTCClockSelection)
 8001580:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8001582:	42ab      	cmp	r3, r5
 8001584:	f040 80d5 	bne.w	8001732 <HAL_RCCEx_PeriphCLKConfig+0x22c>
      status = ret;
 8001588:	4635      	mov	r5, r6
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)
 800158a:	6823      	ldr	r3, [r4, #0]
 800158c:	f013 0f01 	tst.w	r3, #1
 8001590:	d009      	beq.n	80015a6 <HAL_RCCEx_PeriphCLKConfig+0xa0>
    __HAL_RCC_USART1_CONFIG(PeriphClkInit->Usart1ClockSelection);
 8001592:	69a3      	ldr	r3, [r4, #24]
  MODIFY_REG(RCC->CCIPR, RCC_CCIPR_USART1SEL, USARTxSource);
 8001594:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 8001598:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 800159c:	f022 0203 	bic.w	r2, r2, #3
 80015a0:	4313      	orrs	r3, r2
 80015a2:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPUART1) == RCC_PERIPHCLK_LPUART1)
 80015a6:	6823      	ldr	r3, [r4, #0]
 80015a8:	f013 0f02 	tst.w	r3, #2
 80015ac:	d009      	beq.n	80015c2 <HAL_RCCEx_PeriphCLKConfig+0xbc>
    __HAL_RCC_LPUART1_CONFIG(PeriphClkInit->Lpuart1ClockSelection);
 80015ae:	69e3      	ldr	r3, [r4, #28]
  MODIFY_REG(RCC->CCIPR, RCC_CCIPR_LPUART1SEL, LPUARTxSource);
 80015b0:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 80015b4:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 80015b8:	f422 6240 	bic.w	r2, r2, #3072	; 0xc00
 80015bc:	4313      	orrs	r3, r2
 80015be:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM1) == (RCC_PERIPHCLK_LPTIM1))
 80015c2:	6823      	ldr	r3, [r4, #0]
 80015c4:	f013 0f10 	tst.w	r3, #16
 80015c8:	d00c      	beq.n	80015e4 <HAL_RCCEx_PeriphCLKConfig+0xde>
    __HAL_RCC_LPTIM1_CONFIG(PeriphClkInit->Lptim1ClockSelection);
 80015ca:	6aa0      	ldr	r0, [r4, #40]	; 0x28
  MODIFY_REG(RCC->CCIPR, (LPTIMxSource & 0xFFFF0000U), (LPTIMxSource << 16));
 80015cc:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 80015d0:	f8d1 3088 	ldr.w	r3, [r1, #136]	; 0x88
 80015d4:	0c02      	lsrs	r2, r0, #16
 80015d6:	0412      	lsls	r2, r2, #16
 80015d8:	ea23 0302 	bic.w	r3, r3, r2
 80015dc:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
 80015e0:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM2) == (RCC_PERIPHCLK_LPTIM2))
 80015e4:	6823      	ldr	r3, [r4, #0]
 80015e6:	f013 0f20 	tst.w	r3, #32
 80015ea:	d00c      	beq.n	8001606 <HAL_RCCEx_PeriphCLKConfig+0x100>
    __HAL_RCC_LPTIM2_CONFIG(PeriphClkInit->Lptim2ClockSelection);
 80015ec:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 80015ee:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 80015f2:	f8d1 3088 	ldr.w	r3, [r1, #136]	; 0x88
 80015f6:	0c02      	lsrs	r2, r0, #16
 80015f8:	0412      	lsls	r2, r2, #16
 80015fa:	ea23 0302 	bic.w	r3, r3, r2
 80015fe:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
 8001602:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C1) == RCC_PERIPHCLK_I2C1)
 8001606:	6823      	ldr	r3, [r4, #0]
 8001608:	f013 0f04 	tst.w	r3, #4
 800160c:	d00f      	beq.n	800162e <HAL_RCCEx_PeriphCLKConfig+0x128>
    __HAL_RCC_I2C1_CONFIG(PeriphClkInit->I2c1ClockSelection);
 800160e:	6a23      	ldr	r3, [r4, #32]
  MODIFY_REG(RCC->CCIPR, ((I2CxSource >> 4) & 0x000FF000U), ((I2CxSource << 4) & 0x000FF000U));
 8001610:	f04f 40b0 	mov.w	r0, #1476395008	; 0x58000000
 8001614:	f8d0 2088 	ldr.w	r2, [r0, #136]	; 0x88
 8001618:	0919      	lsrs	r1, r3, #4
 800161a:	f401 217f 	and.w	r1, r1, #1044480	; 0xff000
 800161e:	ea22 0201 	bic.w	r2, r2, r1
 8001622:	011b      	lsls	r3, r3, #4
 8001624:	f403 237f 	and.w	r3, r3, #1044480	; 0xff000
 8001628:	4313      	orrs	r3, r2
 800162a:	f8c0 3088 	str.w	r3, [r0, #136]	; 0x88
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C3) == RCC_PERIPHCLK_I2C3)
 800162e:	6823      	ldr	r3, [r4, #0]
 8001630:	f013 0f08 	tst.w	r3, #8
 8001634:	d00f      	beq.n	8001656 <HAL_RCCEx_PeriphCLKConfig+0x150>
    __HAL_RCC_I2C3_CONFIG(PeriphClkInit->I2c3ClockSelection);
 8001636:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8001638:	f04f 40b0 	mov.w	r0, #1476395008	; 0x58000000
 800163c:	f8d0 2088 	ldr.w	r2, [r0, #136]	; 0x88
 8001640:	0919      	lsrs	r1, r3, #4
 8001642:	f401 217f 	and.w	r1, r1, #1044480	; 0xff000
 8001646:	ea22 0201 	bic.w	r2, r2, r1
 800164a:	011b      	lsls	r3, r3, #4
 800164c:	f403 237f 	and.w	r3, r3, #1044480	; 0xff000
 8001650:	4313      	orrs	r3, r2
 8001652:	f8c0 3088 	str.w	r3, [r0, #136]	; 0x88
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USB) == (RCC_PERIPHCLK_USB))
 8001656:	6823      	ldr	r3, [r4, #0]
 8001658:	f413 7f80 	tst.w	r3, #256	; 0x100
 800165c:	d013      	beq.n	8001686 <HAL_RCCEx_PeriphCLKConfig+0x180>
    __HAL_RCC_USB_CONFIG(PeriphClkInit->UsbClockSelection);
 800165e:	6b63      	ldr	r3, [r4, #52]	; 0x34
  MODIFY_REG(RCC->CCIPR, RCC_CCIPR_CLK48SEL, CLK48xSource);
 8001660:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 8001664:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 8001668:	f022 6240 	bic.w	r2, r2, #201326592	; 0xc000000
 800166c:	4313      	orrs	r3, r2
 800166e:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
    if (PeriphClkInit->UsbClockSelection == RCC_USBCLKSOURCE_PLL)
 8001672:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8001674:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
 8001678:	f000 809c 	beq.w	80017b4 <HAL_RCCEx_PeriphCLKConfig+0x2ae>
    if (PeriphClkInit->UsbClockSelection == RCC_USBCLKSOURCE_PLLSAI1)
 800167c:	6b63      	ldr	r3, [r4, #52]	; 0x34
 800167e:	f1b3 6f80 	cmp.w	r3, #67108864	; 0x4000000
 8001682:	f000 809c 	beq.w	80017be <HAL_RCCEx_PeriphCLKConfig+0x2b8>
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RNG) == (RCC_PERIPHCLK_RNG))
 8001686:	6823      	ldr	r3, [r4, #0]
 8001688:	f413 7f00 	tst.w	r3, #512	; 0x200
 800168c:	d017      	beq.n	80016be <HAL_RCCEx_PeriphCLKConfig+0x1b8>
    __HAL_RCC_RNG_CONFIG(PeriphClkInit->RngClockSelection);
 800168e:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8001690:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 8001694:	d005      	beq.n	80016a2 <HAL_RCCEx_PeriphCLKConfig+0x19c>
 8001696:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
 800169a:	d002      	beq.n	80016a2 <HAL_RCCEx_PeriphCLKConfig+0x19c>
 800169c:	2b00      	cmp	r3, #0
 800169e:	f040 8096 	bne.w	80017ce <HAL_RCCEx_PeriphCLKConfig+0x2c8>
  MODIFY_REG(RCC->CCIPR, RCC_CCIPR_RNGSEL, RNGxSource);
 80016a2:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 80016a6:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 80016aa:	f022 4240 	bic.w	r2, r2, #3221225472	; 0xc0000000
 80016ae:	4313      	orrs	r3, r2
 80016b0:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
    if (PeriphClkInit->RngClockSelection == RCC_RNGCLKSOURCE_PLL)
 80016b4:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80016b6:	f1b3 5fc0 	cmp.w	r3, #402653184	; 0x18000000
 80016ba:	f000 809a 	beq.w	80017f2 <HAL_RCCEx_PeriphCLKConfig+0x2ec>
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_ADC) == RCC_PERIPHCLK_ADC)
 80016be:	6823      	ldr	r3, [r4, #0]
 80016c0:	f413 6f80 	tst.w	r3, #1024	; 0x400
 80016c4:	d013      	beq.n	80016ee <HAL_RCCEx_PeriphCLKConfig+0x1e8>
    __HAL_RCC_ADC_CONFIG(PeriphClkInit->AdcClockSelection);
 80016c6:	6be3      	ldr	r3, [r4, #60]	; 0x3c
  MODIFY_REG(RCC->CCIPR, RCC_CCIPR_ADCSEL, ADCxSource);
 80016c8:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 80016cc:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 80016d0:	f022 5240 	bic.w	r2, r2, #805306368	; 0x30000000
 80016d4:	4313      	orrs	r3, r2
 80016d6:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
    if (PeriphClkInit->AdcClockSelection == RCC_ADCCLKSOURCE_PLL)
 80016da:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 80016dc:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
 80016e0:	f000 808e 	beq.w	8001800 <HAL_RCCEx_PeriphCLKConfig+0x2fa>
    if (PeriphClkInit->AdcClockSelection == RCC_ADCCLKSOURCE_PLLSAI1)
 80016e4:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 80016e6:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
 80016ea:	f000 808e 	beq.w	800180a <HAL_RCCEx_PeriphCLKConfig+0x304>
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RFWAKEUP) == RCC_PERIPHCLK_RFWAKEUP)
 80016ee:	6823      	ldr	r3, [r4, #0]
 80016f0:	f413 5f80 	tst.w	r3, #4096	; 0x1000
 80016f4:	d009      	beq.n	800170a <HAL_RCCEx_PeriphCLKConfig+0x204>
    __HAL_RCC_RFWAKEUP_CONFIG(PeriphClkInit->RFWakeUpClockSelection);
 80016f6:	6c63      	ldr	r3, [r4, #68]	; 0x44
  MODIFY_REG(RCC->CSR, RCC_CSR_RFWKPSEL, Source);
 80016f8:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 80016fc:	f8d1 2094 	ldr.w	r2, [r1, #148]	; 0x94
 8001700:	f422 4240 	bic.w	r2, r2, #49152	; 0xc000
 8001704:	4313      	orrs	r3, r2
 8001706:	f8c1 3094 	str.w	r3, [r1, #148]	; 0x94
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SMPS) == RCC_PERIPHCLK_SMPS)
 800170a:	6823      	ldr	r3, [r4, #0]
 800170c:	f413 5f00 	tst.w	r3, #8192	; 0x2000
 8001710:	d00d      	beq.n	800172e <HAL_RCCEx_PeriphCLKConfig+0x228>
    __HAL_RCC_SMPS_DIV_CONFIG(PeriphClkInit->SmpsDivSelection);
 8001712:	6ce2      	ldr	r2, [r4, #76]	; 0x4c
  MODIFY_REG(RCC->SMPSCR, RCC_SMPSCR_SMPSDIV, Prescaler);
 8001714:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8001718:	6a59      	ldr	r1, [r3, #36]	; 0x24
 800171a:	f021 0130 	bic.w	r1, r1, #48	; 0x30
 800171e:	430a      	orrs	r2, r1
 8001720:	625a      	str	r2, [r3, #36]	; 0x24
    __HAL_RCC_SMPS_CONFIG(PeriphClkInit->SmpsClockSelection);
 8001722:	6ca2      	ldr	r2, [r4, #72]	; 0x48
  MODIFY_REG(RCC->SMPSCR, RCC_SMPSCR_SMPSSEL, SMPSSource);
 8001724:	6a59      	ldr	r1, [r3, #36]	; 0x24
 8001726:	f021 0103 	bic.w	r1, r1, #3
 800172a:	430a      	orrs	r2, r1
 800172c:	625a      	str	r2, [r3, #36]	; 0x24
}
 800172e:	4628      	mov	r0, r5
 8001730:	bd70      	pop	{r4, r5, r6, pc}
      HAL_PWR_EnableBkUpAccess();
 8001732:	f7ff f821 	bl	8000778 <HAL_PWR_EnableBkUpAccess>
      if (rtcclocksource == RCC_RTCCLKSOURCE_NONE)
 8001736:	b95d      	cbnz	r5, 8001750 <HAL_RCCEx_PeriphCLKConfig+0x24a>
        LL_RCC_SetRTCClockSource(PeriphClkInit->RTCClockSelection);
 8001738:	6c23      	ldr	r3, [r4, #64]	; 0x40
  MODIFY_REG(RCC->BDCR, RCC_BDCR_RTCSEL, Source);
 800173a:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 800173e:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
 8001742:	f422 7240 	bic.w	r2, r2, #768	; 0x300
 8001746:	4313      	orrs	r3, r2
 8001748:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
 800174c:	4635      	mov	r5, r6
 800174e:	e71c      	b.n	800158a <HAL_RCCEx_PeriphCLKConfig+0x84>
        uint32_t bdcr = LL_RCC_ReadReg(BDCR);
 8001750:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8001754:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
  SET_BIT(RCC->BDCR, RCC_BDCR_BDRST);
 8001758:	f8d3 1090 	ldr.w	r1, [r3, #144]	; 0x90
 800175c:	f441 3180 	orr.w	r1, r1, #65536	; 0x10000
 8001760:	f8c3 1090 	str.w	r1, [r3, #144]	; 0x90
  CLEAR_BIT(RCC->BDCR, RCC_BDCR_BDRST);
 8001764:	f8d3 1090 	ldr.w	r1, [r3, #144]	; 0x90
 8001768:	f421 3180 	bic.w	r1, r1, #65536	; 0x10000
 800176c:	f8c3 1090 	str.w	r1, [r3, #144]	; 0x90
        MODIFY_REG(bdcr, RCC_BDCR_RTCSEL, PeriphClkInit->RTCClockSelection);
 8001770:	f422 7240 	bic.w	r2, r2, #768	; 0x300
 8001774:	6c21      	ldr	r1, [r4, #64]	; 0x40
 8001776:	430a      	orrs	r2, r1
        LL_RCC_WriteReg(BDCR, bdcr);
 8001778:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
  return ((READ_BIT(RCC->BDCR, RCC_BDCR_LSEON) == (RCC_BDCR_LSEON)) ? 1UL : 0UL);
 800177c:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8001780:	f013 0f01 	tst.w	r3, #1
 8001784:	d101      	bne.n	800178a <HAL_RCCEx_PeriphCLKConfig+0x284>
 8001786:	4635      	mov	r5, r6
 8001788:	e6ff      	b.n	800158a <HAL_RCCEx_PeriphCLKConfig+0x84>
          tickstart = HAL_GetTick();
 800178a:	f7fe ff1f 	bl	80005cc <HAL_GetTick>
 800178e:	4605      	mov	r5, r0
  return ((READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == (RCC_BDCR_LSERDY)) ? 1UL : 0UL);
 8001790:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8001794:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8001798:	f013 0f02 	tst.w	r3, #2
 800179c:	d108      	bne.n	80017b0 <HAL_RCCEx_PeriphCLKConfig+0x2aa>
            if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 800179e:	f7fe ff15 	bl	80005cc <HAL_GetTick>
 80017a2:	1b40      	subs	r0, r0, r5
 80017a4:	f241 3388 	movw	r3, #5000	; 0x1388
 80017a8:	4298      	cmp	r0, r3
 80017aa:	d9f1      	bls.n	8001790 <HAL_RCCEx_PeriphCLKConfig+0x28a>
              ret = HAL_TIMEOUT;
 80017ac:	2503      	movs	r5, #3
 80017ae:	e6ec      	b.n	800158a <HAL_RCCEx_PeriphCLKConfig+0x84>
 80017b0:	4635      	mov	r5, r6
 80017b2:	e6ea      	b.n	800158a <HAL_RCCEx_PeriphCLKConfig+0x84>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_USBCLK);
 80017b4:	68cb      	ldr	r3, [r1, #12]
 80017b6:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 80017ba:	60cb      	str	r3, [r1, #12]
 80017bc:	e75e      	b.n	800167c <HAL_RCCEx_PeriphCLKConfig+0x176>
      ret = RCCEx_PLLSAI1_ConfigNQ(&(PeriphClkInit->PLLSAI1));
 80017be:	1d20      	adds	r0, r4, #4
 80017c0:	f7ff fe13 	bl	80013ea <RCCEx_PLLSAI1_ConfigNQ>
      if (ret != HAL_OK)
 80017c4:	2800      	cmp	r0, #0
 80017c6:	f43f af5e 	beq.w	8001686 <HAL_RCCEx_PeriphCLKConfig+0x180>
        status = ret;
 80017ca:	4605      	mov	r5, r0
 80017cc:	e75b      	b.n	8001686 <HAL_RCCEx_PeriphCLKConfig+0x180>
    __HAL_RCC_RNG_CONFIG(PeriphClkInit->RngClockSelection);
 80017ce:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
  MODIFY_REG(RCC->CCIPR, RCC_CCIPR_RNGSEL, RNGxSource);
 80017d2:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 80017d6:	f8d2 1088 	ldr.w	r1, [r2, #136]	; 0x88
 80017da:	f021 4140 	bic.w	r1, r1, #3221225472	; 0xc0000000
 80017de:	f8c2 1088 	str.w	r1, [r2, #136]	; 0x88
  MODIFY_REG(RCC->CCIPR, RCC_CCIPR_CLK48SEL, CLK48xSource);
 80017e2:	f8d2 1088 	ldr.w	r1, [r2, #136]	; 0x88
 80017e6:	f021 6140 	bic.w	r1, r1, #201326592	; 0xc000000
 80017ea:	430b      	orrs	r3, r1
 80017ec:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
 80017f0:	e760      	b.n	80016b4 <HAL_RCCEx_PeriphCLKConfig+0x1ae>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_RNGCLK);
 80017f2:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 80017f6:	68d3      	ldr	r3, [r2, #12]
 80017f8:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 80017fc:	60d3      	str	r3, [r2, #12]
 80017fe:	e75e      	b.n	80016be <HAL_RCCEx_PeriphCLKConfig+0x1b8>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_ADCCLK);
 8001800:	68cb      	ldr	r3, [r1, #12]
 8001802:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8001806:	60cb      	str	r3, [r1, #12]
 8001808:	e76c      	b.n	80016e4 <HAL_RCCEx_PeriphCLKConfig+0x1de>
      ret = RCCEx_PLLSAI1_ConfigNR(&(PeriphClkInit->PLLSAI1));
 800180a:	1d20      	adds	r0, r4, #4
 800180c:	f7ff fe34 	bl	8001478 <RCCEx_PLLSAI1_ConfigNR>
      if (ret != HAL_OK)
 8001810:	2800      	cmp	r0, #0
 8001812:	f43f af6c 	beq.w	80016ee <HAL_RCCEx_PeriphCLKConfig+0x1e8>
        status = ret;
 8001816:	4605      	mov	r5, r0
 8001818:	e769      	b.n	80016ee <HAL_RCCEx_PeriphCLKConfig+0x1e8>
	...

0800181c <HAL_TIM_Base_Start_IT>:

  /* Check the parameters */
  assert_param(IS_TIM_INSTANCE(htim->Instance));

  /* Enable the TIM Update interrupt */
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
 800181c:	6802      	ldr	r2, [r0, #0]
 800181e:	68d3      	ldr	r3, [r2, #12]
 8001820:	f043 0301 	orr.w	r3, r3, #1
 8001824:	60d3      	str	r3, [r2, #12]

  /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
  tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
 8001826:	6802      	ldr	r2, [r0, #0]
 8001828:	6891      	ldr	r1, [r2, #8]
 800182a:	4b06      	ldr	r3, [pc, #24]	; (8001844 <HAL_TIM_Base_Start_IT+0x28>)
 800182c:	400b      	ands	r3, r1
  if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 800182e:	2b06      	cmp	r3, #6
 8001830:	d006      	beq.n	8001840 <HAL_TIM_Base_Start_IT+0x24>
 8001832:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8001836:	d003      	beq.n	8001840 <HAL_TIM_Base_Start_IT+0x24>
  {
    __HAL_TIM_ENABLE(htim);
 8001838:	6813      	ldr	r3, [r2, #0]
 800183a:	f043 0301 	orr.w	r3, r3, #1
 800183e:	6013      	str	r3, [r2, #0]
  }

  /* Return function status */
  return HAL_OK;
}
 8001840:	2000      	movs	r0, #0
 8001842:	4770      	bx	lr
 8001844:	00010007 	.word	0x00010007

08001848 <HAL_TIM_OC_DelayElapsedCallback>:
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_OC_DelayElapsedCallback could be implemented in the user file
   */
}
 8001848:	4770      	bx	lr

0800184a <HAL_TIM_IC_CaptureCallback>:
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_IC_CaptureCallback could be implemented in the user file
   */
}
 800184a:	4770      	bx	lr

0800184c <HAL_TIM_PWM_PulseFinishedCallback>:
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_PWM_PulseFinishedCallback could be implemented in the user file
   */
}
 800184c:	4770      	bx	lr

0800184e <HAL_TIM_TriggerCallback>:
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_TriggerCallback could be implemented in the user file
   */
}
 800184e:	4770      	bx	lr

08001850 <HAL_TIM_IRQHandler>:
{
 8001850:	b510      	push	{r4, lr}
 8001852:	4604      	mov	r4, r0
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
 8001854:	6803      	ldr	r3, [r0, #0]
 8001856:	691a      	ldr	r2, [r3, #16]
 8001858:	f012 0f02 	tst.w	r2, #2
 800185c:	d011      	beq.n	8001882 <HAL_TIM_IRQHandler+0x32>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC1) != RESET)
 800185e:	68da      	ldr	r2, [r3, #12]
 8001860:	f012 0f02 	tst.w	r2, #2
 8001864:	d00d      	beq.n	8001882 <HAL_TIM_IRQHandler+0x32>
        __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC1);
 8001866:	f06f 0202 	mvn.w	r2, #2
 800186a:	611a      	str	r2, [r3, #16]
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
 800186c:	2301      	movs	r3, #1
 800186e:	7703      	strb	r3, [r0, #28]
        if ((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00U)
 8001870:	6803      	ldr	r3, [r0, #0]
 8001872:	699b      	ldr	r3, [r3, #24]
 8001874:	f013 0f03 	tst.w	r3, #3
 8001878:	d079      	beq.n	800196e <HAL_TIM_IRQHandler+0x11e>
          HAL_TIM_IC_CaptureCallback(htim);
 800187a:	f7ff ffe6 	bl	800184a <HAL_TIM_IC_CaptureCallback>
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 800187e:	2300      	movs	r3, #0
 8001880:	7723      	strb	r3, [r4, #28]
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC2) != RESET)
 8001882:	6823      	ldr	r3, [r4, #0]
 8001884:	691a      	ldr	r2, [r3, #16]
 8001886:	f012 0f04 	tst.w	r2, #4
 800188a:	d012      	beq.n	80018b2 <HAL_TIM_IRQHandler+0x62>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC2) != RESET)
 800188c:	68da      	ldr	r2, [r3, #12]
 800188e:	f012 0f04 	tst.w	r2, #4
 8001892:	d00e      	beq.n	80018b2 <HAL_TIM_IRQHandler+0x62>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC2);
 8001894:	f06f 0204 	mvn.w	r2, #4
 8001898:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
 800189a:	2302      	movs	r3, #2
 800189c:	7723      	strb	r3, [r4, #28]
      if ((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00U)
 800189e:	6823      	ldr	r3, [r4, #0]
 80018a0:	699b      	ldr	r3, [r3, #24]
 80018a2:	f413 7f40 	tst.w	r3, #768	; 0x300
 80018a6:	d068      	beq.n	800197a <HAL_TIM_IRQHandler+0x12a>
        HAL_TIM_IC_CaptureCallback(htim);
 80018a8:	4620      	mov	r0, r4
 80018aa:	f7ff ffce 	bl	800184a <HAL_TIM_IC_CaptureCallback>
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 80018ae:	2300      	movs	r3, #0
 80018b0:	7723      	strb	r3, [r4, #28]
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC3) != RESET)
 80018b2:	6823      	ldr	r3, [r4, #0]
 80018b4:	691a      	ldr	r2, [r3, #16]
 80018b6:	f012 0f08 	tst.w	r2, #8
 80018ba:	d012      	beq.n	80018e2 <HAL_TIM_IRQHandler+0x92>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC3) != RESET)
 80018bc:	68da      	ldr	r2, [r3, #12]
 80018be:	f012 0f08 	tst.w	r2, #8
 80018c2:	d00e      	beq.n	80018e2 <HAL_TIM_IRQHandler+0x92>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC3);
 80018c4:	f06f 0208 	mvn.w	r2, #8
 80018c8:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
 80018ca:	2304      	movs	r3, #4
 80018cc:	7723      	strb	r3, [r4, #28]
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00U)
 80018ce:	6823      	ldr	r3, [r4, #0]
 80018d0:	69db      	ldr	r3, [r3, #28]
 80018d2:	f013 0f03 	tst.w	r3, #3
 80018d6:	d057      	beq.n	8001988 <HAL_TIM_IRQHandler+0x138>
        HAL_TIM_IC_CaptureCallback(htim);
 80018d8:	4620      	mov	r0, r4
 80018da:	f7ff ffb6 	bl	800184a <HAL_TIM_IC_CaptureCallback>
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 80018de:	2300      	movs	r3, #0
 80018e0:	7723      	strb	r3, [r4, #28]
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC4) != RESET)
 80018e2:	6823      	ldr	r3, [r4, #0]
 80018e4:	691a      	ldr	r2, [r3, #16]
 80018e6:	f012 0f10 	tst.w	r2, #16
 80018ea:	d012      	beq.n	8001912 <HAL_TIM_IRQHandler+0xc2>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC4) != RESET)
 80018ec:	68da      	ldr	r2, [r3, #12]
 80018ee:	f012 0f10 	tst.w	r2, #16
 80018f2:	d00e      	beq.n	8001912 <HAL_TIM_IRQHandler+0xc2>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC4);
 80018f4:	f06f 0210 	mvn.w	r2, #16
 80018f8:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
 80018fa:	2308      	movs	r3, #8
 80018fc:	7723      	strb	r3, [r4, #28]
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00U)
 80018fe:	6823      	ldr	r3, [r4, #0]
 8001900:	69db      	ldr	r3, [r3, #28]
 8001902:	f413 7f40 	tst.w	r3, #768	; 0x300
 8001906:	d046      	beq.n	8001996 <HAL_TIM_IRQHandler+0x146>
        HAL_TIM_IC_CaptureCallback(htim);
 8001908:	4620      	mov	r0, r4
 800190a:	f7ff ff9e 	bl	800184a <HAL_TIM_IC_CaptureCallback>
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 800190e:	2300      	movs	r3, #0
 8001910:	7723      	strb	r3, [r4, #28]
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_UPDATE) != RESET)
 8001912:	6823      	ldr	r3, [r4, #0]
 8001914:	691a      	ldr	r2, [r3, #16]
 8001916:	f012 0f01 	tst.w	r2, #1
 800191a:	d003      	beq.n	8001924 <HAL_TIM_IRQHandler+0xd4>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_UPDATE) != RESET)
 800191c:	68da      	ldr	r2, [r3, #12]
 800191e:	f012 0f01 	tst.w	r2, #1
 8001922:	d13f      	bne.n	80019a4 <HAL_TIM_IRQHandler+0x154>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK) != RESET)
 8001924:	6823      	ldr	r3, [r4, #0]
 8001926:	691a      	ldr	r2, [r3, #16]
 8001928:	f012 0f80 	tst.w	r2, #128	; 0x80
 800192c:	d003      	beq.n	8001936 <HAL_TIM_IRQHandler+0xe6>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) != RESET)
 800192e:	68da      	ldr	r2, [r3, #12]
 8001930:	f012 0f80 	tst.w	r2, #128	; 0x80
 8001934:	d13d      	bne.n	80019b2 <HAL_TIM_IRQHandler+0x162>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK2) != RESET)
 8001936:	6823      	ldr	r3, [r4, #0]
 8001938:	691a      	ldr	r2, [r3, #16]
 800193a:	f412 7f80 	tst.w	r2, #256	; 0x100
 800193e:	d003      	beq.n	8001948 <HAL_TIM_IRQHandler+0xf8>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) != RESET)
 8001940:	68da      	ldr	r2, [r3, #12]
 8001942:	f012 0f80 	tst.w	r2, #128	; 0x80
 8001946:	d13b      	bne.n	80019c0 <HAL_TIM_IRQHandler+0x170>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_TRIGGER) != RESET)
 8001948:	6823      	ldr	r3, [r4, #0]
 800194a:	691a      	ldr	r2, [r3, #16]
 800194c:	f012 0f40 	tst.w	r2, #64	; 0x40
 8001950:	d003      	beq.n	800195a <HAL_TIM_IRQHandler+0x10a>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_TRIGGER) != RESET)
 8001952:	68da      	ldr	r2, [r3, #12]
 8001954:	f012 0f40 	tst.w	r2, #64	; 0x40
 8001958:	d139      	bne.n	80019ce <HAL_TIM_IRQHandler+0x17e>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_COM) != RESET)
 800195a:	6823      	ldr	r3, [r4, #0]
 800195c:	691a      	ldr	r2, [r3, #16]
 800195e:	f012 0f20 	tst.w	r2, #32
 8001962:	d003      	beq.n	800196c <HAL_TIM_IRQHandler+0x11c>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_COM) != RESET)
 8001964:	68da      	ldr	r2, [r3, #12]
 8001966:	f012 0f20 	tst.w	r2, #32
 800196a:	d137      	bne.n	80019dc <HAL_TIM_IRQHandler+0x18c>
}
 800196c:	bd10      	pop	{r4, pc}
          HAL_TIM_OC_DelayElapsedCallback(htim);
 800196e:	f7ff ff6b 	bl	8001848 <HAL_TIM_OC_DelayElapsedCallback>
          HAL_TIM_PWM_PulseFinishedCallback(htim);
 8001972:	4620      	mov	r0, r4
 8001974:	f7ff ff6a 	bl	800184c <HAL_TIM_PWM_PulseFinishedCallback>
 8001978:	e781      	b.n	800187e <HAL_TIM_IRQHandler+0x2e>
        HAL_TIM_OC_DelayElapsedCallback(htim);
 800197a:	4620      	mov	r0, r4
 800197c:	f7ff ff64 	bl	8001848 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 8001980:	4620      	mov	r0, r4
 8001982:	f7ff ff63 	bl	800184c <HAL_TIM_PWM_PulseFinishedCallback>
 8001986:	e792      	b.n	80018ae <HAL_TIM_IRQHandler+0x5e>
        HAL_TIM_OC_DelayElapsedCallback(htim);
 8001988:	4620      	mov	r0, r4
 800198a:	f7ff ff5d 	bl	8001848 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 800198e:	4620      	mov	r0, r4
 8001990:	f7ff ff5c 	bl	800184c <HAL_TIM_PWM_PulseFinishedCallback>
 8001994:	e7a3      	b.n	80018de <HAL_TIM_IRQHandler+0x8e>
        HAL_TIM_OC_DelayElapsedCallback(htim);
 8001996:	4620      	mov	r0, r4
 8001998:	f7ff ff56 	bl	8001848 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 800199c:	4620      	mov	r0, r4
 800199e:	f7ff ff55 	bl	800184c <HAL_TIM_PWM_PulseFinishedCallback>
 80019a2:	e7b4      	b.n	800190e <HAL_TIM_IRQHandler+0xbe>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_UPDATE);
 80019a4:	f06f 0201 	mvn.w	r2, #1
 80019a8:	611a      	str	r2, [r3, #16]
      HAL_TIM_PeriodElapsedCallback(htim);
 80019aa:	4620      	mov	r0, r4
 80019ac:	f7fe fc86 	bl	80002bc <HAL_TIM_PeriodElapsedCallback>
 80019b0:	e7b8      	b.n	8001924 <HAL_TIM_IRQHandler+0xd4>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_BREAK);
 80019b2:	f06f 0280 	mvn.w	r2, #128	; 0x80
 80019b6:	611a      	str	r2, [r3, #16]
      HAL_TIMEx_BreakCallback(htim);
 80019b8:	4620      	mov	r0, r4
 80019ba:	f000 f869 	bl	8001a90 <HAL_TIMEx_BreakCallback>
 80019be:	e7ba      	b.n	8001936 <HAL_TIM_IRQHandler+0xe6>
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_BREAK2);
 80019c0:	f46f 7280 	mvn.w	r2, #256	; 0x100
 80019c4:	611a      	str	r2, [r3, #16]
      HAL_TIMEx_Break2Callback(htim);
 80019c6:	4620      	mov	r0, r4
 80019c8:	f000 f863 	bl	8001a92 <HAL_TIMEx_Break2Callback>
 80019cc:	e7bc      	b.n	8001948 <HAL_TIM_IRQHandler+0xf8>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_TRIGGER);
 80019ce:	f06f 0240 	mvn.w	r2, #64	; 0x40
 80019d2:	611a      	str	r2, [r3, #16]
      HAL_TIM_TriggerCallback(htim);
 80019d4:	4620      	mov	r0, r4
 80019d6:	f7ff ff3a 	bl	800184e <HAL_TIM_TriggerCallback>
 80019da:	e7be      	b.n	800195a <HAL_TIM_IRQHandler+0x10a>
      __HAL_TIM_CLEAR_IT(htim, TIM_FLAG_COM);
 80019dc:	f06f 0220 	mvn.w	r2, #32
 80019e0:	611a      	str	r2, [r3, #16]
      HAL_TIMEx_CommutCallback(htim);
 80019e2:	4620      	mov	r0, r4
 80019e4:	f000 f853 	bl	8001a8e <HAL_TIMEx_CommutCallback>
}
 80019e8:	e7c0      	b.n	800196c <HAL_TIM_IRQHandler+0x11c>
	...

080019ec <TIM_Base_SetConfig>:
  * @retval None
  */
void TIM_Base_SetConfig(TIM_TypeDef *TIMx, TIM_Base_InitTypeDef *Structure)
{
  uint32_t tmpcr1;
  tmpcr1 = TIMx->CR1;
 80019ec:	6803      	ldr	r3, [r0, #0]

  /* Set TIM Time Base Unit parameters ---------------------------------------*/
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 80019ee:	4a1a      	ldr	r2, [pc, #104]	; (8001a58 <TIM_Base_SetConfig+0x6c>)
 80019f0:	4290      	cmp	r0, r2
 80019f2:	d002      	beq.n	80019fa <TIM_Base_SetConfig+0xe>
 80019f4:	f1b0 4f80 	cmp.w	r0, #1073741824	; 0x40000000
 80019f8:	d103      	bne.n	8001a02 <TIM_Base_SetConfig+0x16>
  {
    /* Select the Counter Mode */
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 80019fa:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    tmpcr1 |= Structure->CounterMode;
 80019fe:	684a      	ldr	r2, [r1, #4]
 8001a00:	4313      	orrs	r3, r2
  }

  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 8001a02:	4a15      	ldr	r2, [pc, #84]	; (8001a58 <TIM_Base_SetConfig+0x6c>)
 8001a04:	4290      	cmp	r0, r2
 8001a06:	d00a      	beq.n	8001a1e <TIM_Base_SetConfig+0x32>
 8001a08:	f1b0 4f80 	cmp.w	r0, #1073741824	; 0x40000000
 8001a0c:	d007      	beq.n	8001a1e <TIM_Base_SetConfig+0x32>
 8001a0e:	f502 52c0 	add.w	r2, r2, #6144	; 0x1800
 8001a12:	4290      	cmp	r0, r2
 8001a14:	d003      	beq.n	8001a1e <TIM_Base_SetConfig+0x32>
 8001a16:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8001a1a:	4290      	cmp	r0, r2
 8001a1c:	d103      	bne.n	8001a26 <TIM_Base_SetConfig+0x3a>
  {
    /* Set the clock division */
    tmpcr1 &= ~TIM_CR1_CKD;
 8001a1e:	f423 7340 	bic.w	r3, r3, #768	; 0x300
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 8001a22:	68ca      	ldr	r2, [r1, #12]
 8001a24:	4313      	orrs	r3, r2
  }

  /* Set the auto-reload preload */
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 8001a26:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8001a2a:	694a      	ldr	r2, [r1, #20]
 8001a2c:	4313      	orrs	r3, r2

  TIMx->CR1 = tmpcr1;
 8001a2e:	6003      	str	r3, [r0, #0]

  /* Set the Autoreload value */
  TIMx->ARR = (uint32_t)Structure->Period ;
 8001a30:	688b      	ldr	r3, [r1, #8]
 8001a32:	62c3      	str	r3, [r0, #44]	; 0x2c

  /* Set the Prescaler value */
  TIMx->PSC = Structure->Prescaler;
 8001a34:	680b      	ldr	r3, [r1, #0]
 8001a36:	6283      	str	r3, [r0, #40]	; 0x28

  if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
 8001a38:	4b07      	ldr	r3, [pc, #28]	; (8001a58 <TIM_Base_SetConfig+0x6c>)
 8001a3a:	4298      	cmp	r0, r3
 8001a3c:	d007      	beq.n	8001a4e <TIM_Base_SetConfig+0x62>
 8001a3e:	f503 53c0 	add.w	r3, r3, #6144	; 0x1800
 8001a42:	4298      	cmp	r0, r3
 8001a44:	d003      	beq.n	8001a4e <TIM_Base_SetConfig+0x62>
 8001a46:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8001a4a:	4298      	cmp	r0, r3
 8001a4c:	d101      	bne.n	8001a52 <TIM_Base_SetConfig+0x66>
  {
    /* Set the Repetition Counter value */
    TIMx->RCR = Structure->RepetitionCounter;
 8001a4e:	690b      	ldr	r3, [r1, #16]
 8001a50:	6303      	str	r3, [r0, #48]	; 0x30
  }

  /* Generate an update event to reload the Prescaler
     and the repetition counter (only for advanced timer) value immediately */
  TIMx->EGR = TIM_EGR_UG;
 8001a52:	2301      	movs	r3, #1
 8001a54:	6143      	str	r3, [r0, #20]
}
 8001a56:	4770      	bx	lr
 8001a58:	40012c00 	.word	0x40012c00

08001a5c <HAL_TIM_Base_Init>:
  if (htim == NULL)
 8001a5c:	b1a8      	cbz	r0, 8001a8a <HAL_TIM_Base_Init+0x2e>
{
 8001a5e:	b510      	push	{r4, lr}
 8001a60:	4604      	mov	r4, r0
  if (htim->State == HAL_TIM_STATE_RESET)
 8001a62:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
 8001a66:	b15b      	cbz	r3, 8001a80 <HAL_TIM_Base_Init+0x24>
  htim->State = HAL_TIM_STATE_BUSY;
 8001a68:	2302      	movs	r3, #2
 8001a6a:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
 8001a6e:	1d21      	adds	r1, r4, #4
 8001a70:	6820      	ldr	r0, [r4, #0]
 8001a72:	f7ff ffbb 	bl	80019ec <TIM_Base_SetConfig>
  htim->State = HAL_TIM_STATE_READY;
 8001a76:	2301      	movs	r3, #1
 8001a78:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
  return HAL_OK;
 8001a7c:	2000      	movs	r0, #0
}
 8001a7e:	bd10      	pop	{r4, pc}
    htim->Lock = HAL_UNLOCKED;
 8001a80:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c
    HAL_TIM_Base_MspInit(htim);
 8001a84:	f7fe fd34 	bl	80004f0 <HAL_TIM_Base_MspInit>
 8001a88:	e7ee      	b.n	8001a68 <HAL_TIM_Base_Init+0xc>
    return HAL_ERROR;
 8001a8a:	2001      	movs	r0, #1
}
 8001a8c:	4770      	bx	lr

08001a8e <HAL_TIMEx_CommutCallback>:
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIMEx_CommutCallback could be implemented in the user file
   */
}
 8001a8e:	4770      	bx	lr

08001a90 <HAL_TIMEx_BreakCallback>:
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIMEx_BreakCallback could be implemented in the user file
   */
}
 8001a90:	4770      	bx	lr

08001a92 <HAL_TIMEx_Break2Callback>:
  UNUSED(htim);

  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_TIMEx_Break2Callback could be implemented in the user file
   */
}
 8001a92:	4770      	bx	lr

08001a94 <UART_TxISR_8BIT>:
  * @retval None
  */
static void UART_TxISR_8BIT(UART_HandleTypeDef *huart)
{
  /* Check that a Tx process is ongoing */
  if (huart->gState == HAL_UART_STATE_BUSY_TX)
 8001a94:	f8d0 3080 	ldr.w	r3, [r0, #128]	; 0x80
 8001a98:	2b21      	cmp	r3, #33	; 0x21
 8001a9a:	d000      	beq.n	8001a9e <UART_TxISR_8BIT+0xa>
      huart->Instance->TDR = (uint8_t)(*huart->pTxBuffPtr & (uint8_t)0xFF);
      huart->pTxBuffPtr++;
      huart->TxXferCount--;
    }
  }
}
 8001a9c:	4770      	bx	lr
    if (huart->TxXferCount == 0U)
 8001a9e:	f8b0 3056 	ldrh.w	r3, [r0, #86]	; 0x56
 8001aa2:	b29b      	uxth	r3, r3
 8001aa4:	b16b      	cbz	r3, 8001ac2 <UART_TxISR_8BIT+0x2e>
      huart->Instance->TDR = (uint8_t)(*huart->pTxBuffPtr & (uint8_t)0xFF);
 8001aa6:	6d03      	ldr	r3, [r0, #80]	; 0x50
 8001aa8:	781a      	ldrb	r2, [r3, #0]
 8001aaa:	6803      	ldr	r3, [r0, #0]
 8001aac:	629a      	str	r2, [r3, #40]	; 0x28
      huart->pTxBuffPtr++;
 8001aae:	6d03      	ldr	r3, [r0, #80]	; 0x50
 8001ab0:	3301      	adds	r3, #1
 8001ab2:	6503      	str	r3, [r0, #80]	; 0x50
      huart->TxXferCount--;
 8001ab4:	f8b0 3056 	ldrh.w	r3, [r0, #86]	; 0x56
 8001ab8:	3b01      	subs	r3, #1
 8001aba:	b29b      	uxth	r3, r3
 8001abc:	f8a0 3056 	strh.w	r3, [r0, #86]	; 0x56
}
 8001ac0:	e7ec      	b.n	8001a9c <UART_TxISR_8BIT+0x8>
      CLEAR_BIT(huart->Instance->CR1, USART_CR1_TXEIE_TXFNFIE);
 8001ac2:	6802      	ldr	r2, [r0, #0]
 8001ac4:	6813      	ldr	r3, [r2, #0]
 8001ac6:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8001aca:	6013      	str	r3, [r2, #0]
      SET_BIT(huart->Instance->CR1, USART_CR1_TCIE);
 8001acc:	6802      	ldr	r2, [r0, #0]
 8001ace:	6813      	ldr	r3, [r2, #0]
 8001ad0:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8001ad4:	6013      	str	r3, [r2, #0]
 8001ad6:	4770      	bx	lr

08001ad8 <UART_TxISR_16BIT>:
static void UART_TxISR_16BIT(UART_HandleTypeDef *huart)
{
  uint16_t *tmp;

  /* Check that a Tx process is ongoing */
  if (huart->gState == HAL_UART_STATE_BUSY_TX)
 8001ad8:	f8d0 3080 	ldr.w	r3, [r0, #128]	; 0x80
 8001adc:	2b21      	cmp	r3, #33	; 0x21
 8001ade:	d000      	beq.n	8001ae2 <UART_TxISR_16BIT+0xa>
      huart->Instance->TDR = (((uint32_t)(*tmp)) & 0x01FFUL);
      huart->pTxBuffPtr += 2U;
      huart->TxXferCount--;
    }
  }
}
 8001ae0:	4770      	bx	lr
    if (huart->TxXferCount == 0U)
 8001ae2:	f8b0 3056 	ldrh.w	r3, [r0, #86]	; 0x56
 8001ae6:	b29b      	uxth	r3, r3
 8001ae8:	b17b      	cbz	r3, 8001b0a <UART_TxISR_16BIT+0x32>
      tmp = (uint16_t *) huart->pTxBuffPtr;
 8001aea:	6d03      	ldr	r3, [r0, #80]	; 0x50
      huart->Instance->TDR = (((uint32_t)(*tmp)) & 0x01FFUL);
 8001aec:	881b      	ldrh	r3, [r3, #0]
 8001aee:	6802      	ldr	r2, [r0, #0]
 8001af0:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8001af4:	6293      	str	r3, [r2, #40]	; 0x28
      huart->pTxBuffPtr += 2U;
 8001af6:	6d03      	ldr	r3, [r0, #80]	; 0x50
 8001af8:	3302      	adds	r3, #2
 8001afa:	6503      	str	r3, [r0, #80]	; 0x50
      huart->TxXferCount--;
 8001afc:	f8b0 3056 	ldrh.w	r3, [r0, #86]	; 0x56
 8001b00:	3b01      	subs	r3, #1
 8001b02:	b29b      	uxth	r3, r3
 8001b04:	f8a0 3056 	strh.w	r3, [r0, #86]	; 0x56
}
 8001b08:	e7ea      	b.n	8001ae0 <UART_TxISR_16BIT+0x8>
      CLEAR_BIT(huart->Instance->CR1, USART_CR1_TXEIE_TXFNFIE);
 8001b0a:	6802      	ldr	r2, [r0, #0]
 8001b0c:	6813      	ldr	r3, [r2, #0]
 8001b0e:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8001b12:	6013      	str	r3, [r2, #0]
      SET_BIT(huart->Instance->CR1, USART_CR1_TCIE);
 8001b14:	6802      	ldr	r2, [r0, #0]
 8001b16:	6813      	ldr	r3, [r2, #0]
 8001b18:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8001b1c:	6013      	str	r3, [r2, #0]
 8001b1e:	4770      	bx	lr

08001b20 <UART_TxISR_8BIT_FIFOEN>:
static void UART_TxISR_8BIT_FIFOEN(UART_HandleTypeDef *huart)
{
  uint16_t  nb_tx_data;

  /* Check that a Tx process is ongoing */
  if (huart->gState == HAL_UART_STATE_BUSY_TX)
 8001b20:	f8d0 3080 	ldr.w	r3, [r0, #128]	; 0x80
 8001b24:	2b21      	cmp	r3, #33	; 0x21
 8001b26:	d000      	beq.n	8001b2a <UART_TxISR_8BIT_FIFOEN+0xa>
      {
        /* Nothing to do */
      }
    }
  }
}
 8001b28:	4770      	bx	lr
    for (nb_tx_data = huart->NbTxDataToProcess ; nb_tx_data > 0U ; nb_tx_data--)
 8001b2a:	f8b0 306a 	ldrh.w	r3, [r0, #106]	; 0x6a
 8001b2e:	e00c      	b.n	8001b4a <UART_TxISR_8BIT_FIFOEN+0x2a>
        CLEAR_BIT(huart->Instance->CR3, USART_CR3_TXFTIE);
 8001b30:	6802      	ldr	r2, [r0, #0]
 8001b32:	6893      	ldr	r3, [r2, #8]
 8001b34:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
 8001b38:	6093      	str	r3, [r2, #8]
        SET_BIT(huart->Instance->CR1, USART_CR1_TCIE);
 8001b3a:	6802      	ldr	r2, [r0, #0]
 8001b3c:	6813      	ldr	r3, [r2, #0]
 8001b3e:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8001b42:	6013      	str	r3, [r2, #0]
        break; /* force exit loop */
 8001b44:	4770      	bx	lr
    for (nb_tx_data = huart->NbTxDataToProcess ; nb_tx_data > 0U ; nb_tx_data--)
 8001b46:	3b01      	subs	r3, #1
 8001b48:	b29b      	uxth	r3, r3
 8001b4a:	2b00      	cmp	r3, #0
 8001b4c:	d0ec      	beq.n	8001b28 <UART_TxISR_8BIT_FIFOEN+0x8>
      if (huart->TxXferCount == 0U)
 8001b4e:	f8b0 2056 	ldrh.w	r2, [r0, #86]	; 0x56
 8001b52:	b292      	uxth	r2, r2
 8001b54:	2a00      	cmp	r2, #0
 8001b56:	d0eb      	beq.n	8001b30 <UART_TxISR_8BIT_FIFOEN+0x10>
      else if (READ_BIT(huart->Instance->ISR, USART_ISR_TXE_TXFNF) != 0U)
 8001b58:	6802      	ldr	r2, [r0, #0]
 8001b5a:	69d1      	ldr	r1, [r2, #28]
 8001b5c:	f011 0f80 	tst.w	r1, #128	; 0x80
 8001b60:	d0f1      	beq.n	8001b46 <UART_TxISR_8BIT_FIFOEN+0x26>
        huart->Instance->TDR = (uint8_t)(*huart->pTxBuffPtr & (uint8_t)0xFF);
 8001b62:	6d01      	ldr	r1, [r0, #80]	; 0x50
 8001b64:	7809      	ldrb	r1, [r1, #0]
 8001b66:	6291      	str	r1, [r2, #40]	; 0x28
        huart->pTxBuffPtr++;
 8001b68:	6d02      	ldr	r2, [r0, #80]	; 0x50
 8001b6a:	3201      	adds	r2, #1
 8001b6c:	6502      	str	r2, [r0, #80]	; 0x50
        huart->TxXferCount--;
 8001b6e:	f8b0 2056 	ldrh.w	r2, [r0, #86]	; 0x56
 8001b72:	3a01      	subs	r2, #1
 8001b74:	b292      	uxth	r2, r2
 8001b76:	f8a0 2056 	strh.w	r2, [r0, #86]	; 0x56
 8001b7a:	e7e4      	b.n	8001b46 <UART_TxISR_8BIT_FIFOEN+0x26>

08001b7c <UART_TxISR_16BIT_FIFOEN>:
{
  uint16_t *tmp;
  uint16_t  nb_tx_data;

  /* Check that a Tx process is ongoing */
  if (huart->gState == HAL_UART_STATE_BUSY_TX)
 8001b7c:	f8d0 3080 	ldr.w	r3, [r0, #128]	; 0x80
 8001b80:	2b21      	cmp	r3, #33	; 0x21
 8001b82:	d000      	beq.n	8001b86 <UART_TxISR_16BIT_FIFOEN+0xa>
      {
        /* Nothing to do */
      }
    }
  }
}
 8001b84:	4770      	bx	lr
    for (nb_tx_data = huart->NbTxDataToProcess ; nb_tx_data > 0U ; nb_tx_data--)
 8001b86:	f8b0 306a 	ldrh.w	r3, [r0, #106]	; 0x6a
 8001b8a:	e00c      	b.n	8001ba6 <UART_TxISR_16BIT_FIFOEN+0x2a>
        CLEAR_BIT(huart->Instance->CR3, USART_CR3_TXFTIE);
 8001b8c:	6802      	ldr	r2, [r0, #0]
 8001b8e:	6893      	ldr	r3, [r2, #8]
 8001b90:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
 8001b94:	6093      	str	r3, [r2, #8]
        SET_BIT(huart->Instance->CR1, USART_CR1_TCIE);
 8001b96:	6802      	ldr	r2, [r0, #0]
 8001b98:	6813      	ldr	r3, [r2, #0]
 8001b9a:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8001b9e:	6013      	str	r3, [r2, #0]
        break; /* force exit loop */
 8001ba0:	4770      	bx	lr
    for (nb_tx_data = huart->NbTxDataToProcess ; nb_tx_data > 0U ; nb_tx_data--)
 8001ba2:	3b01      	subs	r3, #1
 8001ba4:	b29b      	uxth	r3, r3
 8001ba6:	2b00      	cmp	r3, #0
 8001ba8:	d0ec      	beq.n	8001b84 <UART_TxISR_16BIT_FIFOEN+0x8>
      if (huart->TxXferCount == 0U)
 8001baa:	f8b0 2056 	ldrh.w	r2, [r0, #86]	; 0x56
 8001bae:	b292      	uxth	r2, r2
 8001bb0:	2a00      	cmp	r2, #0
 8001bb2:	d0eb      	beq.n	8001b8c <UART_TxISR_16BIT_FIFOEN+0x10>
      else if (READ_BIT(huart->Instance->ISR, USART_ISR_TXE_TXFNF) != 0U)
 8001bb4:	6802      	ldr	r2, [r0, #0]
 8001bb6:	69d1      	ldr	r1, [r2, #28]
 8001bb8:	f011 0f80 	tst.w	r1, #128	; 0x80
 8001bbc:	d0f1      	beq.n	8001ba2 <UART_TxISR_16BIT_FIFOEN+0x26>
        tmp = (uint16_t *) huart->pTxBuffPtr;
 8001bbe:	6d01      	ldr	r1, [r0, #80]	; 0x50
        huart->Instance->TDR = (((uint32_t)(*tmp)) & 0x01FFUL);
 8001bc0:	8809      	ldrh	r1, [r1, #0]
 8001bc2:	f3c1 0108 	ubfx	r1, r1, #0, #9
 8001bc6:	6291      	str	r1, [r2, #40]	; 0x28
        huart->pTxBuffPtr += 2U;
 8001bc8:	6d02      	ldr	r2, [r0, #80]	; 0x50
 8001bca:	3202      	adds	r2, #2
 8001bcc:	6502      	str	r2, [r0, #80]	; 0x50
        huart->TxXferCount--;
 8001bce:	f8b0 2056 	ldrh.w	r2, [r0, #86]	; 0x56
 8001bd2:	3a01      	subs	r2, #1
 8001bd4:	b292      	uxth	r2, r2
 8001bd6:	f8a0 2056 	strh.w	r2, [r0, #86]	; 0x56
 8001bda:	e7e2      	b.n	8001ba2 <UART_TxISR_16BIT_FIFOEN+0x26>

08001bdc <HAL_UART_Transmit_IT>:
  if (huart->gState == HAL_UART_STATE_READY)
 8001bdc:	f8d0 3080 	ldr.w	r3, [r0, #128]	; 0x80
 8001be0:	2b20      	cmp	r3, #32
 8001be2:	d146      	bne.n	8001c72 <HAL_UART_Transmit_IT+0x96>
    if ((pData == NULL) || (Size == 0U))
 8001be4:	2900      	cmp	r1, #0
 8001be6:	d046      	beq.n	8001c76 <HAL_UART_Transmit_IT+0x9a>
 8001be8:	2a00      	cmp	r2, #0
 8001bea:	d046      	beq.n	8001c7a <HAL_UART_Transmit_IT+0x9e>
    __HAL_LOCK(huart);
 8001bec:	f890 307c 	ldrb.w	r3, [r0, #124]	; 0x7c
 8001bf0:	2b01      	cmp	r3, #1
 8001bf2:	d044      	beq.n	8001c7e <HAL_UART_Transmit_IT+0xa2>
 8001bf4:	2301      	movs	r3, #1
 8001bf6:	f880 307c 	strb.w	r3, [r0, #124]	; 0x7c
    huart->pTxBuffPtr  = pData;
 8001bfa:	6501      	str	r1, [r0, #80]	; 0x50
    huart->TxXferSize  = Size;
 8001bfc:	f8a0 2054 	strh.w	r2, [r0, #84]	; 0x54
    huart->TxXferCount = Size;
 8001c00:	f8a0 2056 	strh.w	r2, [r0, #86]	; 0x56
    huart->TxISR       = NULL;
 8001c04:	2300      	movs	r3, #0
 8001c06:	6703      	str	r3, [r0, #112]	; 0x70
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 8001c08:	f8c0 3088 	str.w	r3, [r0, #136]	; 0x88
    huart->gState = HAL_UART_STATE_BUSY_TX;
 8001c0c:	2321      	movs	r3, #33	; 0x21
 8001c0e:	f8c0 3080 	str.w	r3, [r0, #128]	; 0x80
    if (huart->FifoMode == UART_FIFOMODE_ENABLE)
 8001c12:	6e43      	ldr	r3, [r0, #100]	; 0x64
 8001c14:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
 8001c18:	d00f      	beq.n	8001c3a <HAL_UART_Transmit_IT+0x5e>
      if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 8001c1a:	6883      	ldr	r3, [r0, #8]
 8001c1c:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 8001c20:	d021      	beq.n	8001c66 <HAL_UART_Transmit_IT+0x8a>
        huart->TxISR = UART_TxISR_8BIT;
 8001c22:	4b18      	ldr	r3, [pc, #96]	; (8001c84 <HAL_UART_Transmit_IT+0xa8>)
 8001c24:	6703      	str	r3, [r0, #112]	; 0x70
      __HAL_UNLOCK(huart);
 8001c26:	2300      	movs	r3, #0
 8001c28:	f880 307c 	strb.w	r3, [r0, #124]	; 0x7c
      SET_BIT(huart->Instance->CR1, USART_CR1_TXEIE_TXFNFIE);
 8001c2c:	6801      	ldr	r1, [r0, #0]
 8001c2e:	680a      	ldr	r2, [r1, #0]
 8001c30:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 8001c34:	600a      	str	r2, [r1, #0]
    return HAL_OK;
 8001c36:	4618      	mov	r0, r3
 8001c38:	4770      	bx	lr
      if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 8001c3a:	6883      	ldr	r3, [r0, #8]
 8001c3c:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 8001c40:	d00b      	beq.n	8001c5a <HAL_UART_Transmit_IT+0x7e>
        huart->TxISR = UART_TxISR_8BIT_FIFOEN;
 8001c42:	4b11      	ldr	r3, [pc, #68]	; (8001c88 <HAL_UART_Transmit_IT+0xac>)
 8001c44:	6703      	str	r3, [r0, #112]	; 0x70
      __HAL_UNLOCK(huart);
 8001c46:	2300      	movs	r3, #0
 8001c48:	f880 307c 	strb.w	r3, [r0, #124]	; 0x7c
      SET_BIT(huart->Instance->CR3, USART_CR3_TXFTIE);
 8001c4c:	6801      	ldr	r1, [r0, #0]
 8001c4e:	688a      	ldr	r2, [r1, #8]
 8001c50:	f442 0200 	orr.w	r2, r2, #8388608	; 0x800000
 8001c54:	608a      	str	r2, [r1, #8]
    return HAL_OK;
 8001c56:	4618      	mov	r0, r3
 8001c58:	4770      	bx	lr
      if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 8001c5a:	6903      	ldr	r3, [r0, #16]
 8001c5c:	2b00      	cmp	r3, #0
 8001c5e:	d1f0      	bne.n	8001c42 <HAL_UART_Transmit_IT+0x66>
        huart->TxISR = UART_TxISR_16BIT_FIFOEN;
 8001c60:	4b0a      	ldr	r3, [pc, #40]	; (8001c8c <HAL_UART_Transmit_IT+0xb0>)
 8001c62:	6703      	str	r3, [r0, #112]	; 0x70
 8001c64:	e7ef      	b.n	8001c46 <HAL_UART_Transmit_IT+0x6a>
      if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 8001c66:	6903      	ldr	r3, [r0, #16]
 8001c68:	2b00      	cmp	r3, #0
 8001c6a:	d1da      	bne.n	8001c22 <HAL_UART_Transmit_IT+0x46>
        huart->TxISR = UART_TxISR_16BIT;
 8001c6c:	4b08      	ldr	r3, [pc, #32]	; (8001c90 <HAL_UART_Transmit_IT+0xb4>)
 8001c6e:	6703      	str	r3, [r0, #112]	; 0x70
 8001c70:	e7d9      	b.n	8001c26 <HAL_UART_Transmit_IT+0x4a>
    return HAL_BUSY;
 8001c72:	2002      	movs	r0, #2
 8001c74:	4770      	bx	lr
      return HAL_ERROR;
 8001c76:	2001      	movs	r0, #1
 8001c78:	4770      	bx	lr
 8001c7a:	2001      	movs	r0, #1
 8001c7c:	4770      	bx	lr
    __HAL_LOCK(huart);
 8001c7e:	2002      	movs	r0, #2
}
 8001c80:	4770      	bx	lr
 8001c82:	bf00      	nop
 8001c84:	08001a95 	.word	0x08001a95
 8001c88:	08001b21 	.word	0x08001b21
 8001c8c:	08001b7d 	.word	0x08001b7d
 8001c90:	08001ad9 	.word	0x08001ad9

08001c94 <osThreadFlagsSet>:
  }

  return (count);
}

uint32_t osThreadFlagsSet (osThreadId_t thread_id, uint32_t flags) {
 8001c94:	b530      	push	{r4, r5, lr}
 8001c96:	b085      	sub	sp, #20
  TaskHandle_t hTask = (TaskHandle_t)thread_id;
  uint32_t rflags;
  BaseType_t yield;

  if ((hTask == NULL) || ((flags & THREAD_FLAGS_INVALID_BITS) != 0U)) {
 8001c98:	b370      	cbz	r0, 8001cf8 <osThreadFlagsSet+0x64>
 8001c9a:	4605      	mov	r5, r0
 8001c9c:	2900      	cmp	r1, #0
 8001c9e:	db2b      	blt.n	8001cf8 <osThreadFlagsSet+0x64>
    rflags = (uint32_t)osErrorParameter;
  }
  else {
    rflags = (uint32_t)osError;
 8001ca0:	f04f 33ff 	mov.w	r3, #4294967295
 8001ca4:	9303      	str	r3, [sp, #12]
 */
__STATIC_FORCEINLINE uint32_t __get_IPSR(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 8001ca6:	f3ef 8305 	mrs	r3, IPSR

    if (IS_IRQ()) {
 8001caa:	b94b      	cbnz	r3, 8001cc0 <osThreadFlagsSet+0x2c>
 */
__STATIC_FORCEINLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8001cac:	f3ef 8310 	mrs	r3, PRIMASK
 8001cb0:	b933      	cbnz	r3, 8001cc0 <osThreadFlagsSet+0x2c>
 8001cb2:	4b1a      	ldr	r3, [pc, #104]	; (8001d1c <osThreadFlagsSet+0x88>)
 8001cb4:	681b      	ldr	r3, [r3, #0]
 8001cb6:	2b02      	cmp	r3, #2
 8001cb8:	d124      	bne.n	8001d04 <osThreadFlagsSet+0x70>
 */
__STATIC_FORCEINLINE uint32_t __get_BASEPRI(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8001cba:	f3ef 8311 	mrs	r3, BASEPRI
 8001cbe:	b30b      	cbz	r3, 8001d04 <osThreadFlagsSet+0x70>
      yield = pdFALSE;
 8001cc0:	2400      	movs	r4, #0
 8001cc2:	ab04      	add	r3, sp, #16
 8001cc4:	f843 4d08 	str.w	r4, [r3, #-8]!

      (void)xTaskNotifyFromISR (hTask, flags, eSetBits, &yield);
 8001cc8:	9300      	str	r3, [sp, #0]
 8001cca:	4623      	mov	r3, r4
 8001ccc:	2201      	movs	r2, #1
 8001cce:	4628      	mov	r0, r5
 8001cd0:	f000 fa74 	bl	80021bc <xTaskGenericNotifyFromISR>
      (void)xTaskNotifyAndQueryFromISR (hTask, 0, eNoAction, &rflags, NULL);
 8001cd4:	9400      	str	r4, [sp, #0]
 8001cd6:	ab03      	add	r3, sp, #12
 8001cd8:	4622      	mov	r2, r4
 8001cda:	4621      	mov	r1, r4
 8001cdc:	4628      	mov	r0, r5
 8001cde:	f000 fa6d 	bl	80021bc <xTaskGenericNotifyFromISR>

      portYIELD_FROM_ISR (yield);
 8001ce2:	9b02      	ldr	r3, [sp, #8]
 8001ce4:	b15b      	cbz	r3, 8001cfe <osThreadFlagsSet+0x6a>
 8001ce6:	4b0e      	ldr	r3, [pc, #56]	; (8001d20 <osThreadFlagsSet+0x8c>)
 8001ce8:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8001cec:	601a      	str	r2, [r3, #0]
 8001cee:	f3bf 8f4f 	dsb	sy
 8001cf2:	f3bf 8f6f 	isb	sy
 8001cf6:	e002      	b.n	8001cfe <osThreadFlagsSet+0x6a>
    rflags = (uint32_t)osErrorParameter;
 8001cf8:	f06f 0303 	mvn.w	r3, #3
 8001cfc:	9303      	str	r3, [sp, #12]
      (void)xTaskNotifyAndQuery (hTask, 0, eNoAction, &rflags);
    }
  }
  /* Return flags after setting */
  return (rflags);
}
 8001cfe:	9803      	ldr	r0, [sp, #12]
 8001d00:	b005      	add	sp, #20
 8001d02:	bd30      	pop	{r4, r5, pc}
      (void)xTaskNotify (hTask, flags, eSetBits);
 8001d04:	2300      	movs	r3, #0
 8001d06:	2201      	movs	r2, #1
 8001d08:	4628      	mov	r0, r5
 8001d0a:	f000 f9e5 	bl	80020d8 <xTaskGenericNotify>
      (void)xTaskNotifyAndQuery (hTask, 0, eNoAction, &rflags);
 8001d0e:	ab03      	add	r3, sp, #12
 8001d10:	2200      	movs	r2, #0
 8001d12:	4611      	mov	r1, r2
 8001d14:	4628      	mov	r0, r5
 8001d16:	f000 f9df 	bl	80020d8 <xTaskGenericNotify>
 8001d1a:	e7f0      	b.n	8001cfe <osThreadFlagsSet+0x6a>
 8001d1c:	20000030 	.word	0x20000030
 8001d20:	e000ed04 	.word	0xe000ed04

08001d24 <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
ListItem_t * const pxIndex = pxList->pxIndex;
 8001d24:	6843      	ldr	r3, [r0, #4]
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
 8001d26:	604b      	str	r3, [r1, #4]
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 8001d28:	689a      	ldr	r2, [r3, #8]
 8001d2a:	608a      	str	r2, [r1, #8]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
 8001d2c:	689a      	ldr	r2, [r3, #8]
 8001d2e:	6051      	str	r1, [r2, #4]
	pxIndex->pxPrevious = pxNewListItem;
 8001d30:	6099      	str	r1, [r3, #8]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 8001d32:	6108      	str	r0, [r1, #16]

	( pxList->uxNumberOfItems )++;
 8001d34:	6803      	ldr	r3, [r0, #0]
 8001d36:	3301      	adds	r3, #1
 8001d38:	6003      	str	r3, [r0, #0]
}
 8001d3a:	4770      	bx	lr

08001d3c <uxListRemove>:

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
 8001d3c:	6903      	ldr	r3, [r0, #16]

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 8001d3e:	6842      	ldr	r2, [r0, #4]
 8001d40:	6881      	ldr	r1, [r0, #8]
 8001d42:	6091      	str	r1, [r2, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 8001d44:	6882      	ldr	r2, [r0, #8]
 8001d46:	6841      	ldr	r1, [r0, #4]
 8001d48:	6051      	str	r1, [r2, #4]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 8001d4a:	685a      	ldr	r2, [r3, #4]
 8001d4c:	4282      	cmp	r2, r0
 8001d4e:	d006      	beq.n	8001d5e <uxListRemove+0x22>
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
 8001d50:	2200      	movs	r2, #0
 8001d52:	6102      	str	r2, [r0, #16]
	( pxList->uxNumberOfItems )--;
 8001d54:	681a      	ldr	r2, [r3, #0]
 8001d56:	3a01      	subs	r2, #1
 8001d58:	601a      	str	r2, [r3, #0]

	return pxList->uxNumberOfItems;
 8001d5a:	6818      	ldr	r0, [r3, #0]
}
 8001d5c:	4770      	bx	lr
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 8001d5e:	6882      	ldr	r2, [r0, #8]
 8001d60:	605a      	str	r2, [r3, #4]
 8001d62:	e7f5      	b.n	8001d50 <uxListRemove+0x14>
	...

08001d70 <SVC_Handler>:
}
/*-----------------------------------------------------------*/

void vPortSVCHandler( void )
{
	__asm volatile (
 8001d70:	4b07      	ldr	r3, [pc, #28]	; (8001d90 <pxCurrentTCBConst2>)
 8001d72:	6819      	ldr	r1, [r3, #0]
 8001d74:	6808      	ldr	r0, [r1, #0]
 8001d76:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8001d7a:	f380 8809 	msr	PSP, r0
 8001d7e:	f3bf 8f6f 	isb	sy
 8001d82:	f04f 0000 	mov.w	r0, #0
 8001d86:	f380 8811 	msr	BASEPRI, r0
 8001d8a:	4770      	bx	lr
 8001d8c:	f3af 8000 	nop.w

08001d90 <pxCurrentTCBConst2>:
 8001d90:	2000003c 	.word	0x2000003c

08001d94 <vPortEnterCritical>:

portFORCE_INLINE static void vPortRaiseBASEPRI( void )
{
uint32_t ulNewBASEPRI;

	__asm volatile
 8001d94:	f04f 0350 	mov.w	r3, #80	; 0x50
 8001d98:	f383 8811 	msr	BASEPRI, r3
 8001d9c:	f3bf 8f6f 	isb	sy
 8001da0:	f3bf 8f4f 	dsb	sy
/*-----------------------------------------------------------*/

void vPortEnterCritical( void )
{
	portDISABLE_INTERRUPTS();
	uxCriticalNesting++;
 8001da4:	4a0a      	ldr	r2, [pc, #40]	; (8001dd0 <vPortEnterCritical+0x3c>)
 8001da6:	6813      	ldr	r3, [r2, #0]
 8001da8:	3301      	adds	r3, #1
 8001daa:	6013      	str	r3, [r2, #0]
	/* This is not the interrupt safe version of the enter critical function so
	assert() if it is being called from an interrupt context.  Only API
	functions that end in "FromISR" can be used in an interrupt.  Only assert if
	the critical nesting count is 1 to protect against recursive calls if the
	assert function also uses a critical section. */
	if( uxCriticalNesting == 1 )
 8001dac:	2b01      	cmp	r3, #1
 8001dae:	d000      	beq.n	8001db2 <vPortEnterCritical+0x1e>
	{
		configASSERT( ( portNVIC_INT_CTRL_REG & portVECTACTIVE_MASK ) == 0 );
	}
}
 8001db0:	4770      	bx	lr
		configASSERT( ( portNVIC_INT_CTRL_REG & portVECTACTIVE_MASK ) == 0 );
 8001db2:	4b08      	ldr	r3, [pc, #32]	; (8001dd4 <vPortEnterCritical+0x40>)
 8001db4:	681b      	ldr	r3, [r3, #0]
 8001db6:	f013 0fff 	tst.w	r3, #255	; 0xff
 8001dba:	d0f9      	beq.n	8001db0 <vPortEnterCritical+0x1c>
 8001dbc:	f04f 0350 	mov.w	r3, #80	; 0x50
 8001dc0:	f383 8811 	msr	BASEPRI, r3
 8001dc4:	f3bf 8f6f 	isb	sy
 8001dc8:	f3bf 8f4f 	dsb	sy
 8001dcc:	e7fe      	b.n	8001dcc <vPortEnterCritical+0x38>
 8001dce:	bf00      	nop
 8001dd0:	20000010 	.word	0x20000010
 8001dd4:	e000ed04 	.word	0xe000ed04

08001dd8 <vPortExitCritical>:
/*-----------------------------------------------------------*/

void vPortExitCritical( void )
{
	configASSERT( uxCriticalNesting );
 8001dd8:	4b09      	ldr	r3, [pc, #36]	; (8001e00 <vPortExitCritical+0x28>)
 8001dda:	681b      	ldr	r3, [r3, #0]
 8001ddc:	b943      	cbnz	r3, 8001df0 <vPortExitCritical+0x18>
 8001dde:	f04f 0350 	mov.w	r3, #80	; 0x50
 8001de2:	f383 8811 	msr	BASEPRI, r3
 8001de6:	f3bf 8f6f 	isb	sy
 8001dea:	f3bf 8f4f 	dsb	sy
 8001dee:	e7fe      	b.n	8001dee <vPortExitCritical+0x16>
	uxCriticalNesting--;
 8001df0:	3b01      	subs	r3, #1
 8001df2:	4a03      	ldr	r2, [pc, #12]	; (8001e00 <vPortExitCritical+0x28>)
 8001df4:	6013      	str	r3, [r2, #0]
	if( uxCriticalNesting == 0 )
 8001df6:	b90b      	cbnz	r3, 8001dfc <vPortExitCritical+0x24>
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
{
	__asm volatile
 8001df8:	f383 8811 	msr	BASEPRI, r3
	{
		portENABLE_INTERRUPTS();
	}
}
 8001dfc:	4770      	bx	lr
 8001dfe:	bf00      	nop
 8001e00:	20000010 	.word	0x20000010
	...

08001e10 <PendSV_Handler>:

void xPortPendSVHandler( void )
{
	/* This is a naked function. */

	__asm volatile
 8001e10:	f3ef 8009 	mrs	r0, PSP
 8001e14:	f3bf 8f6f 	isb	sy
 8001e18:	4b15      	ldr	r3, [pc, #84]	; (8001e70 <pxCurrentTCBConst>)
 8001e1a:	681a      	ldr	r2, [r3, #0]
 8001e1c:	f01e 0f10 	tst.w	lr, #16
 8001e20:	bf08      	it	eq
 8001e22:	ed20 8a10 	vstmdbeq	r0!, {s16-s31}
 8001e26:	e920 4ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8001e2a:	6010      	str	r0, [r2, #0]
 8001e2c:	e92d 0009 	stmdb	sp!, {r0, r3}
 8001e30:	f04f 0050 	mov.w	r0, #80	; 0x50
 8001e34:	f380 8811 	msr	BASEPRI, r0
 8001e38:	f3bf 8f4f 	dsb	sy
 8001e3c:	f3bf 8f6f 	isb	sy
 8001e40:	f000 f8fe 	bl	8002040 <vTaskSwitchContext>
 8001e44:	f04f 0000 	mov.w	r0, #0
 8001e48:	f380 8811 	msr	BASEPRI, r0
 8001e4c:	bc09      	pop	{r0, r3}
 8001e4e:	6819      	ldr	r1, [r3, #0]
 8001e50:	6808      	ldr	r0, [r1, #0]
 8001e52:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8001e56:	f01e 0f10 	tst.w	lr, #16
 8001e5a:	bf08      	it	eq
 8001e5c:	ecb0 8a10 	vldmiaeq	r0!, {s16-s31}
 8001e60:	f380 8809 	msr	PSP, r0
 8001e64:	f3bf 8f6f 	isb	sy
 8001e68:	4770      	bx	lr
 8001e6a:	bf00      	nop
 8001e6c:	f3af 8000 	nop.w

08001e70 <pxCurrentTCBConst>:
 8001e70:	2000003c 	.word	0x2000003c

08001e74 <SysTick_Handler>:
	);
}
/*-----------------------------------------------------------*/

void xPortSysTickHandler( void )
{
 8001e74:	b508      	push	{r3, lr}
	__asm volatile
 8001e76:	f04f 0350 	mov.w	r3, #80	; 0x50
 8001e7a:	f383 8811 	msr	BASEPRI, r3
 8001e7e:	f3bf 8f6f 	isb	sy
 8001e82:	f3bf 8f4f 	dsb	sy
	save and then restore the interrupt mask value as its value is already
	known. */
	portDISABLE_INTERRUPTS();
	{
		/* Increment the RTOS tick. */
		if( xTaskIncrementTick() != pdFALSE )
 8001e86:	f000 f84f 	bl	8001f28 <xTaskIncrementTick>
 8001e8a:	b118      	cbz	r0, 8001e94 <SysTick_Handler+0x20>
		{
			/* A context switch is required.  Context switching is performed in
			the PendSV interrupt.  Pend the PendSV interrupt. */
			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
 8001e8c:	4b03      	ldr	r3, [pc, #12]	; (8001e9c <SysTick_Handler+0x28>)
 8001e8e:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8001e92:	601a      	str	r2, [r3, #0]
	__asm volatile
 8001e94:	2300      	movs	r3, #0
 8001e96:	f383 8811 	msr	BASEPRI, r3
		}
	}
	portENABLE_INTERRUPTS();
}
 8001e9a:	bd08      	pop	{r3, pc}
 8001e9c:	e000ed04 	.word	0xe000ed04

08001ea0 <vPortValidateInterruptPriority>:
	{
	uint32_t ulCurrentInterrupt;
	uint8_t ucCurrentPriority;

		/* Obtain the number of the currently executing interrupt. */
		__asm volatile( "mrs %0, ipsr" : "=r"( ulCurrentInterrupt ) :: "memory" );
 8001ea0:	f3ef 8305 	mrs	r3, IPSR

		/* Is the interrupt number a user defined interrupt? */
		if( ulCurrentInterrupt >= portFIRST_USER_INTERRUPT_NUMBER )
 8001ea4:	2b0f      	cmp	r3, #15
 8001ea6:	d90f      	bls.n	8001ec8 <vPortValidateInterruptPriority+0x28>
		{
			/* Look up the interrupt's priority. */
			ucCurrentPriority = pcInterruptPriorityRegisters[ ulCurrentInterrupt ];
 8001ea8:	4a10      	ldr	r2, [pc, #64]	; (8001eec <vPortValidateInterruptPriority+0x4c>)
 8001eaa:	5c9b      	ldrb	r3, [r3, r2]
 8001eac:	b2db      	uxtb	r3, r3
			interrupt entry is as fast and simple as possible.

			The following links provide detailed information:
			http://www.freertos.org/RTOS-Cortex-M3-M4.html
			http://www.freertos.org/FAQHelp.html */
			configASSERT( ucCurrentPriority >= ucMaxSysCallPriority );
 8001eae:	4a10      	ldr	r2, [pc, #64]	; (8001ef0 <vPortValidateInterruptPriority+0x50>)
 8001eb0:	7812      	ldrb	r2, [r2, #0]
 8001eb2:	429a      	cmp	r2, r3
 8001eb4:	d908      	bls.n	8001ec8 <vPortValidateInterruptPriority+0x28>
	__asm volatile
 8001eb6:	f04f 0350 	mov.w	r3, #80	; 0x50
 8001eba:	f383 8811 	msr	BASEPRI, r3
 8001ebe:	f3bf 8f6f 	isb	sy
 8001ec2:	f3bf 8f4f 	dsb	sy
 8001ec6:	e7fe      	b.n	8001ec6 <vPortValidateInterruptPriority+0x26>
		configuration then the correct setting can be achieved on all Cortex-M
		devices by calling NVIC_SetPriorityGrouping( 0 ); before starting the
		scheduler.  Note however that some vendor specific peripheral libraries
		assume a non-zero priority group setting, in which cases using a value
		of zero will result in unpredictable behaviour. */
		configASSERT( ( portAIRCR_REG & portPRIORITY_GROUP_MASK ) <= ulMaxPRIGROUPValue );
 8001ec8:	4b0a      	ldr	r3, [pc, #40]	; (8001ef4 <vPortValidateInterruptPriority+0x54>)
 8001eca:	681b      	ldr	r3, [r3, #0]
 8001ecc:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 8001ed0:	4a09      	ldr	r2, [pc, #36]	; (8001ef8 <vPortValidateInterruptPriority+0x58>)
 8001ed2:	6812      	ldr	r2, [r2, #0]
 8001ed4:	4293      	cmp	r3, r2
 8001ed6:	d908      	bls.n	8001eea <vPortValidateInterruptPriority+0x4a>
 8001ed8:	f04f 0350 	mov.w	r3, #80	; 0x50
 8001edc:	f383 8811 	msr	BASEPRI, r3
 8001ee0:	f3bf 8f6f 	isb	sy
 8001ee4:	f3bf 8f4f 	dsb	sy
 8001ee8:	e7fe      	b.n	8001ee8 <vPortValidateInterruptPriority+0x48>
	}
 8001eea:	4770      	bx	lr
 8001eec:	e000e3f0 	.word	0xe000e3f0
 8001ef0:	20000034 	.word	0x20000034
 8001ef4:	e000ed0c 	.word	0xe000ed0c
 8001ef8:	20000038 	.word	0x20000038

08001efc <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 8001efc:	4b08      	ldr	r3, [pc, #32]	; (8001f20 <prvResetNextTaskUnblockTime+0x24>)
 8001efe:	681b      	ldr	r3, [r3, #0]
 8001f00:	681b      	ldr	r3, [r3, #0]
 8001f02:	b13b      	cbz	r3, 8001f14 <prvResetNextTaskUnblockTime+0x18>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 8001f04:	4b06      	ldr	r3, [pc, #24]	; (8001f20 <prvResetNextTaskUnblockTime+0x24>)
 8001f06:	681b      	ldr	r3, [r3, #0]
 8001f08:	68db      	ldr	r3, [r3, #12]
 8001f0a:	68db      	ldr	r3, [r3, #12]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
 8001f0c:	685a      	ldr	r2, [r3, #4]
 8001f0e:	4b05      	ldr	r3, [pc, #20]	; (8001f24 <prvResetNextTaskUnblockTime+0x28>)
 8001f10:	601a      	str	r2, [r3, #0]
	}
}
 8001f12:	4770      	bx	lr
		xNextTaskUnblockTime = portMAX_DELAY;
 8001f14:	4b03      	ldr	r3, [pc, #12]	; (8001f24 <prvResetNextTaskUnblockTime+0x28>)
 8001f16:	f04f 32ff 	mov.w	r2, #4294967295
 8001f1a:	601a      	str	r2, [r3, #0]
 8001f1c:	4770      	bx	lr
 8001f1e:	bf00      	nop
 8001f20:	20000040 	.word	0x20000040
 8001f24:	200004b4 	.word	0x200004b4

08001f28 <xTaskIncrementTick>:
{
 8001f28:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8001f2a:	4b3a      	ldr	r3, [pc, #232]	; (8002014 <xTaskIncrementTick+0xec>)
 8001f2c:	681b      	ldr	r3, [r3, #0]
 8001f2e:	2b00      	cmp	r3, #0
 8001f30:	d164      	bne.n	8001ffc <xTaskIncrementTick+0xd4>
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
 8001f32:	4b39      	ldr	r3, [pc, #228]	; (8002018 <xTaskIncrementTick+0xf0>)
 8001f34:	681d      	ldr	r5, [r3, #0]
 8001f36:	3501      	adds	r5, #1
		xTickCount = xConstTickCount;
 8001f38:	601d      	str	r5, [r3, #0]
		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
 8001f3a:	b9c5      	cbnz	r5, 8001f6e <xTaskIncrementTick+0x46>
			taskSWITCH_DELAYED_LISTS();
 8001f3c:	4b37      	ldr	r3, [pc, #220]	; (800201c <xTaskIncrementTick+0xf4>)
 8001f3e:	681b      	ldr	r3, [r3, #0]
 8001f40:	681b      	ldr	r3, [r3, #0]
 8001f42:	b143      	cbz	r3, 8001f56 <xTaskIncrementTick+0x2e>
 8001f44:	f04f 0350 	mov.w	r3, #80	; 0x50
 8001f48:	f383 8811 	msr	BASEPRI, r3
 8001f4c:	f3bf 8f6f 	isb	sy
 8001f50:	f3bf 8f4f 	dsb	sy
 8001f54:	e7fe      	b.n	8001f54 <xTaskIncrementTick+0x2c>
 8001f56:	4a31      	ldr	r2, [pc, #196]	; (800201c <xTaskIncrementTick+0xf4>)
 8001f58:	6811      	ldr	r1, [r2, #0]
 8001f5a:	4b31      	ldr	r3, [pc, #196]	; (8002020 <xTaskIncrementTick+0xf8>)
 8001f5c:	6818      	ldr	r0, [r3, #0]
 8001f5e:	6010      	str	r0, [r2, #0]
 8001f60:	6019      	str	r1, [r3, #0]
 8001f62:	4a30      	ldr	r2, [pc, #192]	; (8002024 <xTaskIncrementTick+0xfc>)
 8001f64:	6813      	ldr	r3, [r2, #0]
 8001f66:	3301      	adds	r3, #1
 8001f68:	6013      	str	r3, [r2, #0]
 8001f6a:	f7ff ffc7 	bl	8001efc <prvResetNextTaskUnblockTime>
		if( xConstTickCount >= xNextTaskUnblockTime )
 8001f6e:	4b2e      	ldr	r3, [pc, #184]	; (8002028 <xTaskIncrementTick+0x100>)
 8001f70:	681b      	ldr	r3, [r3, #0]
 8001f72:	42ab      	cmp	r3, r5
 8001f74:	d938      	bls.n	8001fe8 <xTaskIncrementTick+0xc0>
BaseType_t xSwitchRequired = pdFALSE;
 8001f76:	2400      	movs	r4, #0
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
 8001f78:	4b2c      	ldr	r3, [pc, #176]	; (800202c <xTaskIncrementTick+0x104>)
 8001f7a:	681b      	ldr	r3, [r3, #0]
 8001f7c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8001f7e:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8001f82:	009a      	lsls	r2, r3, #2
 8001f84:	4b2a      	ldr	r3, [pc, #168]	; (8002030 <xTaskIncrementTick+0x108>)
 8001f86:	589b      	ldr	r3, [r3, r2]
 8001f88:	2b01      	cmp	r3, #1
 8001f8a:	d93c      	bls.n	8002006 <xTaskIncrementTick+0xde>
				xSwitchRequired = pdTRUE;
 8001f8c:	2401      	movs	r4, #1
 8001f8e:	e03a      	b.n	8002006 <xTaskIncrementTick+0xde>
							xSwitchRequired = pdTRUE;
 8001f90:	2401      	movs	r4, #1
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 8001f92:	4b22      	ldr	r3, [pc, #136]	; (800201c <xTaskIncrementTick+0xf4>)
 8001f94:	681b      	ldr	r3, [r3, #0]
 8001f96:	681b      	ldr	r3, [r3, #0]
 8001f98:	b343      	cbz	r3, 8001fec <xTaskIncrementTick+0xc4>
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 8001f9a:	4b20      	ldr	r3, [pc, #128]	; (800201c <xTaskIncrementTick+0xf4>)
 8001f9c:	681b      	ldr	r3, [r3, #0]
 8001f9e:	68db      	ldr	r3, [r3, #12]
 8001fa0:	68de      	ldr	r6, [r3, #12]
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
 8001fa2:	6873      	ldr	r3, [r6, #4]
					if( xConstTickCount < xItemValue )
 8001fa4:	429d      	cmp	r5, r3
 8001fa6:	d326      	bcc.n	8001ff6 <xTaskIncrementTick+0xce>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8001fa8:	1d37      	adds	r7, r6, #4
 8001faa:	4638      	mov	r0, r7
 8001fac:	f7ff fec6 	bl	8001d3c <uxListRemove>
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 8001fb0:	6ab3      	ldr	r3, [r6, #40]	; 0x28
 8001fb2:	b11b      	cbz	r3, 8001fbc <xTaskIncrementTick+0x94>
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 8001fb4:	f106 0018 	add.w	r0, r6, #24
 8001fb8:	f7ff fec0 	bl	8001d3c <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 8001fbc:	6af3      	ldr	r3, [r6, #44]	; 0x2c
 8001fbe:	4a1d      	ldr	r2, [pc, #116]	; (8002034 <xTaskIncrementTick+0x10c>)
 8001fc0:	6812      	ldr	r2, [r2, #0]
 8001fc2:	4293      	cmp	r3, r2
 8001fc4:	d901      	bls.n	8001fca <xTaskIncrementTick+0xa2>
 8001fc6:	4a1b      	ldr	r2, [pc, #108]	; (8002034 <xTaskIncrementTick+0x10c>)
 8001fc8:	6013      	str	r3, [r2, #0]
 8001fca:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8001fce:	009a      	lsls	r2, r3, #2
 8001fd0:	4639      	mov	r1, r7
 8001fd2:	4817      	ldr	r0, [pc, #92]	; (8002030 <xTaskIncrementTick+0x108>)
 8001fd4:	4410      	add	r0, r2
 8001fd6:	f7ff fea5 	bl	8001d24 <vListInsertEnd>
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 8001fda:	6af2      	ldr	r2, [r6, #44]	; 0x2c
 8001fdc:	4b13      	ldr	r3, [pc, #76]	; (800202c <xTaskIncrementTick+0x104>)
 8001fde:	681b      	ldr	r3, [r3, #0]
 8001fe0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8001fe2:	429a      	cmp	r2, r3
 8001fe4:	d2d4      	bcs.n	8001f90 <xTaskIncrementTick+0x68>
 8001fe6:	e7d4      	b.n	8001f92 <xTaskIncrementTick+0x6a>
BaseType_t xSwitchRequired = pdFALSE;
 8001fe8:	2400      	movs	r4, #0
 8001fea:	e7d2      	b.n	8001f92 <xTaskIncrementTick+0x6a>
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8001fec:	4b0e      	ldr	r3, [pc, #56]	; (8002028 <xTaskIncrementTick+0x100>)
 8001fee:	f04f 32ff 	mov.w	r2, #4294967295
 8001ff2:	601a      	str	r2, [r3, #0]
					break;
 8001ff4:	e7c0      	b.n	8001f78 <xTaskIncrementTick+0x50>
						xNextTaskUnblockTime = xItemValue;
 8001ff6:	4a0c      	ldr	r2, [pc, #48]	; (8002028 <xTaskIncrementTick+0x100>)
 8001ff8:	6013      	str	r3, [r2, #0]
						break;
 8001ffa:	e7bd      	b.n	8001f78 <xTaskIncrementTick+0x50>
		++uxPendedTicks;
 8001ffc:	4a0e      	ldr	r2, [pc, #56]	; (8002038 <xTaskIncrementTick+0x110>)
 8001ffe:	6813      	ldr	r3, [r2, #0]
 8002000:	3301      	adds	r3, #1
 8002002:	6013      	str	r3, [r2, #0]
BaseType_t xSwitchRequired = pdFALSE;
 8002004:	2400      	movs	r4, #0
		if( xYieldPending != pdFALSE )
 8002006:	4b0d      	ldr	r3, [pc, #52]	; (800203c <xTaskIncrementTick+0x114>)
 8002008:	681b      	ldr	r3, [r3, #0]
 800200a:	b103      	cbz	r3, 800200e <xTaskIncrementTick+0xe6>
			xSwitchRequired = pdTRUE;
 800200c:	2401      	movs	r4, #1
}
 800200e:	4620      	mov	r0, r4
 8002010:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8002012:	bf00      	nop
 8002014:	200004ac 	.word	0x200004ac
 8002018:	200004d0 	.word	0x200004d0
 800201c:	20000040 	.word	0x20000040
 8002020:	20000044 	.word	0x20000044
 8002024:	200004b8 	.word	0x200004b8
 8002028:	200004b4 	.word	0x200004b4
 800202c:	2000003c 	.word	0x2000003c
 8002030:	20000048 	.word	0x20000048
 8002034:	200004b0 	.word	0x200004b0
 8002038:	200004a8 	.word	0x200004a8
 800203c:	200004d4 	.word	0x200004d4

08002040 <vTaskSwitchContext>:
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 8002040:	4b20      	ldr	r3, [pc, #128]	; (80020c4 <vTaskSwitchContext+0x84>)
 8002042:	681b      	ldr	r3, [r3, #0]
 8002044:	b11b      	cbz	r3, 800204e <vTaskSwitchContext+0xe>
		xYieldPending = pdTRUE;
 8002046:	4b20      	ldr	r3, [pc, #128]	; (80020c8 <vTaskSwitchContext+0x88>)
 8002048:	2201      	movs	r2, #1
 800204a:	601a      	str	r2, [r3, #0]
 800204c:	4770      	bx	lr
		xYieldPending = pdFALSE;
 800204e:	4b1e      	ldr	r3, [pc, #120]	; (80020c8 <vTaskSwitchContext+0x88>)
 8002050:	2200      	movs	r2, #0
 8002052:	601a      	str	r2, [r3, #0]
		taskSELECT_HIGHEST_PRIORITY_TASK();
 8002054:	4b1d      	ldr	r3, [pc, #116]	; (80020cc <vTaskSwitchContext+0x8c>)
 8002056:	681b      	ldr	r3, [r3, #0]
 8002058:	eb03 0183 	add.w	r1, r3, r3, lsl #2
 800205c:	008a      	lsls	r2, r1, #2
 800205e:	491c      	ldr	r1, [pc, #112]	; (80020d0 <vTaskSwitchContext+0x90>)
 8002060:	588a      	ldr	r2, [r1, r2]
 8002062:	b95a      	cbnz	r2, 800207c <vTaskSwitchContext+0x3c>
 8002064:	b10b      	cbz	r3, 800206a <vTaskSwitchContext+0x2a>
 8002066:	3b01      	subs	r3, #1
 8002068:	e7f6      	b.n	8002058 <vTaskSwitchContext+0x18>
 800206a:	f04f 0350 	mov.w	r3, #80	; 0x50
 800206e:	f383 8811 	msr	BASEPRI, r3
 8002072:	f3bf 8f6f 	isb	sy
 8002076:	f3bf 8f4f 	dsb	sy
 800207a:	e7fe      	b.n	800207a <vTaskSwitchContext+0x3a>
{
 800207c:	b410      	push	{r4}
		taskSELECT_HIGHEST_PRIORITY_TASK();
 800207e:	4608      	mov	r0, r1
 8002080:	009a      	lsls	r2, r3, #2
 8002082:	18d4      	adds	r4, r2, r3
 8002084:	00a1      	lsls	r1, r4, #2
 8002086:	4401      	add	r1, r0
 8002088:	684c      	ldr	r4, [r1, #4]
 800208a:	6864      	ldr	r4, [r4, #4]
 800208c:	604c      	str	r4, [r1, #4]
 800208e:	441a      	add	r2, r3
 8002090:	0091      	lsls	r1, r2, #2
 8002092:	3108      	adds	r1, #8
 8002094:	4408      	add	r0, r1
 8002096:	4284      	cmp	r4, r0
 8002098:	d00d      	beq.n	80020b6 <vTaskSwitchContext+0x76>
 800209a:	eb03 0283 	add.w	r2, r3, r3, lsl #2
 800209e:	0091      	lsls	r1, r2, #2
 80020a0:	4a0b      	ldr	r2, [pc, #44]	; (80020d0 <vTaskSwitchContext+0x90>)
 80020a2:	440a      	add	r2, r1
 80020a4:	6852      	ldr	r2, [r2, #4]
 80020a6:	68d1      	ldr	r1, [r2, #12]
 80020a8:	4a0a      	ldr	r2, [pc, #40]	; (80020d4 <vTaskSwitchContext+0x94>)
 80020aa:	6011      	str	r1, [r2, #0]
 80020ac:	4a07      	ldr	r2, [pc, #28]	; (80020cc <vTaskSwitchContext+0x8c>)
 80020ae:	6013      	str	r3, [r2, #0]
}
 80020b0:	f85d 4b04 	ldr.w	r4, [sp], #4
 80020b4:	4770      	bx	lr
		taskSELECT_HIGHEST_PRIORITY_TASK();
 80020b6:	6861      	ldr	r1, [r4, #4]
 80020b8:	4805      	ldr	r0, [pc, #20]	; (80020d0 <vTaskSwitchContext+0x90>)
 80020ba:	2214      	movs	r2, #20
 80020bc:	fb02 0203 	mla	r2, r2, r3, r0
 80020c0:	6051      	str	r1, [r2, #4]
 80020c2:	e7ea      	b.n	800209a <vTaskSwitchContext+0x5a>
 80020c4:	200004ac 	.word	0x200004ac
 80020c8:	200004d4 	.word	0x200004d4
 80020cc:	200004b0 	.word	0x200004b0
 80020d0:	20000048 	.word	0x20000048
 80020d4:	2000003c 	.word	0x2000003c

080020d8 <xTaskGenericNotify>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
 80020d8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	TCB_t * pxTCB;
	BaseType_t xReturn = pdPASS;
	uint8_t ucOriginalNotifyState;

		configASSERT( xTaskToNotify );
 80020da:	b940      	cbnz	r0, 80020ee <xTaskGenericNotify+0x16>
 80020dc:	f04f 0350 	mov.w	r3, #80	; 0x50
 80020e0:	f383 8811 	msr	BASEPRI, r3
 80020e4:	f3bf 8f6f 	isb	sy
 80020e8:	f3bf 8f4f 	dsb	sy
 80020ec:	e7fe      	b.n	80020ec <xTaskGenericNotify+0x14>
 80020ee:	4604      	mov	r4, r0
 80020f0:	461f      	mov	r7, r3
 80020f2:	4615      	mov	r5, r2
 80020f4:	460e      	mov	r6, r1
		pxTCB = ( TCB_t * ) xTaskToNotify;

		taskENTER_CRITICAL();
 80020f6:	f7ff fe4d 	bl	8001d94 <vPortEnterCritical>
		{
			if( pulPreviousNotificationValue != NULL )
 80020fa:	b10f      	cbz	r7, 8002100 <xTaskGenericNotify+0x28>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
 80020fc:	6d63      	ldr	r3, [r4, #84]	; 0x54
 80020fe:	603b      	str	r3, [r7, #0]
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
 8002100:	f894 3058 	ldrb.w	r3, [r4, #88]	; 0x58
 8002104:	b2db      	uxtb	r3, r3

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
 8002106:	2202      	movs	r2, #2
 8002108:	f884 2058 	strb.w	r2, [r4, #88]	; 0x58

			switch( eAction )
 800210c:	1e6a      	subs	r2, r5, #1
 800210e:	2a03      	cmp	r2, #3
 8002110:	d81a      	bhi.n	8002148 <xTaskGenericNotify+0x70>
 8002112:	e8df f002 	tbb	[pc, r2]
 8002116:	0c02      	.short	0x0c02
 8002118:	1411      	.short	0x1411
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
 800211a:	6d62      	ldr	r2, [r4, #84]	; 0x54
 800211c:	4316      	orrs	r6, r2
 800211e:	6566      	str	r6, [r4, #84]	; 0x54
	BaseType_t xReturn = pdPASS;
 8002120:	2501      	movs	r5, #1

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
 8002122:	2b01      	cmp	r3, #1
 8002124:	d014      	beq.n	8002150 <xTaskGenericNotify+0x78>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
 8002126:	f7ff fe57 	bl	8001dd8 <vPortExitCritical>

		return xReturn;
	}
 800212a:	4628      	mov	r0, r5
 800212c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
					( pxTCB->ulNotifiedValue )++;
 800212e:	6d62      	ldr	r2, [r4, #84]	; 0x54
 8002130:	3201      	adds	r2, #1
 8002132:	6562      	str	r2, [r4, #84]	; 0x54
	BaseType_t xReturn = pdPASS;
 8002134:	2501      	movs	r5, #1
					break;
 8002136:	e7f4      	b.n	8002122 <xTaskGenericNotify+0x4a>
					pxTCB->ulNotifiedValue = ulValue;
 8002138:	6566      	str	r6, [r4, #84]	; 0x54
	BaseType_t xReturn = pdPASS;
 800213a:	2501      	movs	r5, #1
					break;
 800213c:	e7f1      	b.n	8002122 <xTaskGenericNotify+0x4a>
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
 800213e:	2b02      	cmp	r3, #2
 8002140:	d004      	beq.n	800214c <xTaskGenericNotify+0x74>
						pxTCB->ulNotifiedValue = ulValue;
 8002142:	6566      	str	r6, [r4, #84]	; 0x54
	BaseType_t xReturn = pdPASS;
 8002144:	2501      	movs	r5, #1
 8002146:	e7ec      	b.n	8002122 <xTaskGenericNotify+0x4a>
 8002148:	2501      	movs	r5, #1
 800214a:	e7ea      	b.n	8002122 <xTaskGenericNotify+0x4a>
						xReturn = pdFAIL;
 800214c:	2500      	movs	r5, #0
 800214e:	e7e8      	b.n	8002122 <xTaskGenericNotify+0x4a>
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8002150:	1d26      	adds	r6, r4, #4
 8002152:	4630      	mov	r0, r6
 8002154:	f7ff fdf2 	bl	8001d3c <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
 8002158:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 800215a:	4a14      	ldr	r2, [pc, #80]	; (80021ac <xTaskGenericNotify+0xd4>)
 800215c:	6812      	ldr	r2, [r2, #0]
 800215e:	4293      	cmp	r3, r2
 8002160:	d901      	bls.n	8002166 <xTaskGenericNotify+0x8e>
 8002162:	4a12      	ldr	r2, [pc, #72]	; (80021ac <xTaskGenericNotify+0xd4>)
 8002164:	6013      	str	r3, [r2, #0]
 8002166:	4631      	mov	r1, r6
 8002168:	4a11      	ldr	r2, [pc, #68]	; (80021b0 <xTaskGenericNotify+0xd8>)
 800216a:	2014      	movs	r0, #20
 800216c:	fb00 2003 	mla	r0, r0, r3, r2
 8002170:	f7ff fdd8 	bl	8001d24 <vListInsertEnd>
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
 8002174:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8002176:	b143      	cbz	r3, 800218a <xTaskGenericNotify+0xb2>
 8002178:	f04f 0350 	mov.w	r3, #80	; 0x50
 800217c:	f383 8811 	msr	BASEPRI, r3
 8002180:	f3bf 8f6f 	isb	sy
 8002184:	f3bf 8f4f 	dsb	sy
 8002188:	e7fe      	b.n	8002188 <xTaskGenericNotify+0xb0>
					prvResetNextTaskUnblockTime();
 800218a:	f7ff feb7 	bl	8001efc <prvResetNextTaskUnblockTime>
				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 800218e:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8002190:	4b08      	ldr	r3, [pc, #32]	; (80021b4 <xTaskGenericNotify+0xdc>)
 8002192:	681b      	ldr	r3, [r3, #0]
 8002194:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8002196:	429a      	cmp	r2, r3
 8002198:	d9c5      	bls.n	8002126 <xTaskGenericNotify+0x4e>
					taskYIELD_IF_USING_PREEMPTION();
 800219a:	4b07      	ldr	r3, [pc, #28]	; (80021b8 <xTaskGenericNotify+0xe0>)
 800219c:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80021a0:	601a      	str	r2, [r3, #0]
 80021a2:	f3bf 8f4f 	dsb	sy
 80021a6:	f3bf 8f6f 	isb	sy
 80021aa:	e7bc      	b.n	8002126 <xTaskGenericNotify+0x4e>
 80021ac:	200004b0 	.word	0x200004b0
 80021b0:	20000048 	.word	0x20000048
 80021b4:	2000003c 	.word	0x2000003c
 80021b8:	e000ed04 	.word	0xe000ed04

080021bc <xTaskGenericNotifyFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
 80021bc:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80021c0:	9e08      	ldr	r6, [sp, #32]
	TCB_t * pxTCB;
	uint8_t ucOriginalNotifyState;
	BaseType_t xReturn = pdPASS;
	UBaseType_t uxSavedInterruptStatus;

		configASSERT( xTaskToNotify );
 80021c2:	b940      	cbnz	r0, 80021d6 <xTaskGenericNotifyFromISR+0x1a>
 80021c4:	f04f 0350 	mov.w	r3, #80	; 0x50
 80021c8:	f383 8811 	msr	BASEPRI, r3
 80021cc:	f3bf 8f6f 	isb	sy
 80021d0:	f3bf 8f4f 	dsb	sy
 80021d4:	e7fe      	b.n	80021d4 <xTaskGenericNotifyFromISR+0x18>
 80021d6:	4604      	mov	r4, r0
 80021d8:	4699      	mov	r9, r3
 80021da:	4615      	mov	r5, r2
 80021dc:	4688      	mov	r8, r1
		below the maximum system call interrupt priority.  FreeRTOS maintains a
		separate interrupt safe API to ensure interrupt entry is as fast and as
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 80021de:	f7ff fe5f 	bl	8001ea0 <vPortValidateInterruptPriority>
	__asm volatile
 80021e2:	f3ef 8711 	mrs	r7, BASEPRI
 80021e6:	f04f 0350 	mov.w	r3, #80	; 0x50
 80021ea:	f383 8811 	msr	BASEPRI, r3
 80021ee:	f3bf 8f6f 	isb	sy
 80021f2:	f3bf 8f4f 	dsb	sy

		pxTCB = ( TCB_t * ) xTaskToNotify;

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
		{
			if( pulPreviousNotificationValue != NULL )
 80021f6:	f1b9 0f00 	cmp.w	r9, #0
 80021fa:	d002      	beq.n	8002202 <xTaskGenericNotifyFromISR+0x46>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
 80021fc:	6d63      	ldr	r3, [r4, #84]	; 0x54
 80021fe:	f8c9 3000 	str.w	r3, [r9]
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
 8002202:	f894 3058 	ldrb.w	r3, [r4, #88]	; 0x58
 8002206:	b2db      	uxtb	r3, r3
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
 8002208:	2202      	movs	r2, #2
 800220a:	f884 2058 	strb.w	r2, [r4, #88]	; 0x58

			switch( eAction )
 800220e:	1e6a      	subs	r2, r5, #1
 8002210:	2a03      	cmp	r2, #3
 8002212:	d81e      	bhi.n	8002252 <xTaskGenericNotifyFromISR+0x96>
 8002214:	e8df f002 	tbb	[pc, r2]
 8002218:	17130e02 	.word	0x17130e02
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
 800221c:	6d62      	ldr	r2, [r4, #84]	; 0x54
 800221e:	ea42 0208 	orr.w	r2, r2, r8
 8002222:	6562      	str	r2, [r4, #84]	; 0x54
	BaseType_t xReturn = pdPASS;
 8002224:	2501      	movs	r5, #1

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
 8002226:	2b01      	cmp	r3, #1
 8002228:	d017      	beq.n	800225a <xTaskGenericNotifyFromISR+0x9e>
	__asm volatile
 800222a:	f387 8811 	msr	BASEPRI, r7
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xReturn;
	}
 800222e:	4628      	mov	r0, r5
 8002230:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
					( pxTCB->ulNotifiedValue )++;
 8002234:	6d62      	ldr	r2, [r4, #84]	; 0x54
 8002236:	3201      	adds	r2, #1
 8002238:	6562      	str	r2, [r4, #84]	; 0x54
	BaseType_t xReturn = pdPASS;
 800223a:	2501      	movs	r5, #1
					break;
 800223c:	e7f3      	b.n	8002226 <xTaskGenericNotifyFromISR+0x6a>
					pxTCB->ulNotifiedValue = ulValue;
 800223e:	f8c4 8054 	str.w	r8, [r4, #84]	; 0x54
	BaseType_t xReturn = pdPASS;
 8002242:	2501      	movs	r5, #1
					break;
 8002244:	e7ef      	b.n	8002226 <xTaskGenericNotifyFromISR+0x6a>
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
 8002246:	2b02      	cmp	r3, #2
 8002248:	d005      	beq.n	8002256 <xTaskGenericNotifyFromISR+0x9a>
						pxTCB->ulNotifiedValue = ulValue;
 800224a:	f8c4 8054 	str.w	r8, [r4, #84]	; 0x54
	BaseType_t xReturn = pdPASS;
 800224e:	2501      	movs	r5, #1
 8002250:	e7e9      	b.n	8002226 <xTaskGenericNotifyFromISR+0x6a>
 8002252:	2501      	movs	r5, #1
 8002254:	e7e7      	b.n	8002226 <xTaskGenericNotifyFromISR+0x6a>
						xReturn = pdFAIL;
 8002256:	2500      	movs	r5, #0
 8002258:	e7e5      	b.n	8002226 <xTaskGenericNotifyFromISR+0x6a>
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
 800225a:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 800225c:	b143      	cbz	r3, 8002270 <xTaskGenericNotifyFromISR+0xb4>
	__asm volatile
 800225e:	f04f 0350 	mov.w	r3, #80	; 0x50
 8002262:	f383 8811 	msr	BASEPRI, r3
 8002266:	f3bf 8f6f 	isb	sy
 800226a:	f3bf 8f4f 	dsb	sy
 800226e:	e7fe      	b.n	800226e <xTaskGenericNotifyFromISR+0xb2>
				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8002270:	4b14      	ldr	r3, [pc, #80]	; (80022c4 <xTaskGenericNotifyFromISR+0x108>)
 8002272:	681b      	ldr	r3, [r3, #0]
 8002274:	b9e3      	cbnz	r3, 80022b0 <xTaskGenericNotifyFromISR+0xf4>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8002276:	f104 0804 	add.w	r8, r4, #4
 800227a:	4640      	mov	r0, r8
 800227c:	f7ff fd5e 	bl	8001d3c <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 8002280:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8002282:	4a11      	ldr	r2, [pc, #68]	; (80022c8 <xTaskGenericNotifyFromISR+0x10c>)
 8002284:	6812      	ldr	r2, [r2, #0]
 8002286:	4293      	cmp	r3, r2
 8002288:	d901      	bls.n	800228e <xTaskGenericNotifyFromISR+0xd2>
 800228a:	4a0f      	ldr	r2, [pc, #60]	; (80022c8 <xTaskGenericNotifyFromISR+0x10c>)
 800228c:	6013      	str	r3, [r2, #0]
 800228e:	4641      	mov	r1, r8
 8002290:	4a0e      	ldr	r2, [pc, #56]	; (80022cc <xTaskGenericNotifyFromISR+0x110>)
 8002292:	2014      	movs	r0, #20
 8002294:	fb00 2003 	mla	r0, r0, r3, r2
 8002298:	f7ff fd44 	bl	8001d24 <vListInsertEnd>
				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 800229c:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 800229e:	4b0c      	ldr	r3, [pc, #48]	; (80022d0 <xTaskGenericNotifyFromISR+0x114>)
 80022a0:	681b      	ldr	r3, [r3, #0]
 80022a2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80022a4:	429a      	cmp	r2, r3
 80022a6:	d9c0      	bls.n	800222a <xTaskGenericNotifyFromISR+0x6e>
					if( pxHigherPriorityTaskWoken != NULL )
 80022a8:	b146      	cbz	r6, 80022bc <xTaskGenericNotifyFromISR+0x100>
						*pxHigherPriorityTaskWoken = pdTRUE;
 80022aa:	2301      	movs	r3, #1
 80022ac:	6033      	str	r3, [r6, #0]
 80022ae:	e7bc      	b.n	800222a <xTaskGenericNotifyFromISR+0x6e>
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 80022b0:	f104 0118 	add.w	r1, r4, #24
 80022b4:	4807      	ldr	r0, [pc, #28]	; (80022d4 <xTaskGenericNotifyFromISR+0x118>)
 80022b6:	f7ff fd35 	bl	8001d24 <vListInsertEnd>
 80022ba:	e7ef      	b.n	800229c <xTaskGenericNotifyFromISR+0xe0>
						xYieldPending = pdTRUE;
 80022bc:	4b06      	ldr	r3, [pc, #24]	; (80022d8 <xTaskGenericNotifyFromISR+0x11c>)
 80022be:	2201      	movs	r2, #1
 80022c0:	601a      	str	r2, [r3, #0]
 80022c2:	e7b2      	b.n	800222a <xTaskGenericNotifyFromISR+0x6e>
 80022c4:	200004ac 	.word	0x200004ac
 80022c8:	200004b0 	.word	0x200004b0
 80022cc:	20000048 	.word	0x20000048
 80022d0:	2000003c 	.word	0x2000003c
 80022d4:	200004bc 	.word	0x200004bc
 80022d8:	200004d4 	.word	0x200004d4

080022dc <LST_is_empty>:
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 80022dc:	f3ef 8310 	mrs	r3, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 80022e0:	b672      	cpsid	i
  uint32_t primask_bit;
  uint8_t return_value;

  primask_bit = __get_PRIMASK();  /**< backup PRIMASK bit */
  __disable_irq();                  /**< Disable all interrupts by setting PRIMASK bit on Cortex*/
  if(listHead->next == listHead)
 80022e2:	6802      	ldr	r2, [r0, #0]
 80022e4:	4282      	cmp	r2, r0
 80022e6:	d003      	beq.n	80022f0 <LST_is_empty+0x14>
  {
    return_value = TRUE;
  }
  else
  {
    return_value = FALSE;
 80022e8:	2000      	movs	r0, #0
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 80022ea:	f383 8810 	msr	PRIMASK, r3
  }
  __set_PRIMASK(primask_bit);     /**< Restore PRIMASK bit*/

  return return_value;
}
 80022ee:	4770      	bx	lr
    return_value = TRUE;
 80022f0:	2001      	movs	r0, #1
 80022f2:	e7fa      	b.n	80022ea <LST_is_empty+0xe>

080022f4 <LST_insert_tail>:
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 80022f4:	f3ef 8310 	mrs	r3, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 80022f8:	b672      	cpsid	i
  uint32_t primask_bit;

  primask_bit = __get_PRIMASK();  /**< backup PRIMASK bit */
  __disable_irq();                  /**< Disable all interrupts by setting PRIMASK bit on Cortex*/

  node->next = listHead;
 80022fa:	6008      	str	r0, [r1, #0]
  node->prev = listHead->prev;
 80022fc:	6842      	ldr	r2, [r0, #4]
 80022fe:	604a      	str	r2, [r1, #4]
  listHead->prev = node;
 8002300:	6041      	str	r1, [r0, #4]
  (node->prev)->next = node;
 8002302:	684a      	ldr	r2, [r1, #4]
 8002304:	6011      	str	r1, [r2, #0]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8002306:	f383 8810 	msr	PRIMASK, r3

  __set_PRIMASK(primask_bit);     /**< Restore PRIMASK bit*/
}
 800230a:	4770      	bx	lr

0800230c <LST_remove_node>:
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800230c:	f3ef 8310 	mrs	r3, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8002310:	b672      	cpsid	i
  uint32_t primask_bit;

  primask_bit = __get_PRIMASK();  /**< backup PRIMASK bit */
  __disable_irq();                  /**< Disable all interrupts by setting PRIMASK bit on Cortex*/

  (node->prev)->next = node->next;
 8002312:	6842      	ldr	r2, [r0, #4]
 8002314:	6801      	ldr	r1, [r0, #0]
 8002316:	6011      	str	r1, [r2, #0]
  (node->next)->prev = node->prev;
 8002318:	6802      	ldr	r2, [r0, #0]
 800231a:	6841      	ldr	r1, [r0, #4]
 800231c:	6051      	str	r1, [r2, #4]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800231e:	f383 8810 	msr	PRIMASK, r3

  __set_PRIMASK(primask_bit);     /**< Restore PRIMASK bit*/
}
 8002322:	4770      	bx	lr

08002324 <LST_remove_head>:


void LST_remove_head (tListNode * listHead, tListNode ** node )
{
 8002324:	b510      	push	{r4, lr}
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8002326:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 800232a:	b672      	cpsid	i
  uint32_t primask_bit;

  primask_bit = __get_PRIMASK();  /**< backup PRIMASK bit */
  __disable_irq();                  /**< Disable all interrupts by setting PRIMASK bit on Cortex*/

  *node = listHead->next;
 800232c:	6803      	ldr	r3, [r0, #0]
 800232e:	600b      	str	r3, [r1, #0]
  LST_remove_node (listHead->next);
 8002330:	6800      	ldr	r0, [r0, #0]
 8002332:	f7ff ffeb 	bl	800230c <LST_remove_node>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8002336:	f384 8810 	msr	PRIMASK, r4

  __set_PRIMASK(primask_bit);     /**< Restore PRIMASK bit*/
}
 800233a:	bd10      	pop	{r4, pc}

0800233c <SendFreeBuf>:

  return;
}

static void SendFreeBuf( void )
{
 800233c:	b500      	push	{lr}
 800233e:	b083      	sub	sp, #12
  tListNode *p_node;

  while ( FALSE == LST_is_empty (&LocalFreeBufQueue) )
 8002340:	e009      	b.n	8002356 <SendFreeBuf+0x1a>
  {
    LST_remove_head( &LocalFreeBufQueue, (tListNode **)&p_node );
 8002342:	a901      	add	r1, sp, #4
 8002344:	4808      	ldr	r0, [pc, #32]	; (8002368 <SendFreeBuf+0x2c>)
 8002346:	f7ff ffed 	bl	8002324 <LST_remove_head>
    LST_insert_tail( (tListNode*)(TL_RefTable.p_mem_manager_table->pevt_free_buffer_queue), p_node );
 800234a:	4b08      	ldr	r3, [pc, #32]	; (800236c <SendFreeBuf+0x30>)
 800234c:	691b      	ldr	r3, [r3, #16]
 800234e:	9901      	ldr	r1, [sp, #4]
 8002350:	6918      	ldr	r0, [r3, #16]
 8002352:	f7ff ffcf 	bl	80022f4 <LST_insert_tail>
  while ( FALSE == LST_is_empty (&LocalFreeBufQueue) )
 8002356:	4804      	ldr	r0, [pc, #16]	; (8002368 <SendFreeBuf+0x2c>)
 8002358:	f7ff ffc0 	bl	80022dc <LST_is_empty>
 800235c:	2800      	cmp	r0, #0
 800235e:	d0f0      	beq.n	8002342 <SendFreeBuf+0x6>
  }

  return;
}
 8002360:	b003      	add	sp, #12
 8002362:	f85d fb04 	ldr.w	pc, [sp], #4
 8002366:	bf00      	nop
 8002368:	200004e0 	.word	0x200004e0
 800236c:	20030000 	.word	0x20030000

08002370 <HW_IPCC_BLE_RxEvtNot>:
{
 8002370:	b500      	push	{lr}
 8002372:	b083      	sub	sp, #12
  while(LST_is_empty(&EvtQueue) == FALSE)
 8002374:	e007      	b.n	8002386 <HW_IPCC_BLE_RxEvtNot+0x16>
    LST_remove_head (&EvtQueue, (tListNode **)&phcievt);
 8002376:	a901      	add	r1, sp, #4
 8002378:	4807      	ldr	r0, [pc, #28]	; (8002398 <HW_IPCC_BLE_RxEvtNot+0x28>)
 800237a:	f7ff ffd3 	bl	8002324 <LST_remove_head>
    BLE_IoBusEvtCallBackFunction(phcievt);
 800237e:	4b07      	ldr	r3, [pc, #28]	; (800239c <HW_IPCC_BLE_RxEvtNot+0x2c>)
 8002380:	681b      	ldr	r3, [r3, #0]
 8002382:	9801      	ldr	r0, [sp, #4]
 8002384:	4798      	blx	r3
  while(LST_is_empty(&EvtQueue) == FALSE)
 8002386:	4804      	ldr	r0, [pc, #16]	; (8002398 <HW_IPCC_BLE_RxEvtNot+0x28>)
 8002388:	f7ff ffa8 	bl	80022dc <LST_is_empty>
 800238c:	2800      	cmp	r0, #0
 800238e:	d0f2      	beq.n	8002376 <HW_IPCC_BLE_RxEvtNot+0x6>
}
 8002390:	b003      	add	sp, #12
 8002392:	f85d fb04 	ldr.w	pc, [sp], #4
 8002396:	bf00      	nop
 8002398:	200300b8 	.word	0x200300b8
 800239c:	200004dc 	.word	0x200004dc

080023a0 <HW_IPCC_BLE_AclDataAckNot>:
{
 80023a0:	b508      	push	{r3, lr}
  BLE_IoBusAclDataTxAck( );
 80023a2:	4b02      	ldr	r3, [pc, #8]	; (80023ac <HW_IPCC_BLE_AclDataAckNot+0xc>)
 80023a4:	681b      	ldr	r3, [r3, #0]
 80023a6:	4798      	blx	r3
}
 80023a8:	bd08      	pop	{r3, pc}
 80023aa:	bf00      	nop
 80023ac:	200004d8 	.word	0x200004d8

080023b0 <HW_IPCC_SYS_CmdEvtNot>:
{
 80023b0:	b508      	push	{r3, lr}
  SYS_CMD_IoBusCallBackFunction( (TL_EvtPacket_t*)(TL_RefTable.p_sys_table->pcmd_buffer) );
 80023b2:	4b03      	ldr	r3, [pc, #12]	; (80023c0 <HW_IPCC_SYS_CmdEvtNot+0x10>)
 80023b4:	68da      	ldr	r2, [r3, #12]
 80023b6:	4b03      	ldr	r3, [pc, #12]	; (80023c4 <HW_IPCC_SYS_CmdEvtNot+0x14>)
 80023b8:	681b      	ldr	r3, [r3, #0]
 80023ba:	6810      	ldr	r0, [r2, #0]
 80023bc:	4798      	blx	r3
}
 80023be:	bd08      	pop	{r3, pc}
 80023c0:	20030000 	.word	0x20030000
 80023c4:	200004e8 	.word	0x200004e8

080023c8 <HW_IPCC_SYS_EvtNot>:
{
 80023c8:	b500      	push	{lr}
 80023ca:	b083      	sub	sp, #12
  while(LST_is_empty(&SystemEvtQueue) == FALSE)
 80023cc:	e007      	b.n	80023de <HW_IPCC_SYS_EvtNot+0x16>
    LST_remove_head (&SystemEvtQueue, (tListNode **)&p_evt);
 80023ce:	a901      	add	r1, sp, #4
 80023d0:	4807      	ldr	r0, [pc, #28]	; (80023f0 <HW_IPCC_SYS_EvtNot+0x28>)
 80023d2:	f7ff ffa7 	bl	8002324 <LST_remove_head>
    SYS_EVT_IoBusCallBackFunction( p_evt );
 80023d6:	4b07      	ldr	r3, [pc, #28]	; (80023f4 <HW_IPCC_SYS_EvtNot+0x2c>)
 80023d8:	681b      	ldr	r3, [r3, #0]
 80023da:	9801      	ldr	r0, [sp, #4]
 80023dc:	4798      	blx	r3
  while(LST_is_empty(&SystemEvtQueue) == FALSE)
 80023de:	4804      	ldr	r0, [pc, #16]	; (80023f0 <HW_IPCC_SYS_EvtNot+0x28>)
 80023e0:	f7ff ff7c 	bl	80022dc <LST_is_empty>
 80023e4:	2800      	cmp	r0, #0
 80023e6:	d0f2      	beq.n	80023ce <HW_IPCC_SYS_EvtNot+0x6>
}
 80023e8:	b003      	add	sp, #12
 80023ea:	f85d fb04 	ldr.w	pc, [sp], #4
 80023ee:	bf00      	nop
 80023f0:	200300d0 	.word	0x200300d0
 80023f4:	200004ec 	.word	0x200004ec

080023f8 <TL_THREAD_CliSendAck>:
{
 80023f8:	b508      	push	{r3, lr}
  ((TL_CmdPacket_t *)(TL_RefTable.p_thread_table->notack_buffer))->cmdserial.type = TL_OTACK_PKT_TYPE;
 80023fa:	4b04      	ldr	r3, [pc, #16]	; (800240c <TL_THREAD_CliSendAck+0x14>)
 80023fc:	689b      	ldr	r3, [r3, #8]
 80023fe:	681b      	ldr	r3, [r3, #0]
 8002400:	220d      	movs	r2, #13
 8002402:	721a      	strb	r2, [r3, #8]
  HW_IPCC_THREAD_CliSendAck();
 8002404:	f000 f8d0 	bl	80025a8 <HW_IPCC_THREAD_CliSendAck>
}
 8002408:	bd08      	pop	{r3, pc}
 800240a:	bf00      	nop
 800240c:	20030000 	.word	0x20030000

08002410 <HW_IPCC_OT_CmdEvtNot>:
{
 8002410:	b508      	push	{r3, lr}
  TL_OT_CmdEvtReceived( (TL_EvtPacket_t*)(TL_RefTable.p_thread_table->otcmdrsp_buffer) );
 8002412:	4b03      	ldr	r3, [pc, #12]	; (8002420 <HW_IPCC_OT_CmdEvtNot+0x10>)
 8002414:	689b      	ldr	r3, [r3, #8]
 8002416:	6898      	ldr	r0, [r3, #8]
 8002418:	f000 f858 	bl	80024cc <TL_OT_CmdEvtReceived>
}
 800241c:	bd08      	pop	{r3, pc}
 800241e:	bf00      	nop
 8002420:	20030000 	.word	0x20030000

08002424 <HW_IPCC_THREAD_EvtNot>:
{
 8002424:	b508      	push	{r3, lr}
  TL_THREAD_NotReceived( (TL_EvtPacket_t*)(TL_RefTable.p_thread_table->notack_buffer) );
 8002426:	4b03      	ldr	r3, [pc, #12]	; (8002434 <HW_IPCC_THREAD_EvtNot+0x10>)
 8002428:	689b      	ldr	r3, [r3, #8]
 800242a:	6818      	ldr	r0, [r3, #0]
 800242c:	f000 f852 	bl	80024d4 <TL_THREAD_NotReceived>
}
 8002430:	bd08      	pop	{r3, pc}
 8002432:	bf00      	nop
 8002434:	20030000 	.word	0x20030000

08002438 <HW_IPCC_THREAD_CliEvtNot>:
{
 8002438:	b508      	push	{r3, lr}
  TL_THREAD_CliNotReceived( (TL_EvtPacket_t*)(TL_RefTable.p_thread_table->clicmdrsp_buffer) );
 800243a:	4b03      	ldr	r3, [pc, #12]	; (8002448 <HW_IPCC_THREAD_CliEvtNot+0x10>)
 800243c:	689b      	ldr	r3, [r3, #8]
 800243e:	6858      	ldr	r0, [r3, #4]
 8002440:	f000 f850 	bl	80024e4 <TL_THREAD_CliNotReceived>
}
 8002444:	bd08      	pop	{r3, pc}
 8002446:	bf00      	nop
 8002448:	20030000 	.word	0x20030000

0800244c <TL_MM_EvtDone>:
{
 800244c:	b508      	push	{r3, lr}
  LST_insert_tail(&LocalFreeBufQueue, (tListNode *)phcievt);
 800244e:	4601      	mov	r1, r0
 8002450:	4803      	ldr	r0, [pc, #12]	; (8002460 <TL_MM_EvtDone+0x14>)
 8002452:	f7ff ff4f 	bl	80022f4 <LST_insert_tail>
  HW_IPCC_MM_SendFreeBuf( SendFreeBuf );
 8002456:	4803      	ldr	r0, [pc, #12]	; (8002464 <TL_MM_EvtDone+0x18>)
 8002458:	f000 f90e 	bl	8002678 <HW_IPCC_MM_SendFreeBuf>
}
 800245c:	bd08      	pop	{r3, pc}
 800245e:	bf00      	nop
 8002460:	200004e0 	.word	0x200004e0
 8002464:	0800233d 	.word	0x0800233d

08002468 <HW_IPCC_TRACES_EvtNot>:

  return;
}

void HW_IPCC_TRACES_EvtNot(void)
{
 8002468:	b500      	push	{lr}
 800246a:	b083      	sub	sp, #12
  TL_EvtPacket_t *phcievt;

  while(LST_is_empty(&TracesEvtQueue) == FALSE)
 800246c:	e006      	b.n	800247c <HW_IPCC_TRACES_EvtNot+0x14>
  {
    LST_remove_head (&TracesEvtQueue, (tListNode **)&phcievt);
 800246e:	a901      	add	r1, sp, #4
 8002470:	4806      	ldr	r0, [pc, #24]	; (800248c <HW_IPCC_TRACES_EvtNot+0x24>)
 8002472:	f7ff ff57 	bl	8002324 <LST_remove_head>
    TL_TRACES_EvtReceived( phcievt );
 8002476:	9801      	ldr	r0, [sp, #4]
 8002478:	f7fd fe8c 	bl	8000194 <TL_TRACES_EvtReceived>
  while(LST_is_empty(&TracesEvtQueue) == FALSE)
 800247c:	4803      	ldr	r0, [pc, #12]	; (800248c <HW_IPCC_TRACES_EvtNot+0x24>)
 800247e:	f7ff ff2d 	bl	80022dc <LST_is_empty>
 8002482:	2800      	cmp	r0, #0
 8002484:	d0f3      	beq.n	800246e <HW_IPCC_TRACES_EvtNot+0x6>
  }

  return;
}
 8002486:	b003      	add	sp, #12
 8002488:	f85d fb04 	ldr.w	pc, [sp], #4
 800248c:	200300b0 	.word	0x200300b0

08002490 <Receive_Ack_From_M0>:
  * @param  None
  * @retval None
  */
static void Receive_Ack_From_M0(void)
{
  FlagReceiveAckFromM0 = 1;
 8002490:	4b01      	ldr	r3, [pc, #4]	; (8002498 <Receive_Ack_From_M0+0x8>)
 8002492:	2201      	movs	r2, #1
 8002494:	601a      	str	r2, [r3, #0]
}
 8002496:	4770      	bx	lr
 8002498:	200004f4 	.word	0x200004f4

0800249c <Receive_Notification_From_M0>:
  *         This function is called under interrupt.
  * @param  None
  * @retval None
  */
static void Receive_Notification_From_M0(void)
{
 800249c:	b508      	push	{r3, lr}
  CptReceiveMsgFromM0++;
 800249e:	4a05      	ldr	r2, [pc, #20]	; (80024b4 <Receive_Notification_From_M0+0x18>)
 80024a0:	6813      	ldr	r3, [r2, #0]
 80024a2:	3301      	adds	r3, #1
 80024a4:	6013      	str	r3, [r2, #0]
  osThreadFlagsSet(OsTaskMsgM0ToM4Id,1);
 80024a6:	2101      	movs	r1, #1
 80024a8:	4b03      	ldr	r3, [pc, #12]	; (80024b8 <Receive_Notification_From_M0+0x1c>)
 80024aa:	6818      	ldr	r0, [r3, #0]
 80024ac:	f7ff fbf2 	bl	8001c94 <osThreadFlagsSet>
}
 80024b0:	bd08      	pop	{r3, pc}
 80024b2:	bf00      	nop
 80024b4:	200004f0 	.word	0x200004f0
 80024b8:	200004f8 	.word	0x200004f8

080024bc <Send_CLI_Ack_For_OT>:
 * @brief Send notification for CLI TL Channel.
 * @param  None
 * @retval None
 */
static void Send_CLI_Ack_For_OT(void)
{
 80024bc:	b508      	push	{r3, lr}

  /* Notify M0 that characters have been sent to UART */
  TL_THREAD_CliSendAck();
 80024be:	f7ff ff9b 	bl	80023f8 <TL_THREAD_CliSendAck>
}
 80024c2:	bd08      	pop	{r3, pc}

080024c4 <HostTxCb>:
 *
 * @param   Notbuffer : a pointer to TL_EvtPacket_t
 * @return  None
 */
void HostTxCb(void)
{
 80024c4:	b508      	push	{r3, lr}
  Send_CLI_Ack_For_OT();
 80024c6:	f7ff fff9 	bl	80024bc <Send_CLI_Ack_For_OT>
}
 80024ca:	bd08      	pop	{r3, pc}

080024cc <TL_OT_CmdEvtReceived>:
{
 80024cc:	b508      	push	{r3, lr}
  Receive_Ack_From_M0();
 80024ce:	f7ff ffdf 	bl	8002490 <Receive_Ack_From_M0>
}
 80024d2:	bd08      	pop	{r3, pc}

080024d4 <TL_THREAD_NotReceived>:
{
 80024d4:	b508      	push	{r3, lr}
  p_thread_notif_M0_to_M4 = Notbuffer;
 80024d6:	4b02      	ldr	r3, [pc, #8]	; (80024e0 <TL_THREAD_NotReceived+0xc>)
 80024d8:	6018      	str	r0, [r3, #0]
  Receive_Notification_From_M0();
 80024da:	f7ff ffdf 	bl	800249c <Receive_Notification_From_M0>
}
 80024de:	bd08      	pop	{r3, pc}
 80024e0:	200004fc 	.word	0x200004fc

080024e4 <TL_THREAD_CliNotReceived>:
{
 80024e4:	b538      	push	{r3, r4, r5, lr}
  uint8_t l_size = l_CliBuffer->cmdserial.cmd.plen;
 80024e6:	7ac5      	ldrb	r5, [r0, #11]
  if (strcmp((const char *)l_CliBuffer->cmdserial.cmd.payload, "> ") != 0)
 80024e8:	f100 040c 	add.w	r4, r0, #12
 80024ec:	4907      	ldr	r1, [pc, #28]	; (800250c <TL_THREAD_CliNotReceived+0x28>)
 80024ee:	4620      	mov	r0, r4
 80024f0:	f7fd fe46 	bl	8000180 <strcmp>
 80024f4:	b910      	cbnz	r0, 80024fc <TL_THREAD_CliNotReceived+0x18>
    Send_CLI_Ack_For_OT();
 80024f6:	f7ff ffe1 	bl	80024bc <Send_CLI_Ack_For_OT>
}
 80024fa:	bd38      	pop	{r3, r4, r5, pc}
    HW_UART_Transmit_IT(CFG_CLI_UART, l_CliBuffer->cmdserial.cmd.payload, l_size, HostTxCb);
 80024fc:	4b04      	ldr	r3, [pc, #16]	; (8002510 <TL_THREAD_CliNotReceived+0x2c>)
 80024fe:	462a      	mov	r2, r5
 8002500:	4621      	mov	r1, r4
 8002502:	2000      	movs	r0, #0
 8002504:	f7fd fe4a 	bl	800019c <HW_UART_Transmit_IT>
 8002508:	e7f7      	b.n	80024fa <TL_THREAD_CliNotReceived+0x16>
 800250a:	bf00      	nop
 800250c:	08002884 	.word	0x08002884
 8002510:	080024c5 	.word	0x080024c5

08002514 <HW_IPCC_MM_FreeBufHandler>:

  return;
}

static void HW_IPCC_MM_FreeBufHandler( void )
{
 8002514:	b510      	push	{r4, lr}
  *         @arg @ref LL_IPCC_CHANNEL_6
  * @retval None
  */
__STATIC_INLINE void LL_C1_IPCC_DisableTransmitChannel(IPCC_TypeDef *IPCCx, uint32_t Channel)
{
  SET_BIT(IPCCx->C1MR, Channel << IPCC_C1MR_CH1FM_Pos);
 8002516:	4c06      	ldr	r4, [pc, #24]	; (8002530 <HW_IPCC_MM_FreeBufHandler+0x1c>)
 8002518:	6863      	ldr	r3, [r4, #4]
 800251a:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
 800251e:	6063      	str	r3, [r4, #4]
  LL_C1_IPCC_DisableTransmitChannel( IPCC, HW_IPCC_MM_RELEASE_BUFFER_CHANNEL );

  FreeBufCb();
 8002520:	4b04      	ldr	r3, [pc, #16]	; (8002534 <HW_IPCC_MM_FreeBufHandler+0x20>)
 8002522:	681b      	ldr	r3, [r3, #0]
 8002524:	4798      	blx	r3
  *         @arg @ref LL_IPCC_CHANNEL_6
  * @retval None
  */
__STATIC_INLINE void LL_C1_IPCC_SetFlag_CHx(IPCC_TypeDef *IPCCx, uint32_t Channel)
{
  WRITE_REG(IPCCx->C1SCR, Channel << IPCC_C1SCR_CH1S_Pos);
 8002526:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 800252a:	60a3      	str	r3, [r4, #8]

  LL_C1_IPCC_SetFlag_CHx( IPCC, HW_IPCC_MM_RELEASE_BUFFER_CHANNEL );

  return;
}
 800252c:	bd10      	pop	{r4, pc}
 800252e:	bf00      	nop
 8002530:	58000c00 	.word	0x58000c00
 8002534:	20000500 	.word	0x20000500

08002538 <HW_IPCC_THREAD_CliNotEvtHandler>:
{
 8002538:	b508      	push	{r3, lr}
  SET_BIT(IPCCx->C1MR, Channel);
 800253a:	4a04      	ldr	r2, [pc, #16]	; (800254c <HW_IPCC_THREAD_CliNotEvtHandler+0x14>)
 800253c:	6853      	ldr	r3, [r2, #4]
 800253e:	f043 0310 	orr.w	r3, r3, #16
 8002542:	6053      	str	r3, [r2, #4]
  HW_IPCC_THREAD_CliEvtNot();
 8002544:	f7ff ff78 	bl	8002438 <HW_IPCC_THREAD_CliEvtNot>
}
 8002548:	bd08      	pop	{r3, pc}
 800254a:	bf00      	nop
 800254c:	58000c00 	.word	0x58000c00

08002550 <HW_IPCC_BLE_AclDataEvtHandler>:
{
 8002550:	b508      	push	{r3, lr}
  SET_BIT(IPCCx->C1MR, Channel << IPCC_C1MR_CH1FM_Pos);
 8002552:	4a04      	ldr	r2, [pc, #16]	; (8002564 <HW_IPCC_BLE_AclDataEvtHandler+0x14>)
 8002554:	6853      	ldr	r3, [r2, #4]
 8002556:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 800255a:	6053      	str	r3, [r2, #4]
  HW_IPCC_BLE_AclDataAckNot();
 800255c:	f7ff ff20 	bl	80023a0 <HW_IPCC_BLE_AclDataAckNot>
}
 8002560:	bd08      	pop	{r3, pc}
 8002562:	bf00      	nop
 8002564:	58000c00 	.word	0x58000c00

08002568 <HW_IPCC_BLE_EvtHandler>:
{
 8002568:	b508      	push	{r3, lr}
  HW_IPCC_BLE_RxEvtNot();
 800256a:	f7ff ff01 	bl	8002370 <HW_IPCC_BLE_RxEvtNot>
  WRITE_REG(IPCCx->C1SCR, Channel);
 800256e:	4b02      	ldr	r3, [pc, #8]	; (8002578 <HW_IPCC_BLE_EvtHandler+0x10>)
 8002570:	2201      	movs	r2, #1
 8002572:	609a      	str	r2, [r3, #8]
}
 8002574:	bd08      	pop	{r3, pc}
 8002576:	bf00      	nop
 8002578:	58000c00 	.word	0x58000c00

0800257c <HW_IPCC_SYS_CmdEvtHandler>:
{
 800257c:	b508      	push	{r3, lr}
  SET_BIT(IPCCx->C1MR, Channel << IPCC_C1MR_CH1FM_Pos);
 800257e:	4a04      	ldr	r2, [pc, #16]	; (8002590 <HW_IPCC_SYS_CmdEvtHandler+0x14>)
 8002580:	6853      	ldr	r3, [r2, #4]
 8002582:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8002586:	6053      	str	r3, [r2, #4]
  HW_IPCC_SYS_CmdEvtNot();
 8002588:	f7ff ff12 	bl	80023b0 <HW_IPCC_SYS_CmdEvtNot>
}
 800258c:	bd08      	pop	{r3, pc}
 800258e:	bf00      	nop
 8002590:	58000c00 	.word	0x58000c00

08002594 <HW_IPCC_SYS_EvtHandler>:
{
 8002594:	b508      	push	{r3, lr}
  HW_IPCC_SYS_EvtNot();
 8002596:	f7ff ff17 	bl	80023c8 <HW_IPCC_SYS_EvtNot>
  WRITE_REG(IPCCx->C1SCR, Channel);
 800259a:	4b02      	ldr	r3, [pc, #8]	; (80025a4 <HW_IPCC_SYS_EvtHandler+0x10>)
 800259c:	2202      	movs	r2, #2
 800259e:	609a      	str	r2, [r3, #8]
}
 80025a0:	bd08      	pop	{r3, pc}
 80025a2:	bf00      	nop
 80025a4:	58000c00 	.word	0x58000c00

080025a8 <HW_IPCC_THREAD_CliSendAck>:
 80025a8:	4b03      	ldr	r3, [pc, #12]	; (80025b8 <HW_IPCC_THREAD_CliSendAck+0x10>)
 80025aa:	2210      	movs	r2, #16
 80025ac:	609a      	str	r2, [r3, #8]
  CLEAR_BIT(IPCCx->C1MR, Channel);
 80025ae:	685a      	ldr	r2, [r3, #4]
 80025b0:	f022 0210 	bic.w	r2, r2, #16
 80025b4:	605a      	str	r2, [r3, #4]
}
 80025b6:	4770      	bx	lr
 80025b8:	58000c00 	.word	0x58000c00

080025bc <HW_IPCC_OT_CmdEvtHandler>:
{
 80025bc:	b508      	push	{r3, lr}
  SET_BIT(IPCCx->C1MR, Channel << IPCC_C1MR_CH1FM_Pos);
 80025be:	4a04      	ldr	r2, [pc, #16]	; (80025d0 <HW_IPCC_OT_CmdEvtHandler+0x14>)
 80025c0:	6853      	ldr	r3, [r2, #4]
 80025c2:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 80025c6:	6053      	str	r3, [r2, #4]
  HW_IPCC_OT_CmdEvtNot();
 80025c8:	f7ff ff22 	bl	8002410 <HW_IPCC_OT_CmdEvtNot>
}
 80025cc:	bd08      	pop	{r3, pc}
 80025ce:	bf00      	nop
 80025d0:	58000c00 	.word	0x58000c00

080025d4 <HW_IPCC_Tx_Handler>:
{
 80025d4:	b508      	push	{r3, lr}
  *         @arg @ref LL_IPCC_CHANNEL_6
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_C1_IPCC_IsActiveFlag_CHx(IPCC_TypeDef  const *const IPCCx, uint32_t Channel)
{
  return ((READ_BIT(IPCCx->C1TOC2SR, Channel) == (Channel)) ? 1UL : 0UL);
 80025d6:	4b21      	ldr	r3, [pc, #132]	; (800265c <HW_IPCC_Tx_Handler+0x88>)
 80025d8:	68db      	ldr	r3, [r3, #12]
 80025da:	f013 0f02 	tst.w	r3, #2
 80025de:	d104      	bne.n	80025ea <HW_IPCC_Tx_Handler+0x16>
  if (HW_IPCC_TX_PENDING( HW_IPCC_SYSTEM_CMD_RSP_CHANNEL ))
 80025e0:	4b1e      	ldr	r3, [pc, #120]	; (800265c <HW_IPCC_Tx_Handler+0x88>)
 80025e2:	685b      	ldr	r3, [r3, #4]
 80025e4:	f413 3f00 	tst.w	r3, #131072	; 0x20000
 80025e8:	d028      	beq.n	800263c <HW_IPCC_Tx_Handler+0x68>
 80025ea:	4b1c      	ldr	r3, [pc, #112]	; (800265c <HW_IPCC_Tx_Handler+0x88>)
 80025ec:	68db      	ldr	r3, [r3, #12]
 80025ee:	f013 0f04 	tst.w	r3, #4
 80025f2:	d104      	bne.n	80025fe <HW_IPCC_Tx_Handler+0x2a>
  else if (HW_IPCC_TX_PENDING( HW_IPCC_THREAD_OT_CMD_RSP_CHANNEL ))
 80025f4:	4b19      	ldr	r3, [pc, #100]	; (800265c <HW_IPCC_Tx_Handler+0x88>)
 80025f6:	685b      	ldr	r3, [r3, #4]
 80025f8:	f413 2f80 	tst.w	r3, #262144	; 0x40000
 80025fc:	d021      	beq.n	8002642 <HW_IPCC_Tx_Handler+0x6e>
 80025fe:	4b17      	ldr	r3, [pc, #92]	; (800265c <HW_IPCC_Tx_Handler+0x88>)
 8002600:	68db      	ldr	r3, [r3, #12]
 8002602:	f013 0f02 	tst.w	r3, #2
 8002606:	d104      	bne.n	8002612 <HW_IPCC_Tx_Handler+0x3e>
  else if (HW_IPCC_TX_PENDING( HW_IPCC_SYSTEM_CMD_RSP_CHANNEL ))
 8002608:	4b14      	ldr	r3, [pc, #80]	; (800265c <HW_IPCC_Tx_Handler+0x88>)
 800260a:	685b      	ldr	r3, [r3, #4]
 800260c:	f413 3f00 	tst.w	r3, #131072	; 0x20000
 8002610:	d01a      	beq.n	8002648 <HW_IPCC_Tx_Handler+0x74>
 8002612:	4b12      	ldr	r3, [pc, #72]	; (800265c <HW_IPCC_Tx_Handler+0x88>)
 8002614:	68db      	ldr	r3, [r3, #12]
 8002616:	f013 0f08 	tst.w	r3, #8
 800261a:	d104      	bne.n	8002626 <HW_IPCC_Tx_Handler+0x52>
  else if (HW_IPCC_TX_PENDING( HW_IPCC_MM_RELEASE_BUFFER_CHANNEL ))
 800261c:	4b0f      	ldr	r3, [pc, #60]	; (800265c <HW_IPCC_Tx_Handler+0x88>)
 800261e:	685b      	ldr	r3, [r3, #4]
 8002620:	f413 2f00 	tst.w	r3, #524288	; 0x80000
 8002624:	d013      	beq.n	800264e <HW_IPCC_Tx_Handler+0x7a>
 8002626:	4b0d      	ldr	r3, [pc, #52]	; (800265c <HW_IPCC_Tx_Handler+0x88>)
 8002628:	68db      	ldr	r3, [r3, #12]
 800262a:	f013 0f20 	tst.w	r3, #32
 800262e:	d104      	bne.n	800263a <HW_IPCC_Tx_Handler+0x66>
  else if (HW_IPCC_TX_PENDING( HW_IPCC_HCI_ACL_DATA_CHANNEL ))
 8002630:	4b0a      	ldr	r3, [pc, #40]	; (800265c <HW_IPCC_Tx_Handler+0x88>)
 8002632:	685b      	ldr	r3, [r3, #4]
 8002634:	f413 1f00 	tst.w	r3, #2097152	; 0x200000
 8002638:	d00c      	beq.n	8002654 <HW_IPCC_Tx_Handler+0x80>
}
 800263a:	bd08      	pop	{r3, pc}
    HW_IPCC_SYS_CmdEvtHandler();
 800263c:	f7ff ff9e 	bl	800257c <HW_IPCC_SYS_CmdEvtHandler>
 8002640:	e7fb      	b.n	800263a <HW_IPCC_Tx_Handler+0x66>
    HW_IPCC_OT_CmdEvtHandler();
 8002642:	f7ff ffbb 	bl	80025bc <HW_IPCC_OT_CmdEvtHandler>
 8002646:	e7f8      	b.n	800263a <HW_IPCC_Tx_Handler+0x66>
    HW_IPCC_SYS_CmdEvtHandler();
 8002648:	f7ff ff98 	bl	800257c <HW_IPCC_SYS_CmdEvtHandler>
 800264c:	e7f5      	b.n	800263a <HW_IPCC_Tx_Handler+0x66>
    HW_IPCC_MM_FreeBufHandler();
 800264e:	f7ff ff61 	bl	8002514 <HW_IPCC_MM_FreeBufHandler>
 8002652:	e7f2      	b.n	800263a <HW_IPCC_Tx_Handler+0x66>
    HW_IPCC_BLE_AclDataEvtHandler();
 8002654:	f7ff ff7c 	bl	8002550 <HW_IPCC_BLE_AclDataEvtHandler>
  return;
 8002658:	e7ef      	b.n	800263a <HW_IPCC_Tx_Handler+0x66>
 800265a:	bf00      	nop
 800265c:	58000c00 	.word	0x58000c00

08002660 <HW_IPCC_THREAD_NotEvtHandler>:
{
 8002660:	b508      	push	{r3, lr}
  SET_BIT(IPCCx->C1MR, Channel);
 8002662:	4a04      	ldr	r2, [pc, #16]	; (8002674 <HW_IPCC_THREAD_NotEvtHandler+0x14>)
 8002664:	6853      	ldr	r3, [r2, #4]
 8002666:	f043 0304 	orr.w	r3, r3, #4
 800266a:	6053      	str	r3, [r2, #4]
  HW_IPCC_THREAD_EvtNot();
 800266c:	f7ff feda 	bl	8002424 <HW_IPCC_THREAD_EvtNot>
}
 8002670:	bd08      	pop	{r3, pc}
 8002672:	bf00      	nop
 8002674:	58000c00 	.word	0x58000c00

08002678 <HW_IPCC_MM_SendFreeBuf>:
{
 8002678:	b508      	push	{r3, lr}
  return ((READ_BIT(IPCCx->C1TOC2SR, Channel) == (Channel)) ? 1UL : 0UL);
 800267a:	4b09      	ldr	r3, [pc, #36]	; (80026a0 <HW_IPCC_MM_SendFreeBuf+0x28>)
 800267c:	68db      	ldr	r3, [r3, #12]
 800267e:	f013 0f08 	tst.w	r3, #8
 8002682:	d105      	bne.n	8002690 <HW_IPCC_MM_SendFreeBuf+0x18>
    cb();
 8002684:	4780      	blx	r0
  WRITE_REG(IPCCx->C1SCR, Channel << IPCC_C1SCR_CH1S_Pos);
 8002686:	4b06      	ldr	r3, [pc, #24]	; (80026a0 <HW_IPCC_MM_SendFreeBuf+0x28>)
 8002688:	f44f 2200 	mov.w	r2, #524288	; 0x80000
 800268c:	609a      	str	r2, [r3, #8]
}
 800268e:	bd08      	pop	{r3, pc}
    FreeBufCb = cb;
 8002690:	4b04      	ldr	r3, [pc, #16]	; (80026a4 <HW_IPCC_MM_SendFreeBuf+0x2c>)
 8002692:	6018      	str	r0, [r3, #0]
  CLEAR_BIT(IPCCx->C1MR, Channel << IPCC_C1MR_CH1FM_Pos);
 8002694:	4a02      	ldr	r2, [pc, #8]	; (80026a0 <HW_IPCC_MM_SendFreeBuf+0x28>)
 8002696:	6853      	ldr	r3, [r2, #4]
 8002698:	f423 2300 	bic.w	r3, r3, #524288	; 0x80000
 800269c:	6053      	str	r3, [r2, #4]
 800269e:	e7f6      	b.n	800268e <HW_IPCC_MM_SendFreeBuf+0x16>
 80026a0:	58000c00 	.word	0x58000c00
 80026a4:	20000500 	.word	0x20000500

080026a8 <HW_IPCC_TRACES_EvtHandler>:

  return;
}

static void HW_IPCC_TRACES_EvtHandler( void )
{
 80026a8:	b508      	push	{r3, lr}
  HW_IPCC_TRACES_EvtNot();
 80026aa:	f7ff fedd 	bl	8002468 <HW_IPCC_TRACES_EvtNot>
  WRITE_REG(IPCCx->C1SCR, Channel);
 80026ae:	4b02      	ldr	r3, [pc, #8]	; (80026b8 <HW_IPCC_TRACES_EvtHandler+0x10>)
 80026b0:	2208      	movs	r2, #8
 80026b2:	609a      	str	r2, [r3, #8]

  LL_C1_IPCC_ClearFlag_CHx( IPCC, HW_IPCC_TRACES_CHANNEL );

  return;
}
 80026b4:	bd08      	pop	{r3, pc}
 80026b6:	bf00      	nop
 80026b8:	58000c00 	.word	0x58000c00

080026bc <HW_IPCC_Rx_Handler>:
{
 80026bc:	b508      	push	{r3, lr}
  *         @arg @ref LL_IPCC_CHANNEL_6
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_C2_IPCC_IsActiveFlag_CHx(IPCC_TypeDef  const *const IPCCx, uint32_t Channel)
{
  return ((READ_BIT(IPCCx->C2TOC1SR, Channel) == (Channel)) ? 1UL : 0UL);
 80026be:	4b21      	ldr	r3, [pc, #132]	; (8002744 <HW_IPCC_Rx_Handler+0x88>)
 80026c0:	69db      	ldr	r3, [r3, #28]
 80026c2:	f013 0f02 	tst.w	r3, #2
 80026c6:	d004      	beq.n	80026d2 <HW_IPCC_Rx_Handler+0x16>
  if (HW_IPCC_RX_PENDING( HW_IPCC_SYSTEM_EVENT_CHANNEL ))
 80026c8:	4b1e      	ldr	r3, [pc, #120]	; (8002744 <HW_IPCC_Rx_Handler+0x88>)
 80026ca:	685b      	ldr	r3, [r3, #4]
 80026cc:	f013 0f02 	tst.w	r3, #2
 80026d0:	d028      	beq.n	8002724 <HW_IPCC_Rx_Handler+0x68>
 80026d2:	4b1c      	ldr	r3, [pc, #112]	; (8002744 <HW_IPCC_Rx_Handler+0x88>)
 80026d4:	69db      	ldr	r3, [r3, #28]
 80026d6:	f013 0f04 	tst.w	r3, #4
 80026da:	d004      	beq.n	80026e6 <HW_IPCC_Rx_Handler+0x2a>
  else if (HW_IPCC_RX_PENDING( HW_IPCC_THREAD_NOTIFICATION_ACK_CHANNEL ))
 80026dc:	4b19      	ldr	r3, [pc, #100]	; (8002744 <HW_IPCC_Rx_Handler+0x88>)
 80026de:	685b      	ldr	r3, [r3, #4]
 80026e0:	f013 0f04 	tst.w	r3, #4
 80026e4:	d021      	beq.n	800272a <HW_IPCC_Rx_Handler+0x6e>
 80026e6:	4b17      	ldr	r3, [pc, #92]	; (8002744 <HW_IPCC_Rx_Handler+0x88>)
 80026e8:	69db      	ldr	r3, [r3, #28]
 80026ea:	f013 0f10 	tst.w	r3, #16
 80026ee:	d004      	beq.n	80026fa <HW_IPCC_Rx_Handler+0x3e>
  else if (HW_IPCC_RX_PENDING( HW_IPCC_THREAD_CLI_NOTIFICATION_ACK_CHANNEL ))
 80026f0:	4b14      	ldr	r3, [pc, #80]	; (8002744 <HW_IPCC_Rx_Handler+0x88>)
 80026f2:	685b      	ldr	r3, [r3, #4]
 80026f4:	f013 0f10 	tst.w	r3, #16
 80026f8:	d01a      	beq.n	8002730 <HW_IPCC_Rx_Handler+0x74>
 80026fa:	4b12      	ldr	r3, [pc, #72]	; (8002744 <HW_IPCC_Rx_Handler+0x88>)
 80026fc:	69db      	ldr	r3, [r3, #28]
 80026fe:	f013 0f01 	tst.w	r3, #1
 8002702:	d004      	beq.n	800270e <HW_IPCC_Rx_Handler+0x52>
  else if (HW_IPCC_RX_PENDING( HW_IPCC_BLE_EVENT_CHANNEL ))
 8002704:	4b0f      	ldr	r3, [pc, #60]	; (8002744 <HW_IPCC_Rx_Handler+0x88>)
 8002706:	685b      	ldr	r3, [r3, #4]
 8002708:	f013 0f01 	tst.w	r3, #1
 800270c:	d013      	beq.n	8002736 <HW_IPCC_Rx_Handler+0x7a>
 800270e:	4b0d      	ldr	r3, [pc, #52]	; (8002744 <HW_IPCC_Rx_Handler+0x88>)
 8002710:	69db      	ldr	r3, [r3, #28]
 8002712:	f013 0f08 	tst.w	r3, #8
 8002716:	d004      	beq.n	8002722 <HW_IPCC_Rx_Handler+0x66>
  else if (HW_IPCC_RX_PENDING( HW_IPCC_TRACES_CHANNEL ))
 8002718:	4b0a      	ldr	r3, [pc, #40]	; (8002744 <HW_IPCC_Rx_Handler+0x88>)
 800271a:	685b      	ldr	r3, [r3, #4]
 800271c:	f013 0f08 	tst.w	r3, #8
 8002720:	d00c      	beq.n	800273c <HW_IPCC_Rx_Handler+0x80>
}
 8002722:	bd08      	pop	{r3, pc}
      HW_IPCC_SYS_EvtHandler();
 8002724:	f7ff ff36 	bl	8002594 <HW_IPCC_SYS_EvtHandler>
 8002728:	e7fb      	b.n	8002722 <HW_IPCC_Rx_Handler+0x66>
    HW_IPCC_THREAD_NotEvtHandler();
 800272a:	f7ff ff99 	bl	8002660 <HW_IPCC_THREAD_NotEvtHandler>
 800272e:	e7f8      	b.n	8002722 <HW_IPCC_Rx_Handler+0x66>
    HW_IPCC_THREAD_CliNotEvtHandler();
 8002730:	f7ff ff02 	bl	8002538 <HW_IPCC_THREAD_CliNotEvtHandler>
 8002734:	e7f5      	b.n	8002722 <HW_IPCC_Rx_Handler+0x66>
    HW_IPCC_BLE_EvtHandler();
 8002736:	f7ff ff17 	bl	8002568 <HW_IPCC_BLE_EvtHandler>
 800273a:	e7f2      	b.n	8002722 <HW_IPCC_Rx_Handler+0x66>
    HW_IPCC_TRACES_EvtHandler();
 800273c:	f7ff ffb4 	bl	80026a8 <HW_IPCC_TRACES_EvtHandler>
  return;
 8002740:	e7ef      	b.n	8002722 <HW_IPCC_Rx_Handler+0x66>
 8002742:	bf00      	nop
 8002744:	58000c00 	.word	0x58000c00

08002748 <__libc_init_array>:
 8002748:	b570      	push	{r4, r5, r6, lr}
 800274a:	4e0d      	ldr	r6, [pc, #52]	; (8002780 <__libc_init_array+0x38>)
 800274c:	4c0d      	ldr	r4, [pc, #52]	; (8002784 <__libc_init_array+0x3c>)
 800274e:	1ba4      	subs	r4, r4, r6
 8002750:	10a4      	asrs	r4, r4, #2
 8002752:	2500      	movs	r5, #0
 8002754:	42a5      	cmp	r5, r4
 8002756:	d109      	bne.n	800276c <__libc_init_array+0x24>
 8002758:	4e0b      	ldr	r6, [pc, #44]	; (8002788 <__libc_init_array+0x40>)
 800275a:	4c0c      	ldr	r4, [pc, #48]	; (800278c <__libc_init_array+0x44>)
 800275c:	f000 f820 	bl	80027a0 <_init>
 8002760:	1ba4      	subs	r4, r4, r6
 8002762:	10a4      	asrs	r4, r4, #2
 8002764:	2500      	movs	r5, #0
 8002766:	42a5      	cmp	r5, r4
 8002768:	d105      	bne.n	8002776 <__libc_init_array+0x2e>
 800276a:	bd70      	pop	{r4, r5, r6, pc}
 800276c:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 8002770:	4798      	blx	r3
 8002772:	3501      	adds	r5, #1
 8002774:	e7ee      	b.n	8002754 <__libc_init_array+0xc>
 8002776:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 800277a:	4798      	blx	r3
 800277c:	3501      	adds	r5, #1
 800277e:	e7f2      	b.n	8002766 <__libc_init_array+0x1e>
 8002780:	08002888 	.word	0x08002888
 8002784:	08002888 	.word	0x08002888
 8002788:	08002888 	.word	0x08002888
 800278c:	0800288c 	.word	0x0800288c

08002790 <memset>:
 8002790:	4402      	add	r2, r0
 8002792:	4603      	mov	r3, r0
 8002794:	4293      	cmp	r3, r2
 8002796:	d100      	bne.n	800279a <memset+0xa>
 8002798:	4770      	bx	lr
 800279a:	f803 1b01 	strb.w	r1, [r3], #1
 800279e:	e7f9      	b.n	8002794 <memset+0x4>

080027a0 <_init>:
 80027a0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80027a2:	bf00      	nop
 80027a4:	bcf8      	pop	{r3, r4, r5, r6, r7}
 80027a6:	bc08      	pop	{r3}
 80027a8:	469e      	mov	lr, r3
 80027aa:	4770      	bx	lr

080027ac <_fini>:
 80027ac:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80027ae:	bf00      	nop
 80027b0:	bcf8      	pop	{r3, r4, r5, r6, r7}
 80027b2:	bc08      	pop	{r3}
 80027b4:	469e      	mov	lr, r3
 80027b6:	4770      	bx	lr
